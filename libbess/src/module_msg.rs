// This file is generated by rust-protobuf 2.16.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `module_msg.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_16_2;

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EmptyArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmptyArg {
    fn default() -> &'a EmptyArg {
        <EmptyArg as ::protobuf::Message>::default_instance()
    }
}

impl EmptyArg {
    pub fn new() -> EmptyArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EmptyArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmptyArg {
        EmptyArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmptyArg>(
                "EmptyArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static EmptyArg {
        static instance: ::protobuf::rt::LazyV2<EmptyArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmptyArg::new)
    }
}

impl ::protobuf::Clear for EmptyArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmptyArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BPFCommandClearArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BPFCommandClearArg {
    fn default() -> &'a BPFCommandClearArg {
        <BPFCommandClearArg as ::protobuf::Message>::default_instance()
    }
}

impl BPFCommandClearArg {
    pub fn new() -> BPFCommandClearArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BPFCommandClearArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BPFCommandClearArg {
        BPFCommandClearArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BPFCommandClearArg>(
                "BPFCommandClearArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static BPFCommandClearArg {
        static instance: ::protobuf::rt::LazyV2<BPFCommandClearArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BPFCommandClearArg::new)
    }
}

impl ::protobuf::Clear for BPFCommandClearArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BPFCommandClearArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BPFCommandClearArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExactMatchCommandAddArg {
    // message fields
    pub gate: u64,
    pub fields: ::protobuf::RepeatedField<super::util_msg::FieldData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExactMatchCommandAddArg {
    fn default() -> &'a ExactMatchCommandAddArg {
        <ExactMatchCommandAddArg as ::protobuf::Message>::default_instance()
    }
}

impl ExactMatchCommandAddArg {
    pub fn new() -> ExactMatchCommandAddArg {
        ::std::default::Default::default()
    }

    // uint64 gate = 1;

    pub fn get_gate(&self) -> u64 {
        self.gate
    }
    pub fn clear_gate(&mut self) {
        self.gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate(&mut self, v: u64) {
        self.gate = v;
    }

    // repeated .bess.pb.FieldData fields = 2;

    pub fn get_fields(&self) -> &[super::util_msg::FieldData] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<super::util_msg::FieldData>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::FieldData> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<super::util_msg::FieldData> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExactMatchCommandAddArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.gate = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gate != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.gate, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.gate != 0 {
            os.write_uint64(1, self.gate)?;
        }
        for v in &self.fields {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExactMatchCommandAddArg {
        ExactMatchCommandAddArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "gate",
                |m: &ExactMatchCommandAddArg| &m.gate,
                |m: &mut ExactMatchCommandAddArg| &mut m.gate,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::FieldData>,
                >(
                    "fields",
                    |m: &ExactMatchCommandAddArg| &m.fields,
                    |m: &mut ExactMatchCommandAddArg| &mut m.fields,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExactMatchCommandAddArg>(
                "ExactMatchCommandAddArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ExactMatchCommandAddArg {
        static instance: ::protobuf::rt::LazyV2<ExactMatchCommandAddArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ExactMatchCommandAddArg::new)
    }
}

impl ::protobuf::Clear for ExactMatchCommandAddArg {
    fn clear(&mut self) {
        self.gate = 0;
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExactMatchCommandAddArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExactMatchCommandAddArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExactMatchCommandDeleteArg {
    // message fields
    pub fields: ::protobuf::RepeatedField<super::util_msg::FieldData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExactMatchCommandDeleteArg {
    fn default() -> &'a ExactMatchCommandDeleteArg {
        <ExactMatchCommandDeleteArg as ::protobuf::Message>::default_instance()
    }
}

impl ExactMatchCommandDeleteArg {
    pub fn new() -> ExactMatchCommandDeleteArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.FieldData fields = 2;

    pub fn get_fields(&self) -> &[super::util_msg::FieldData] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<super::util_msg::FieldData>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::FieldData> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<super::util_msg::FieldData> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExactMatchCommandDeleteArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExactMatchCommandDeleteArg {
        ExactMatchCommandDeleteArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::FieldData>,
                >(
                    "fields",
                    |m: &ExactMatchCommandDeleteArg| &m.fields,
                    |m: &mut ExactMatchCommandDeleteArg| &mut m.fields,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExactMatchCommandDeleteArg>(
                "ExactMatchCommandDeleteArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ExactMatchCommandDeleteArg {
        static instance: ::protobuf::rt::LazyV2<ExactMatchCommandDeleteArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ExactMatchCommandDeleteArg::new)
    }
}

impl ::protobuf::Clear for ExactMatchCommandDeleteArg {
    fn clear(&mut self) {
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExactMatchCommandDeleteArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExactMatchCommandDeleteArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExactMatchCommandClearArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExactMatchCommandClearArg {
    fn default() -> &'a ExactMatchCommandClearArg {
        <ExactMatchCommandClearArg as ::protobuf::Message>::default_instance()
    }
}

impl ExactMatchCommandClearArg {
    pub fn new() -> ExactMatchCommandClearArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ExactMatchCommandClearArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExactMatchCommandClearArg {
        ExactMatchCommandClearArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExactMatchCommandClearArg>(
                "ExactMatchCommandClearArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ExactMatchCommandClearArg {
        static instance: ::protobuf::rt::LazyV2<ExactMatchCommandClearArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ExactMatchCommandClearArg::new)
    }
}

impl ::protobuf::Clear for ExactMatchCommandClearArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExactMatchCommandClearArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExactMatchCommandClearArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExactMatchCommandSetDefaultGateArg {
    // message fields
    pub gate: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExactMatchCommandSetDefaultGateArg {
    fn default() -> &'a ExactMatchCommandSetDefaultGateArg {
        <ExactMatchCommandSetDefaultGateArg as ::protobuf::Message>::default_instance()
    }
}

impl ExactMatchCommandSetDefaultGateArg {
    pub fn new() -> ExactMatchCommandSetDefaultGateArg {
        ::std::default::Default::default()
    }

    // uint64 gate = 1;

    pub fn get_gate(&self) -> u64 {
        self.gate
    }
    pub fn clear_gate(&mut self) {
        self.gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate(&mut self, v: u64) {
        self.gate = v;
    }
}

impl ::protobuf::Message for ExactMatchCommandSetDefaultGateArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.gate = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gate != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.gate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.gate != 0 {
            os.write_uint64(1, self.gate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExactMatchCommandSetDefaultGateArg {
        ExactMatchCommandSetDefaultGateArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gate",
                |m: &ExactMatchCommandSetDefaultGateArg| { &m.gate },
                |m: &mut ExactMatchCommandSetDefaultGateArg| { &mut m.gate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExactMatchCommandSetDefaultGateArg>(
                "ExactMatchCommandSetDefaultGateArg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExactMatchCommandSetDefaultGateArg {
        static instance: ::protobuf::rt::LazyV2<ExactMatchCommandSetDefaultGateArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ExactMatchCommandSetDefaultGateArg::new)
    }
}

impl ::protobuf::Clear for ExactMatchCommandSetDefaultGateArg {
    fn clear(&mut self) {
        self.gate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExactMatchCommandSetDefaultGateArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExactMatchCommandSetDefaultGateArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FlowGenCommandSetBurstArg {
    // message fields
    pub burst: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowGenCommandSetBurstArg {
    fn default() -> &'a FlowGenCommandSetBurstArg {
        <FlowGenCommandSetBurstArg as ::protobuf::Message>::default_instance()
    }
}

impl FlowGenCommandSetBurstArg {
    pub fn new() -> FlowGenCommandSetBurstArg {
        ::std::default::Default::default()
    }

    // uint64 burst = 1;

    pub fn get_burst(&self) -> u64 {
        self.burst
    }
    pub fn clear_burst(&mut self) {
        self.burst = 0;
    }

    // Param is passed by value, moved
    pub fn set_burst(&mut self, v: u64) {
        self.burst = v;
    }
}

impl ::protobuf::Message for FlowGenCommandSetBurstArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.burst = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.burst != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.burst, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.burst != 0 {
            os.write_uint64(1, self.burst)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowGenCommandSetBurstArg {
        FlowGenCommandSetBurstArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "burst",
                |m: &FlowGenCommandSetBurstArg| &m.burst,
                |m: &mut FlowGenCommandSetBurstArg| &mut m.burst,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlowGenCommandSetBurstArg>(
                "FlowGenCommandSetBurstArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static FlowGenCommandSetBurstArg {
        static instance: ::protobuf::rt::LazyV2<FlowGenCommandSetBurstArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(FlowGenCommandSetBurstArg::new)
    }
}

impl ::protobuf::Clear for FlowGenCommandSetBurstArg {
    fn clear(&mut self) {
        self.burst = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowGenCommandSetBurstArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowGenCommandSetBurstArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct HashLBCommandSetModeArg {
    // message fields
    pub mode: ::std::string::String,
    pub fields: ::protobuf::RepeatedField<super::util_msg::Field>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashLBCommandSetModeArg {
    fn default() -> &'a HashLBCommandSetModeArg {
        <HashLBCommandSetModeArg as ::protobuf::Message>::default_instance()
    }
}

impl HashLBCommandSetModeArg {
    pub fn new() -> HashLBCommandSetModeArg {
        ::std::default::Default::default()
    }

    // string mode = 1;

    pub fn get_mode(&self) -> &str {
        &self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ::std::string::String) {
        self.mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut ::std::string::String {
        &mut self.mode
    }

    // Take field
    pub fn take_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mode, ::std::string::String::new())
    }

    // repeated .bess.pb.Field fields = 2;

    pub fn get_fields(&self) -> &[super::util_msg::Field] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<super::util_msg::Field>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::Field> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<super::util_msg::Field> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HashLBCommandSetModeArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mode,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mode);
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.mode.is_empty() {
            os.write_string(1, &self.mode)?;
        }
        for v in &self.fields {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashLBCommandSetModeArg {
        HashLBCommandSetModeArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mode",
                |m: &HashLBCommandSetModeArg| &m.mode,
                |m: &mut HashLBCommandSetModeArg| &mut m.mode,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::Field>,
                >(
                    "fields",
                    |m: &HashLBCommandSetModeArg| &m.fields,
                    |m: &mut HashLBCommandSetModeArg| &mut m.fields,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HashLBCommandSetModeArg>(
                "HashLBCommandSetModeArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static HashLBCommandSetModeArg {
        static instance: ::protobuf::rt::LazyV2<HashLBCommandSetModeArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(HashLBCommandSetModeArg::new)
    }
}

impl ::protobuf::Clear for HashLBCommandSetModeArg {
    fn clear(&mut self) {
        self.mode.clear();
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashLBCommandSetModeArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashLBCommandSetModeArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct HashLBCommandSetGatesArg {
    // message fields
    pub gates: ::std::vec::Vec<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashLBCommandSetGatesArg {
    fn default() -> &'a HashLBCommandSetGatesArg {
        <HashLBCommandSetGatesArg as ::protobuf::Message>::default_instance()
    }
}

impl HashLBCommandSetGatesArg {
    pub fn new() -> HashLBCommandSetGatesArg {
        ::std::default::Default::default()
    }

    // repeated int64 gates = 1;

    pub fn get_gates(&self) -> &[i64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<i64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for HashLBCommandSetGatesArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gates {
            os.write_int64(1, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashLBCommandSetGatesArg {
        HashLBCommandSetGatesArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gates",
                |m: &HashLBCommandSetGatesArg| &m.gates,
                |m: &mut HashLBCommandSetGatesArg| &mut m.gates,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HashLBCommandSetGatesArg>(
                "HashLBCommandSetGatesArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static HashLBCommandSetGatesArg {
        static instance: ::protobuf::rt::LazyV2<HashLBCommandSetGatesArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(HashLBCommandSetGatesArg::new)
    }
}

impl ::protobuf::Clear for HashLBCommandSetGatesArg {
    fn clear(&mut self) {
        self.gates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashLBCommandSetGatesArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashLBCommandSetGatesArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IPLookupCommandAddArg {
    // message fields
    pub prefix: ::std::string::String,
    pub prefix_len: u64,
    pub gate: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLookupCommandAddArg {
    fn default() -> &'a IPLookupCommandAddArg {
        <IPLookupCommandAddArg as ::protobuf::Message>::default_instance()
    }
}

impl IPLookupCommandAddArg {
    pub fn new() -> IPLookupCommandAddArg {
        ::std::default::Default::default()
    }

    // string prefix = 1;

    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // uint64 prefix_len = 2;

    pub fn get_prefix_len(&self) -> u64 {
        self.prefix_len
    }
    pub fn clear_prefix_len(&mut self) {
        self.prefix_len = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_len(&mut self, v: u64) {
        self.prefix_len = v;
    }

    // uint64 gate = 3;

    pub fn get_gate(&self) -> u64 {
        self.gate
    }
    pub fn clear_gate(&mut self) {
        self.gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate(&mut self, v: u64) {
        self.gate = v;
    }
}

impl ::protobuf::Message for IPLookupCommandAddArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.prefix,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.prefix_len = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.gate = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if self.prefix_len != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.prefix_len,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.gate != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.gate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if self.prefix_len != 0 {
            os.write_uint64(2, self.prefix_len)?;
        }
        if self.gate != 0 {
            os.write_uint64(3, self.gate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLookupCommandAddArg {
        IPLookupCommandAddArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "prefix",
                |m: &IPLookupCommandAddArg| &m.prefix,
                |m: &mut IPLookupCommandAddArg| &mut m.prefix,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "prefix_len",
                |m: &IPLookupCommandAddArg| &m.prefix_len,
                |m: &mut IPLookupCommandAddArg| &mut m.prefix_len,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "gate",
                |m: &IPLookupCommandAddArg| &m.gate,
                |m: &mut IPLookupCommandAddArg| &mut m.gate,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLookupCommandAddArg>(
                "IPLookupCommandAddArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static IPLookupCommandAddArg {
        static instance: ::protobuf::rt::LazyV2<IPLookupCommandAddArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(IPLookupCommandAddArg::new)
    }
}

impl ::protobuf::Clear for IPLookupCommandAddArg {
    fn clear(&mut self) {
        self.prefix.clear();
        self.prefix_len = 0;
        self.gate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLookupCommandAddArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLookupCommandAddArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IPLookupCommandDeleteArg {
    // message fields
    pub prefix: ::std::string::String,
    pub prefix_len: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLookupCommandDeleteArg {
    fn default() -> &'a IPLookupCommandDeleteArg {
        <IPLookupCommandDeleteArg as ::protobuf::Message>::default_instance()
    }
}

impl IPLookupCommandDeleteArg {
    pub fn new() -> IPLookupCommandDeleteArg {
        ::std::default::Default::default()
    }

    // string prefix = 1;

    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // uint64 prefix_len = 2;

    pub fn get_prefix_len(&self) -> u64 {
        self.prefix_len
    }
    pub fn clear_prefix_len(&mut self) {
        self.prefix_len = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_len(&mut self, v: u64) {
        self.prefix_len = v;
    }
}

impl ::protobuf::Message for IPLookupCommandDeleteArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.prefix,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.prefix_len = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if self.prefix_len != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.prefix_len,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if self.prefix_len != 0 {
            os.write_uint64(2, self.prefix_len)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLookupCommandDeleteArg {
        IPLookupCommandDeleteArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "prefix",
                |m: &IPLookupCommandDeleteArg| &m.prefix,
                |m: &mut IPLookupCommandDeleteArg| &mut m.prefix,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "prefix_len",
                |m: &IPLookupCommandDeleteArg| &m.prefix_len,
                |m: &mut IPLookupCommandDeleteArg| &mut m.prefix_len,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLookupCommandDeleteArg>(
                "IPLookupCommandDeleteArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static IPLookupCommandDeleteArg {
        static instance: ::protobuf::rt::LazyV2<IPLookupCommandDeleteArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(IPLookupCommandDeleteArg::new)
    }
}

impl ::protobuf::Clear for IPLookupCommandDeleteArg {
    fn clear(&mut self) {
        self.prefix.clear();
        self.prefix_len = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLookupCommandDeleteArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLookupCommandDeleteArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IPLookupCommandClearArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLookupCommandClearArg {
    fn default() -> &'a IPLookupCommandClearArg {
        <IPLookupCommandClearArg as ::protobuf::Message>::default_instance()
    }
}

impl IPLookupCommandClearArg {
    pub fn new() -> IPLookupCommandClearArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IPLookupCommandClearArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLookupCommandClearArg {
        IPLookupCommandClearArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLookupCommandClearArg>(
                "IPLookupCommandClearArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static IPLookupCommandClearArg {
        static instance: ::protobuf::rt::LazyV2<IPLookupCommandClearArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(IPLookupCommandClearArg::new)
    }
}

impl ::protobuf::Clear for IPLookupCommandClearArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLookupCommandClearArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLookupCommandClearArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L2ForwardCommandAddArg {
    // message fields
    pub entries: ::protobuf::RepeatedField<L2ForwardCommandAddArg_Entry>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L2ForwardCommandAddArg {
    fn default() -> &'a L2ForwardCommandAddArg {
        <L2ForwardCommandAddArg as ::protobuf::Message>::default_instance()
    }
}

impl L2ForwardCommandAddArg {
    pub fn new() -> L2ForwardCommandAddArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.L2ForwardCommandAddArg.Entry entries = 1;

    pub fn get_entries(&self) -> &[L2ForwardCommandAddArg_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<L2ForwardCommandAddArg_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<L2ForwardCommandAddArg_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<L2ForwardCommandAddArg_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for L2ForwardCommandAddArg {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L2ForwardCommandAddArg {
        L2ForwardCommandAddArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<L2ForwardCommandAddArg_Entry>,
                >(
                    "entries",
                    |m: &L2ForwardCommandAddArg| &m.entries,
                    |m: &mut L2ForwardCommandAddArg| &mut m.entries,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L2ForwardCommandAddArg>(
                "L2ForwardCommandAddArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static L2ForwardCommandAddArg {
        static instance: ::protobuf::rt::LazyV2<L2ForwardCommandAddArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(L2ForwardCommandAddArg::new)
    }
}

impl ::protobuf::Clear for L2ForwardCommandAddArg {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L2ForwardCommandAddArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L2ForwardCommandAddArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L2ForwardCommandAddArg_Entry {
    // message fields
    pub addr: ::std::string::String,
    pub gate: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L2ForwardCommandAddArg_Entry {
    fn default() -> &'a L2ForwardCommandAddArg_Entry {
        <L2ForwardCommandAddArg_Entry as ::protobuf::Message>::default_instance()
    }
}

impl L2ForwardCommandAddArg_Entry {
    pub fn new() -> L2ForwardCommandAddArg_Entry {
        ::std::default::Default::default()
    }

    // string addr = 1;

    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }

    // int64 gate = 2;

    pub fn get_gate(&self) -> i64 {
        self.gate
    }
    pub fn clear_gate(&mut self) {
        self.gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate(&mut self, v: i64) {
        self.gate = v;
    }
}

impl ::protobuf::Message for L2ForwardCommandAddArg_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.addr,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.gate = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.addr);
        }
        if self.gate != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.gate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.addr.is_empty() {
            os.write_string(1, &self.addr)?;
        }
        if self.gate != 0 {
            os.write_int64(2, self.gate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L2ForwardCommandAddArg_Entry {
        L2ForwardCommandAddArg_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "addr",
                |m: &L2ForwardCommandAddArg_Entry| &m.addr,
                |m: &mut L2ForwardCommandAddArg_Entry| &mut m.addr,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gate",
                |m: &L2ForwardCommandAddArg_Entry| &m.gate,
                |m: &mut L2ForwardCommandAddArg_Entry| &mut m.gate,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L2ForwardCommandAddArg_Entry>(
                "L2ForwardCommandAddArg.Entry",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static L2ForwardCommandAddArg_Entry {
        static instance: ::protobuf::rt::LazyV2<L2ForwardCommandAddArg_Entry> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(L2ForwardCommandAddArg_Entry::new)
    }
}

impl ::protobuf::Clear for L2ForwardCommandAddArg_Entry {
    fn clear(&mut self) {
        self.addr.clear();
        self.gate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L2ForwardCommandAddArg_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L2ForwardCommandAddArg_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L2ForwardCommandDeleteArg {
    // message fields
    pub addrs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L2ForwardCommandDeleteArg {
    fn default() -> &'a L2ForwardCommandDeleteArg {
        <L2ForwardCommandDeleteArg as ::protobuf::Message>::default_instance()
    }
}

impl L2ForwardCommandDeleteArg {
    pub fn new() -> L2ForwardCommandDeleteArg {
        ::std::default::Default::default()
    }

    // repeated string addrs = 1;

    pub fn get_addrs(&self) -> &[::std::string::String] {
        &self.addrs
    }
    pub fn clear_addrs(&mut self) {
        self.addrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_addrs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addrs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addrs
    }

    // Take field
    pub fn take_addrs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addrs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for L2ForwardCommandDeleteArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addrs)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addrs {
            my_size += ::protobuf::rt::string_size(1, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addrs {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L2ForwardCommandDeleteArg {
        L2ForwardCommandDeleteArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "addrs",
                    |m: &L2ForwardCommandDeleteArg| &m.addrs,
                    |m: &mut L2ForwardCommandDeleteArg| &mut m.addrs,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L2ForwardCommandDeleteArg>(
                "L2ForwardCommandDeleteArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static L2ForwardCommandDeleteArg {
        static instance: ::protobuf::rt::LazyV2<L2ForwardCommandDeleteArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(L2ForwardCommandDeleteArg::new)
    }
}

impl ::protobuf::Clear for L2ForwardCommandDeleteArg {
    fn clear(&mut self) {
        self.addrs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L2ForwardCommandDeleteArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L2ForwardCommandDeleteArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L2ForwardCommandSetDefaultGateArg {
    // message fields
    pub gate: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L2ForwardCommandSetDefaultGateArg {
    fn default() -> &'a L2ForwardCommandSetDefaultGateArg {
        <L2ForwardCommandSetDefaultGateArg as ::protobuf::Message>::default_instance()
    }
}

impl L2ForwardCommandSetDefaultGateArg {
    pub fn new() -> L2ForwardCommandSetDefaultGateArg {
        ::std::default::Default::default()
    }

    // int64 gate = 1;

    pub fn get_gate(&self) -> i64 {
        self.gate
    }
    pub fn clear_gate(&mut self) {
        self.gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate(&mut self, v: i64) {
        self.gate = v;
    }
}

impl ::protobuf::Message for L2ForwardCommandSetDefaultGateArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.gate = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gate != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.gate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.gate != 0 {
            os.write_int64(1, self.gate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L2ForwardCommandSetDefaultGateArg {
        L2ForwardCommandSetDefaultGateArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "gate",
                |m: &L2ForwardCommandSetDefaultGateArg| { &m.gate },
                |m: &mut L2ForwardCommandSetDefaultGateArg| { &mut m.gate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L2ForwardCommandSetDefaultGateArg>(
                "L2ForwardCommandSetDefaultGateArg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static L2ForwardCommandSetDefaultGateArg {
        static instance: ::protobuf::rt::LazyV2<L2ForwardCommandSetDefaultGateArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(L2ForwardCommandSetDefaultGateArg::new)
    }
}

impl ::protobuf::Clear for L2ForwardCommandSetDefaultGateArg {
    fn clear(&mut self) {
        self.gate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L2ForwardCommandSetDefaultGateArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L2ForwardCommandSetDefaultGateArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L2ForwardCommandLookupArg {
    // message fields
    pub addrs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L2ForwardCommandLookupArg {
    fn default() -> &'a L2ForwardCommandLookupArg {
        <L2ForwardCommandLookupArg as ::protobuf::Message>::default_instance()
    }
}

impl L2ForwardCommandLookupArg {
    pub fn new() -> L2ForwardCommandLookupArg {
        ::std::default::Default::default()
    }

    // repeated string addrs = 1;

    pub fn get_addrs(&self) -> &[::std::string::String] {
        &self.addrs
    }
    pub fn clear_addrs(&mut self) {
        self.addrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_addrs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addrs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addrs
    }

    // Take field
    pub fn take_addrs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addrs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for L2ForwardCommandLookupArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addrs)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addrs {
            my_size += ::protobuf::rt::string_size(1, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addrs {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L2ForwardCommandLookupArg {
        L2ForwardCommandLookupArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "addrs",
                    |m: &L2ForwardCommandLookupArg| &m.addrs,
                    |m: &mut L2ForwardCommandLookupArg| &mut m.addrs,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L2ForwardCommandLookupArg>(
                "L2ForwardCommandLookupArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static L2ForwardCommandLookupArg {
        static instance: ::protobuf::rt::LazyV2<L2ForwardCommandLookupArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(L2ForwardCommandLookupArg::new)
    }
}

impl ::protobuf::Clear for L2ForwardCommandLookupArg {
    fn clear(&mut self) {
        self.addrs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L2ForwardCommandLookupArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L2ForwardCommandLookupArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L2ForwardCommandLookupResponse {
    // message fields
    pub gates: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L2ForwardCommandLookupResponse {
    fn default() -> &'a L2ForwardCommandLookupResponse {
        <L2ForwardCommandLookupResponse as ::protobuf::Message>::default_instance()
    }
}

impl L2ForwardCommandLookupResponse {
    pub fn new() -> L2ForwardCommandLookupResponse {
        ::std::default::Default::default()
    }

    // repeated uint64 gates = 1;

    pub fn get_gates(&self) -> &[u64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<u64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for L2ForwardCommandLookupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.gates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gates {
            os.write_uint64(1, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L2ForwardCommandLookupResponse {
        L2ForwardCommandLookupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "gates",
                |m: &L2ForwardCommandLookupResponse| &m.gates,
                |m: &mut L2ForwardCommandLookupResponse| &mut m.gates,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L2ForwardCommandLookupResponse>(
                "L2ForwardCommandLookupResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static L2ForwardCommandLookupResponse {
        static instance: ::protobuf::rt::LazyV2<L2ForwardCommandLookupResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(L2ForwardCommandLookupResponse::new)
    }
}

impl ::protobuf::Clear for L2ForwardCommandLookupResponse {
    fn clear(&mut self) {
        self.gates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L2ForwardCommandLookupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L2ForwardCommandLookupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L2ForwardCommandPopulateArg {
    // message fields
    pub base: ::std::string::String,
    pub count: i64,
    pub gate_count: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L2ForwardCommandPopulateArg {
    fn default() -> &'a L2ForwardCommandPopulateArg {
        <L2ForwardCommandPopulateArg as ::protobuf::Message>::default_instance()
    }
}

impl L2ForwardCommandPopulateArg {
    pub fn new() -> L2ForwardCommandPopulateArg {
        ::std::default::Default::default()
    }

    // string base = 1;

    pub fn get_base(&self) -> &str {
        &self.base
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: ::std::string::String) {
        self.base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut ::std::string::String {
        &mut self.base
    }

    // Take field
    pub fn take_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base, ::std::string::String::new())
    }

    // int64 count = 2;

    pub fn get_count(&self) -> i64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = v;
    }

    // int64 gate_count = 3;

    pub fn get_gate_count(&self) -> i64 {
        self.gate_count
    }
    pub fn clear_gate_count(&mut self) {
        self.gate_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate_count(&mut self, v: i64) {
        self.gate_count = v;
    }
}

impl ::protobuf::Message for L2ForwardCommandPopulateArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.base,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.count = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.gate_count = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.base.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.base);
        }
        if self.count != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.gate_count != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.gate_count,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.base.is_empty() {
            os.write_string(1, &self.base)?;
        }
        if self.count != 0 {
            os.write_int64(2, self.count)?;
        }
        if self.gate_count != 0 {
            os.write_int64(3, self.gate_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L2ForwardCommandPopulateArg {
        L2ForwardCommandPopulateArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "base",
                |m: &L2ForwardCommandPopulateArg| &m.base,
                |m: &mut L2ForwardCommandPopulateArg| &mut m.base,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "count",
                |m: &L2ForwardCommandPopulateArg| &m.count,
                |m: &mut L2ForwardCommandPopulateArg| &mut m.count,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gate_count",
                |m: &L2ForwardCommandPopulateArg| &m.gate_count,
                |m: &mut L2ForwardCommandPopulateArg| &mut m.gate_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L2ForwardCommandPopulateArg>(
                "L2ForwardCommandPopulateArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static L2ForwardCommandPopulateArg {
        static instance: ::protobuf::rt::LazyV2<L2ForwardCommandPopulateArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(L2ForwardCommandPopulateArg::new)
    }
}

impl ::protobuf::Clear for L2ForwardCommandPopulateArg {
    fn clear(&mut self) {
        self.base.clear();
        self.count = 0;
        self.gate_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L2ForwardCommandPopulateArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L2ForwardCommandPopulateArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MeasureCommandGetSummaryArg {
    // message fields
    pub clear: bool,
    pub latency_percentiles: ::std::vec::Vec<f64>,
    pub jitter_percentiles: ::std::vec::Vec<f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeasureCommandGetSummaryArg {
    fn default() -> &'a MeasureCommandGetSummaryArg {
        <MeasureCommandGetSummaryArg as ::protobuf::Message>::default_instance()
    }
}

impl MeasureCommandGetSummaryArg {
    pub fn new() -> MeasureCommandGetSummaryArg {
        ::std::default::Default::default()
    }

    // bool clear = 1;

    pub fn get_clear(&self) -> bool {
        self.clear
    }
    pub fn clear_clear(&mut self) {
        self.clear = false;
    }

    // Param is passed by value, moved
    pub fn set_clear(&mut self, v: bool) {
        self.clear = v;
    }

    // repeated double latency_percentiles = 2;

    pub fn get_latency_percentiles(&self) -> &[f64] {
        &self.latency_percentiles
    }
    pub fn clear_latency_percentiles(&mut self) {
        self.latency_percentiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_latency_percentiles(&mut self, v: ::std::vec::Vec<f64>) {
        self.latency_percentiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latency_percentiles(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.latency_percentiles
    }

    // Take field
    pub fn take_latency_percentiles(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.latency_percentiles, ::std::vec::Vec::new())
    }

    // repeated double jitter_percentiles = 3;

    pub fn get_jitter_percentiles(&self) -> &[f64] {
        &self.jitter_percentiles
    }
    pub fn clear_jitter_percentiles(&mut self) {
        self.jitter_percentiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_jitter_percentiles(&mut self, v: ::std::vec::Vec<f64>) {
        self.jitter_percentiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_jitter_percentiles(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.jitter_percentiles
    }

    // Take field
    pub fn take_jitter_percentiles(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.jitter_percentiles, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MeasureCommandGetSummaryArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.clear = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_double_into(
                        wire_type,
                        is,
                        &mut self.latency_percentiles,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_repeated_double_into(
                        wire_type,
                        is,
                        &mut self.jitter_percentiles,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.clear != false {
            my_size += 2;
        }
        my_size += 9 * self.latency_percentiles.len() as u32;
        my_size += 9 * self.jitter_percentiles.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.clear != false {
            os.write_bool(1, self.clear)?;
        }
        for v in &self.latency_percentiles {
            os.write_double(2, *v)?;
        }
        for v in &self.jitter_percentiles {
            os.write_double(3, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureCommandGetSummaryArg {
        MeasureCommandGetSummaryArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "clear",
                |m: &MeasureCommandGetSummaryArg| &m.clear,
                |m: &mut MeasureCommandGetSummaryArg| &mut m.clear,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "latency_percentiles",
                |m: &MeasureCommandGetSummaryArg| &m.latency_percentiles,
                |m: &mut MeasureCommandGetSummaryArg| &mut m.latency_percentiles,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "jitter_percentiles",
                |m: &MeasureCommandGetSummaryArg| &m.jitter_percentiles,
                |m: &mut MeasureCommandGetSummaryArg| &mut m.jitter_percentiles,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MeasureCommandGetSummaryArg>(
                "MeasureCommandGetSummaryArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MeasureCommandGetSummaryArg {
        static instance: ::protobuf::rt::LazyV2<MeasureCommandGetSummaryArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(MeasureCommandGetSummaryArg::new)
    }
}

impl ::protobuf::Clear for MeasureCommandGetSummaryArg {
    fn clear(&mut self) {
        self.clear = false;
        self.latency_percentiles.clear();
        self.jitter_percentiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureCommandGetSummaryArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureCommandGetSummaryArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MeasureCommandGetSummaryResponse {
    // message fields
    pub timestamp: f64,
    pub packets: u64,
    pub bits: u64,
    pub latency: ::protobuf::SingularPtrField<MeasureCommandGetSummaryResponse_Histogram>,
    pub jitter: ::protobuf::SingularPtrField<MeasureCommandGetSummaryResponse_Histogram>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeasureCommandGetSummaryResponse {
    fn default() -> &'a MeasureCommandGetSummaryResponse {
        <MeasureCommandGetSummaryResponse as ::protobuf::Message>::default_instance()
    }
}

impl MeasureCommandGetSummaryResponse {
    pub fn new() -> MeasureCommandGetSummaryResponse {
        ::std::default::Default::default()
    }

    // double timestamp = 1;

    pub fn get_timestamp(&self) -> f64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0.;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = v;
    }

    // uint64 packets = 2;

    pub fn get_packets(&self) -> u64 {
        self.packets
    }
    pub fn clear_packets(&mut self) {
        self.packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: u64) {
        self.packets = v;
    }

    // uint64 bits = 3;

    pub fn get_bits(&self) -> u64 {
        self.bits
    }
    pub fn clear_bits(&mut self) {
        self.bits = 0;
    }

    // Param is passed by value, moved
    pub fn set_bits(&mut self, v: u64) {
        self.bits = v;
    }

    // .bess.pb.MeasureCommandGetSummaryResponse.Histogram latency = 4;

    pub fn get_latency(&self) -> &MeasureCommandGetSummaryResponse_Histogram {
        self.latency.as_ref().unwrap_or_else(|| {
            <MeasureCommandGetSummaryResponse_Histogram as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_latency(&mut self) {
        self.latency.clear();
    }

    pub fn has_latency(&self) -> bool {
        self.latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latency(&mut self, v: MeasureCommandGetSummaryResponse_Histogram) {
        self.latency = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latency(&mut self) -> &mut MeasureCommandGetSummaryResponse_Histogram {
        if self.latency.is_none() {
            self.latency.set_default();
        }
        self.latency.as_mut().unwrap()
    }

    // Take field
    pub fn take_latency(&mut self) -> MeasureCommandGetSummaryResponse_Histogram {
        self.latency
            .take()
            .unwrap_or_else(|| MeasureCommandGetSummaryResponse_Histogram::new())
    }

    // .bess.pb.MeasureCommandGetSummaryResponse.Histogram jitter = 5;

    pub fn get_jitter(&self) -> &MeasureCommandGetSummaryResponse_Histogram {
        self.jitter.as_ref().unwrap_or_else(|| {
            <MeasureCommandGetSummaryResponse_Histogram as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_jitter(&mut self) {
        self.jitter.clear();
    }

    pub fn has_jitter(&self) -> bool {
        self.jitter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter(&mut self, v: MeasureCommandGetSummaryResponse_Histogram) {
        self.jitter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jitter(&mut self) -> &mut MeasureCommandGetSummaryResponse_Histogram {
        if self.jitter.is_none() {
            self.jitter.set_default();
        }
        self.jitter.as_mut().unwrap()
    }

    // Take field
    pub fn take_jitter(&mut self) -> MeasureCommandGetSummaryResponse_Histogram {
        self.jitter
            .take()
            .unwrap_or_else(|| MeasureCommandGetSummaryResponse_Histogram::new())
    }
}

impl ::protobuf::Message for MeasureCommandGetSummaryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.latency {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.jitter {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.timestamp = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.bits = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.latency)?;
                }
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jitter)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0. {
            my_size += 9;
        }
        if self.packets != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.packets,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.bits != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.bits, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.latency.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.jitter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0. {
            os.write_double(1, self.timestamp)?;
        }
        if self.packets != 0 {
            os.write_uint64(2, self.packets)?;
        }
        if self.bits != 0 {
            os.write_uint64(3, self.bits)?;
        }
        if let Some(ref v) = self.latency.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.jitter.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureCommandGetSummaryResponse {
        MeasureCommandGetSummaryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "timestamp",
                |m: &MeasureCommandGetSummaryResponse| &m.timestamp,
                |m: &mut MeasureCommandGetSummaryResponse| &mut m.timestamp,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "packets",
                |m: &MeasureCommandGetSummaryResponse| &m.packets,
                |m: &mut MeasureCommandGetSummaryResponse| &mut m.packets,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "bits",
                |m: &MeasureCommandGetSummaryResponse| &m.bits,
                |m: &mut MeasureCommandGetSummaryResponse| &mut m.bits,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<
                        MeasureCommandGetSummaryResponse_Histogram,
                    >,
                >(
                    "latency",
                    |m: &MeasureCommandGetSummaryResponse| &m.latency,
                    |m: &mut MeasureCommandGetSummaryResponse| &mut m.latency,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<
                        MeasureCommandGetSummaryResponse_Histogram,
                    >,
                >(
                    "jitter",
                    |m: &MeasureCommandGetSummaryResponse| &m.jitter,
                    |m: &mut MeasureCommandGetSummaryResponse| &mut m.jitter,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MeasureCommandGetSummaryResponse>(
                "MeasureCommandGetSummaryResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MeasureCommandGetSummaryResponse {
        static instance: ::protobuf::rt::LazyV2<MeasureCommandGetSummaryResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(MeasureCommandGetSummaryResponse::new)
    }
}

impl ::protobuf::Clear for MeasureCommandGetSummaryResponse {
    fn clear(&mut self) {
        self.timestamp = 0.;
        self.packets = 0;
        self.bits = 0;
        self.latency.clear();
        self.jitter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureCommandGetSummaryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureCommandGetSummaryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MeasureCommandGetSummaryResponse_Histogram {
    // message fields
    pub count: u64,
    pub above_range: u64,
    pub resolution_ns: u64,
    pub min_ns: u64,
    pub avg_ns: u64,
    pub max_ns: u64,
    pub total_ns: u64,
    pub percentile_values_ns: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeasureCommandGetSummaryResponse_Histogram {
    fn default() -> &'a MeasureCommandGetSummaryResponse_Histogram {
        <MeasureCommandGetSummaryResponse_Histogram as ::protobuf::Message>::default_instance()
    }
}

impl MeasureCommandGetSummaryResponse_Histogram {
    pub fn new() -> MeasureCommandGetSummaryResponse_Histogram {
        ::std::default::Default::default()
    }

    // uint64 count = 1;

    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }

    // uint64 above_range = 2;

    pub fn get_above_range(&self) -> u64 {
        self.above_range
    }
    pub fn clear_above_range(&mut self) {
        self.above_range = 0;
    }

    // Param is passed by value, moved
    pub fn set_above_range(&mut self, v: u64) {
        self.above_range = v;
    }

    // uint64 resolution_ns = 8;

    pub fn get_resolution_ns(&self) -> u64 {
        self.resolution_ns
    }
    pub fn clear_resolution_ns(&mut self) {
        self.resolution_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_resolution_ns(&mut self, v: u64) {
        self.resolution_ns = v;
    }

    // uint64 min_ns = 3;

    pub fn get_min_ns(&self) -> u64 {
        self.min_ns
    }
    pub fn clear_min_ns(&mut self) {
        self.min_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_ns(&mut self, v: u64) {
        self.min_ns = v;
    }

    // uint64 avg_ns = 4;

    pub fn get_avg_ns(&self) -> u64 {
        self.avg_ns
    }
    pub fn clear_avg_ns(&mut self) {
        self.avg_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_avg_ns(&mut self, v: u64) {
        self.avg_ns = v;
    }

    // uint64 max_ns = 5;

    pub fn get_max_ns(&self) -> u64 {
        self.max_ns
    }
    pub fn clear_max_ns(&mut self) {
        self.max_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_ns(&mut self, v: u64) {
        self.max_ns = v;
    }

    // uint64 total_ns = 6;

    pub fn get_total_ns(&self) -> u64 {
        self.total_ns
    }
    pub fn clear_total_ns(&mut self) {
        self.total_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_ns(&mut self, v: u64) {
        self.total_ns = v;
    }

    // repeated uint64 percentile_values_ns = 7;

    pub fn get_percentile_values_ns(&self) -> &[u64] {
        &self.percentile_values_ns
    }
    pub fn clear_percentile_values_ns(&mut self) {
        self.percentile_values_ns.clear();
    }

    // Param is passed by value, moved
    pub fn set_percentile_values_ns(&mut self, v: ::std::vec::Vec<u64>) {
        self.percentile_values_ns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_percentile_values_ns(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.percentile_values_ns
    }

    // Take field
    pub fn take_percentile_values_ns(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.percentile_values_ns, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MeasureCommandGetSummaryResponse_Histogram {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.above_range = tmp;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.resolution_ns = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_ns = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.avg_ns = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_ns = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_ns = tmp;
                }
                7 => {
                    ::protobuf::rt::read_repeated_uint64_into(
                        wire_type,
                        is,
                        &mut self.percentile_values_ns,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.above_range != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.above_range,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.resolution_ns != 0 {
            my_size += ::protobuf::rt::value_size(
                8,
                self.resolution_ns,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.min_ns != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.min_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avg_ns != 0 {
            my_size +=
                ::protobuf::rt::value_size(4, self.avg_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_ns != 0 {
            my_size +=
                ::protobuf::rt::value_size(5, self.max_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_ns != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.total_ns,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.percentile_values_ns {
            my_size +=
                ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_uint64(1, self.count)?;
        }
        if self.above_range != 0 {
            os.write_uint64(2, self.above_range)?;
        }
        if self.resolution_ns != 0 {
            os.write_uint64(8, self.resolution_ns)?;
        }
        if self.min_ns != 0 {
            os.write_uint64(3, self.min_ns)?;
        }
        if self.avg_ns != 0 {
            os.write_uint64(4, self.avg_ns)?;
        }
        if self.max_ns != 0 {
            os.write_uint64(5, self.max_ns)?;
        }
        if self.total_ns != 0 {
            os.write_uint64(6, self.total_ns)?;
        }
        for v in &self.percentile_values_ns {
            os.write_uint64(7, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureCommandGetSummaryResponse_Histogram {
        MeasureCommandGetSummaryResponse_Histogram::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "count",
                |m: &MeasureCommandGetSummaryResponse_Histogram| &m.count,
                |m: &mut MeasureCommandGetSummaryResponse_Histogram| &mut m.count,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "above_range",
                |m: &MeasureCommandGetSummaryResponse_Histogram| &m.above_range,
                |m: &mut MeasureCommandGetSummaryResponse_Histogram| &mut m.above_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "resolution_ns",
                |m: &MeasureCommandGetSummaryResponse_Histogram| &m.resolution_ns,
                |m: &mut MeasureCommandGetSummaryResponse_Histogram| &mut m.resolution_ns,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "min_ns",
                |m: &MeasureCommandGetSummaryResponse_Histogram| &m.min_ns,
                |m: &mut MeasureCommandGetSummaryResponse_Histogram| &mut m.min_ns,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "avg_ns",
                |m: &MeasureCommandGetSummaryResponse_Histogram| &m.avg_ns,
                |m: &mut MeasureCommandGetSummaryResponse_Histogram| &mut m.avg_ns,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "max_ns",
                |m: &MeasureCommandGetSummaryResponse_Histogram| &m.max_ns,
                |m: &mut MeasureCommandGetSummaryResponse_Histogram| &mut m.max_ns,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "total_ns",
                |m: &MeasureCommandGetSummaryResponse_Histogram| &m.total_ns,
                |m: &mut MeasureCommandGetSummaryResponse_Histogram| &mut m.total_ns,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "percentile_values_ns",
                |m: &MeasureCommandGetSummaryResponse_Histogram| &m.percentile_values_ns,
                |m: &mut MeasureCommandGetSummaryResponse_Histogram| &mut m.percentile_values_ns,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                MeasureCommandGetSummaryResponse_Histogram,
            >(
                "MeasureCommandGetSummaryResponse.Histogram",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MeasureCommandGetSummaryResponse_Histogram {
        static instance: ::protobuf::rt::LazyV2<MeasureCommandGetSummaryResponse_Histogram> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(MeasureCommandGetSummaryResponse_Histogram::new)
    }
}

impl ::protobuf::Clear for MeasureCommandGetSummaryResponse_Histogram {
    fn clear(&mut self) {
        self.count = 0;
        self.above_range = 0;
        self.resolution_ns = 0;
        self.min_ns = 0;
        self.avg_ns = 0;
        self.max_ns = 0;
        self.total_ns = 0;
        self.percentile_values_ns.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureCommandGetSummaryResponse_Histogram {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureCommandGetSummaryResponse_Histogram {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DRRArg {
    // message fields
    pub num_flows: u32,
    pub quantum: u64,
    pub max_flow_queue_size: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DRRArg {
    fn default() -> &'a DRRArg {
        <DRRArg as ::protobuf::Message>::default_instance()
    }
}

impl DRRArg {
    pub fn new() -> DRRArg {
        ::std::default::Default::default()
    }

    // uint32 num_flows = 1;

    pub fn get_num_flows(&self) -> u32 {
        self.num_flows
    }
    pub fn clear_num_flows(&mut self) {
        self.num_flows = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_flows(&mut self, v: u32) {
        self.num_flows = v;
    }

    // uint64 quantum = 2;

    pub fn get_quantum(&self) -> u64 {
        self.quantum
    }
    pub fn clear_quantum(&mut self) {
        self.quantum = 0;
    }

    // Param is passed by value, moved
    pub fn set_quantum(&mut self, v: u64) {
        self.quantum = v;
    }

    // uint32 max_flow_queue_size = 3;

    pub fn get_max_flow_queue_size(&self) -> u32 {
        self.max_flow_queue_size
    }
    pub fn clear_max_flow_queue_size(&mut self) {
        self.max_flow_queue_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_flow_queue_size(&mut self, v: u32) {
        self.max_flow_queue_size = v;
    }
}

impl ::protobuf::Message for DRRArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_flows = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.quantum = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_flow_queue_size = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_flows != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.num_flows,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.quantum != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.quantum,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.max_flow_queue_size != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.max_flow_queue_size,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.num_flows != 0 {
            os.write_uint32(1, self.num_flows)?;
        }
        if self.quantum != 0 {
            os.write_uint64(2, self.quantum)?;
        }
        if self.max_flow_queue_size != 0 {
            os.write_uint32(3, self.max_flow_queue_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DRRArg {
        DRRArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "num_flows",
                |m: &DRRArg| &m.num_flows,
                |m: &mut DRRArg| &mut m.num_flows,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "quantum",
                |m: &DRRArg| &m.quantum,
                |m: &mut DRRArg| &mut m.quantum,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "max_flow_queue_size",
                |m: &DRRArg| &m.max_flow_queue_size,
                |m: &mut DRRArg| &mut m.max_flow_queue_size,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DRRArg>(
                "DRRArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DRRArg {
        static instance: ::protobuf::rt::LazyV2<DRRArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DRRArg::new)
    }
}

impl ::protobuf::Clear for DRRArg {
    fn clear(&mut self) {
        self.num_flows = 0;
        self.quantum = 0;
        self.max_flow_queue_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DRRArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DRRArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DRRQuantumArg {
    // message fields
    pub quantum: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DRRQuantumArg {
    fn default() -> &'a DRRQuantumArg {
        <DRRQuantumArg as ::protobuf::Message>::default_instance()
    }
}

impl DRRQuantumArg {
    pub fn new() -> DRRQuantumArg {
        ::std::default::Default::default()
    }

    // uint32 quantum = 1;

    pub fn get_quantum(&self) -> u32 {
        self.quantum
    }
    pub fn clear_quantum(&mut self) {
        self.quantum = 0;
    }

    // Param is passed by value, moved
    pub fn set_quantum(&mut self, v: u32) {
        self.quantum = v;
    }
}

impl ::protobuf::Message for DRRQuantumArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantum = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.quantum != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.quantum,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.quantum != 0 {
            os.write_uint32(1, self.quantum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DRRQuantumArg {
        DRRQuantumArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "quantum",
                |m: &DRRQuantumArg| &m.quantum,
                |m: &mut DRRQuantumArg| &mut m.quantum,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DRRQuantumArg>(
                "DRRQuantumArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DRRQuantumArg {
        static instance: ::protobuf::rt::LazyV2<DRRQuantumArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DRRQuantumArg::new)
    }
}

impl ::protobuf::Clear for DRRQuantumArg {
    fn clear(&mut self) {
        self.quantum = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DRRQuantumArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DRRQuantumArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DRRMaxFlowQueueSizeArg {
    // message fields
    pub max_queue_size: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DRRMaxFlowQueueSizeArg {
    fn default() -> &'a DRRMaxFlowQueueSizeArg {
        <DRRMaxFlowQueueSizeArg as ::protobuf::Message>::default_instance()
    }
}

impl DRRMaxFlowQueueSizeArg {
    pub fn new() -> DRRMaxFlowQueueSizeArg {
        ::std::default::Default::default()
    }

    // uint32 max_queue_size = 1;

    pub fn get_max_queue_size(&self) -> u32 {
        self.max_queue_size
    }
    pub fn clear_max_queue_size(&mut self) {
        self.max_queue_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_queue_size(&mut self, v: u32) {
        self.max_queue_size = v;
    }
}

impl ::protobuf::Message for DRRMaxFlowQueueSizeArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_queue_size = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_queue_size != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.max_queue_size,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.max_queue_size != 0 {
            os.write_uint32(1, self.max_queue_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DRRMaxFlowQueueSizeArg {
        DRRMaxFlowQueueSizeArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "max_queue_size",
                |m: &DRRMaxFlowQueueSizeArg| &m.max_queue_size,
                |m: &mut DRRMaxFlowQueueSizeArg| &mut m.max_queue_size,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DRRMaxFlowQueueSizeArg>(
                "DRRMaxFlowQueueSizeArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DRRMaxFlowQueueSizeArg {
        static instance: ::protobuf::rt::LazyV2<DRRMaxFlowQueueSizeArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(DRRMaxFlowQueueSizeArg::new)
    }
}

impl ::protobuf::Clear for DRRMaxFlowQueueSizeArg {
    fn clear(&mut self) {
        self.max_queue_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DRRMaxFlowQueueSizeArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DRRMaxFlowQueueSizeArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PortIncCommandSetBurstArg {
    // message fields
    pub burst: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortIncCommandSetBurstArg {
    fn default() -> &'a PortIncCommandSetBurstArg {
        <PortIncCommandSetBurstArg as ::protobuf::Message>::default_instance()
    }
}

impl PortIncCommandSetBurstArg {
    pub fn new() -> PortIncCommandSetBurstArg {
        ::std::default::Default::default()
    }

    // uint64 burst = 1;

    pub fn get_burst(&self) -> u64 {
        self.burst
    }
    pub fn clear_burst(&mut self) {
        self.burst = 0;
    }

    // Param is passed by value, moved
    pub fn set_burst(&mut self, v: u64) {
        self.burst = v;
    }
}

impl ::protobuf::Message for PortIncCommandSetBurstArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.burst = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.burst != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.burst, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.burst != 0 {
            os.write_uint64(1, self.burst)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortIncCommandSetBurstArg {
        PortIncCommandSetBurstArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "burst",
                |m: &PortIncCommandSetBurstArg| &m.burst,
                |m: &mut PortIncCommandSetBurstArg| &mut m.burst,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortIncCommandSetBurstArg>(
                "PortIncCommandSetBurstArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static PortIncCommandSetBurstArg {
        static instance: ::protobuf::rt::LazyV2<PortIncCommandSetBurstArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(PortIncCommandSetBurstArg::new)
    }
}

impl ::protobuf::Clear for PortIncCommandSetBurstArg {
    fn clear(&mut self) {
        self.burst = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortIncCommandSetBurstArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortIncCommandSetBurstArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct QueueIncCommandSetBurstArg {
    // message fields
    pub burst: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueIncCommandSetBurstArg {
    fn default() -> &'a QueueIncCommandSetBurstArg {
        <QueueIncCommandSetBurstArg as ::protobuf::Message>::default_instance()
    }
}

impl QueueIncCommandSetBurstArg {
    pub fn new() -> QueueIncCommandSetBurstArg {
        ::std::default::Default::default()
    }

    // uint64 burst = 1;

    pub fn get_burst(&self) -> u64 {
        self.burst
    }
    pub fn clear_burst(&mut self) {
        self.burst = 0;
    }

    // Param is passed by value, moved
    pub fn set_burst(&mut self, v: u64) {
        self.burst = v;
    }
}

impl ::protobuf::Message for QueueIncCommandSetBurstArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.burst = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.burst != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.burst, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.burst != 0 {
            os.write_uint64(1, self.burst)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueIncCommandSetBurstArg {
        QueueIncCommandSetBurstArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "burst",
                |m: &QueueIncCommandSetBurstArg| &m.burst,
                |m: &mut QueueIncCommandSetBurstArg| &mut m.burst,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueIncCommandSetBurstArg>(
                "QueueIncCommandSetBurstArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static QueueIncCommandSetBurstArg {
        static instance: ::protobuf::rt::LazyV2<QueueIncCommandSetBurstArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueIncCommandSetBurstArg::new)
    }
}

impl ::protobuf::Clear for QueueIncCommandSetBurstArg {
    fn clear(&mut self) {
        self.burst = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueIncCommandSetBurstArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueIncCommandSetBurstArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct QueueCommandSetBurstArg {
    // message fields
    pub burst: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueCommandSetBurstArg {
    fn default() -> &'a QueueCommandSetBurstArg {
        <QueueCommandSetBurstArg as ::protobuf::Message>::default_instance()
    }
}

impl QueueCommandSetBurstArg {
    pub fn new() -> QueueCommandSetBurstArg {
        ::std::default::Default::default()
    }

    // uint64 burst = 1;

    pub fn get_burst(&self) -> u64 {
        self.burst
    }
    pub fn clear_burst(&mut self) {
        self.burst = 0;
    }

    // Param is passed by value, moved
    pub fn set_burst(&mut self, v: u64) {
        self.burst = v;
    }
}

impl ::protobuf::Message for QueueCommandSetBurstArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.burst = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.burst != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.burst, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.burst != 0 {
            os.write_uint64(1, self.burst)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueCommandSetBurstArg {
        QueueCommandSetBurstArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "burst",
                |m: &QueueCommandSetBurstArg| &m.burst,
                |m: &mut QueueCommandSetBurstArg| &mut m.burst,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueCommandSetBurstArg>(
                "QueueCommandSetBurstArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static QueueCommandSetBurstArg {
        static instance: ::protobuf::rt::LazyV2<QueueCommandSetBurstArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueCommandSetBurstArg::new)
    }
}

impl ::protobuf::Clear for QueueCommandSetBurstArg {
    fn clear(&mut self) {
        self.burst = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueCommandSetBurstArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueCommandSetBurstArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct QueueCommandSetSizeArg {
    // message fields
    pub size: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueCommandSetSizeArg {
    fn default() -> &'a QueueCommandSetSizeArg {
        <QueueCommandSetSizeArg as ::protobuf::Message>::default_instance()
    }
}

impl QueueCommandSetSizeArg {
    pub fn new() -> QueueCommandSetSizeArg {
        ::std::default::Default::default()
    }

    // uint64 size = 1;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }
}

impl ::protobuf::Message for QueueCommandSetSizeArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.size != 0 {
            os.write_uint64(1, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueCommandSetSizeArg {
        QueueCommandSetSizeArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &QueueCommandSetSizeArg| &m.size,
                |m: &mut QueueCommandSetSizeArg| &mut m.size,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueCommandSetSizeArg>(
                "QueueCommandSetSizeArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static QueueCommandSetSizeArg {
        static instance: ::protobuf::rt::LazyV2<QueueCommandSetSizeArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueCommandSetSizeArg::new)
    }
}

impl ::protobuf::Clear for QueueCommandSetSizeArg {
    fn clear(&mut self) {
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueCommandSetSizeArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueCommandSetSizeArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct QueueCommandGetStatusArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueCommandGetStatusArg {
    fn default() -> &'a QueueCommandGetStatusArg {
        <QueueCommandGetStatusArg as ::protobuf::Message>::default_instance()
    }
}

impl QueueCommandGetStatusArg {
    pub fn new() -> QueueCommandGetStatusArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueueCommandGetStatusArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueCommandGetStatusArg {
        QueueCommandGetStatusArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueCommandGetStatusArg>(
                "QueueCommandGetStatusArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static QueueCommandGetStatusArg {
        static instance: ::protobuf::rt::LazyV2<QueueCommandGetStatusArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueCommandGetStatusArg::new)
    }
}

impl ::protobuf::Clear for QueueCommandGetStatusArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueCommandGetStatusArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueCommandGetStatusArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct QueueCommandGetStatusResponse {
    // message fields
    pub count: u64,
    pub size: u64,
    pub enqueued: u64,
    pub dequeued: u64,
    pub dropped: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueCommandGetStatusResponse {
    fn default() -> &'a QueueCommandGetStatusResponse {
        <QueueCommandGetStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueueCommandGetStatusResponse {
    pub fn new() -> QueueCommandGetStatusResponse {
        ::std::default::Default::default()
    }

    // uint64 count = 1;

    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }

    // uint64 size = 2;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // uint64 enqueued = 3;

    pub fn get_enqueued(&self) -> u64 {
        self.enqueued
    }
    pub fn clear_enqueued(&mut self) {
        self.enqueued = 0;
    }

    // Param is passed by value, moved
    pub fn set_enqueued(&mut self, v: u64) {
        self.enqueued = v;
    }

    // uint64 dequeued = 4;

    pub fn get_dequeued(&self) -> u64 {
        self.dequeued
    }
    pub fn clear_dequeued(&mut self) {
        self.dequeued = 0;
    }

    // Param is passed by value, moved
    pub fn set_dequeued(&mut self, v: u64) {
        self.dequeued = v;
    }

    // uint64 dropped = 5;

    pub fn get_dropped(&self) -> u64 {
        self.dropped
    }
    pub fn clear_dropped(&mut self) {
        self.dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped(&mut self, v: u64) {
        self.dropped = v;
    }
}

impl ::protobuf::Message for QueueCommandGetStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.enqueued = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.dequeued = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.dropped = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.enqueued != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.enqueued,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.dequeued != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.dequeued,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.dropped != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.dropped,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_uint64(1, self.count)?;
        }
        if self.size != 0 {
            os.write_uint64(2, self.size)?;
        }
        if self.enqueued != 0 {
            os.write_uint64(3, self.enqueued)?;
        }
        if self.dequeued != 0 {
            os.write_uint64(4, self.dequeued)?;
        }
        if self.dropped != 0 {
            os.write_uint64(5, self.dropped)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueCommandGetStatusResponse {
        QueueCommandGetStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "count",
                |m: &QueueCommandGetStatusResponse| &m.count,
                |m: &mut QueueCommandGetStatusResponse| &mut m.count,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &QueueCommandGetStatusResponse| &m.size,
                |m: &mut QueueCommandGetStatusResponse| &mut m.size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "enqueued",
                |m: &QueueCommandGetStatusResponse| &m.enqueued,
                |m: &mut QueueCommandGetStatusResponse| &mut m.enqueued,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "dequeued",
                |m: &QueueCommandGetStatusResponse| &m.dequeued,
                |m: &mut QueueCommandGetStatusResponse| &mut m.dequeued,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "dropped",
                |m: &QueueCommandGetStatusResponse| &m.dropped,
                |m: &mut QueueCommandGetStatusResponse| &mut m.dropped,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueCommandGetStatusResponse>(
                "QueueCommandGetStatusResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static QueueCommandGetStatusResponse {
        static instance: ::protobuf::rt::LazyV2<QueueCommandGetStatusResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueCommandGetStatusResponse::new)
    }
}

impl ::protobuf::Clear for QueueCommandGetStatusResponse {
    fn clear(&mut self) {
        self.count = 0;
        self.size = 0;
        self.enqueued = 0;
        self.dequeued = 0;
        self.dropped = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueCommandGetStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueCommandGetStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RandomUpdateCommandClearArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomUpdateCommandClearArg {
    fn default() -> &'a RandomUpdateCommandClearArg {
        <RandomUpdateCommandClearArg as ::protobuf::Message>::default_instance()
    }
}

impl RandomUpdateCommandClearArg {
    pub fn new() -> RandomUpdateCommandClearArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RandomUpdateCommandClearArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomUpdateCommandClearArg {
        RandomUpdateCommandClearArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandomUpdateCommandClearArg>(
                "RandomUpdateCommandClearArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RandomUpdateCommandClearArg {
        static instance: ::protobuf::rt::LazyV2<RandomUpdateCommandClearArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(RandomUpdateCommandClearArg::new)
    }
}

impl ::protobuf::Clear for RandomUpdateCommandClearArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandomUpdateCommandClearArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomUpdateCommandClearArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RewriteCommandClearArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewriteCommandClearArg {
    fn default() -> &'a RewriteCommandClearArg {
        <RewriteCommandClearArg as ::protobuf::Message>::default_instance()
    }
}

impl RewriteCommandClearArg {
    pub fn new() -> RewriteCommandClearArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RewriteCommandClearArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewriteCommandClearArg {
        RewriteCommandClearArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RewriteCommandClearArg>(
                "RewriteCommandClearArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RewriteCommandClearArg {
        static instance: ::protobuf::rt::LazyV2<RewriteCommandClearArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(RewriteCommandClearArg::new)
    }
}

impl ::protobuf::Clear for RewriteCommandClearArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RewriteCommandClearArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RewriteCommandClearArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateCommandClearArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateCommandClearArg {
    fn default() -> &'a UpdateCommandClearArg {
        <UpdateCommandClearArg as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCommandClearArg {
    pub fn new() -> UpdateCommandClearArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateCommandClearArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateCommandClearArg {
        UpdateCommandClearArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateCommandClearArg>(
                "UpdateCommandClearArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UpdateCommandClearArg {
        static instance: ::protobuf::rt::LazyV2<UpdateCommandClearArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateCommandClearArg::new)
    }
}

impl ::protobuf::Clear for UpdateCommandClearArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateCommandClearArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCommandClearArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WildcardMatchCommandAddArg {
    // message fields
    pub gate: u64,
    pub priority: i64,
    pub values: ::protobuf::RepeatedField<super::util_msg::FieldData>,
    pub masks: ::protobuf::RepeatedField<super::util_msg::FieldData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WildcardMatchCommandAddArg {
    fn default() -> &'a WildcardMatchCommandAddArg {
        <WildcardMatchCommandAddArg as ::protobuf::Message>::default_instance()
    }
}

impl WildcardMatchCommandAddArg {
    pub fn new() -> WildcardMatchCommandAddArg {
        ::std::default::Default::default()
    }

    // uint64 gate = 1;

    pub fn get_gate(&self) -> u64 {
        self.gate
    }
    pub fn clear_gate(&mut self) {
        self.gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate(&mut self, v: u64) {
        self.gate = v;
    }

    // int64 priority = 2;

    pub fn get_priority(&self) -> i64 {
        self.priority
    }
    pub fn clear_priority(&mut self) {
        self.priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i64) {
        self.priority = v;
    }

    // repeated .bess.pb.FieldData values = 3;

    pub fn get_values(&self) -> &[super::util_msg::FieldData] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<super::util_msg::FieldData>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::FieldData> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<super::util_msg::FieldData> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    // repeated .bess.pb.FieldData masks = 4;

    pub fn get_masks(&self) -> &[super::util_msg::FieldData] {
        &self.masks
    }
    pub fn clear_masks(&mut self) {
        self.masks.clear();
    }

    // Param is passed by value, moved
    pub fn set_masks(&mut self, v: ::protobuf::RepeatedField<super::util_msg::FieldData>) {
        self.masks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_masks(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::FieldData> {
        &mut self.masks
    }

    // Take field
    pub fn take_masks(&mut self) -> ::protobuf::RepeatedField<super::util_msg::FieldData> {
        ::std::mem::replace(&mut self.masks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WildcardMatchCommandAddArg {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.masks {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.gate = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.priority = tmp;
                }
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.masks)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gate != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.gate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.priority != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.priority,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.masks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.gate != 0 {
            os.write_uint64(1, self.gate)?;
        }
        if self.priority != 0 {
            os.write_int64(2, self.priority)?;
        }
        for v in &self.values {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.masks {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WildcardMatchCommandAddArg {
        WildcardMatchCommandAddArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "gate",
                |m: &WildcardMatchCommandAddArg| &m.gate,
                |m: &mut WildcardMatchCommandAddArg| &mut m.gate,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "priority",
                |m: &WildcardMatchCommandAddArg| &m.priority,
                |m: &mut WildcardMatchCommandAddArg| &mut m.priority,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::FieldData>,
                >(
                    "values",
                    |m: &WildcardMatchCommandAddArg| &m.values,
                    |m: &mut WildcardMatchCommandAddArg| &mut m.values,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::FieldData>,
                >(
                    "masks",
                    |m: &WildcardMatchCommandAddArg| &m.masks,
                    |m: &mut WildcardMatchCommandAddArg| &mut m.masks,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WildcardMatchCommandAddArg>(
                "WildcardMatchCommandAddArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static WildcardMatchCommandAddArg {
        static instance: ::protobuf::rt::LazyV2<WildcardMatchCommandAddArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(WildcardMatchCommandAddArg::new)
    }
}

impl ::protobuf::Clear for WildcardMatchCommandAddArg {
    fn clear(&mut self) {
        self.gate = 0;
        self.priority = 0;
        self.values.clear();
        self.masks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WildcardMatchCommandAddArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WildcardMatchCommandAddArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WildcardMatchCommandDeleteArg {
    // message fields
    pub values: ::protobuf::RepeatedField<super::util_msg::FieldData>,
    pub masks: ::protobuf::RepeatedField<super::util_msg::FieldData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WildcardMatchCommandDeleteArg {
    fn default() -> &'a WildcardMatchCommandDeleteArg {
        <WildcardMatchCommandDeleteArg as ::protobuf::Message>::default_instance()
    }
}

impl WildcardMatchCommandDeleteArg {
    pub fn new() -> WildcardMatchCommandDeleteArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.FieldData values = 1;

    pub fn get_values(&self) -> &[super::util_msg::FieldData] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<super::util_msg::FieldData>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::FieldData> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<super::util_msg::FieldData> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    // repeated .bess.pb.FieldData masks = 2;

    pub fn get_masks(&self) -> &[super::util_msg::FieldData] {
        &self.masks
    }
    pub fn clear_masks(&mut self) {
        self.masks.clear();
    }

    // Param is passed by value, moved
    pub fn set_masks(&mut self, v: ::protobuf::RepeatedField<super::util_msg::FieldData>) {
        self.masks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_masks(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::FieldData> {
        &mut self.masks
    }

    // Take field
    pub fn take_masks(&mut self) -> ::protobuf::RepeatedField<super::util_msg::FieldData> {
        ::std::mem::replace(&mut self.masks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WildcardMatchCommandDeleteArg {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.masks {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.masks)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.masks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.values {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.masks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WildcardMatchCommandDeleteArg {
        WildcardMatchCommandDeleteArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::FieldData>,
                >(
                    "values",
                    |m: &WildcardMatchCommandDeleteArg| &m.values,
                    |m: &mut WildcardMatchCommandDeleteArg| &mut m.values,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::FieldData>,
                >(
                    "masks",
                    |m: &WildcardMatchCommandDeleteArg| &m.masks,
                    |m: &mut WildcardMatchCommandDeleteArg| &mut m.masks,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WildcardMatchCommandDeleteArg>(
                "WildcardMatchCommandDeleteArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static WildcardMatchCommandDeleteArg {
        static instance: ::protobuf::rt::LazyV2<WildcardMatchCommandDeleteArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(WildcardMatchCommandDeleteArg::new)
    }
}

impl ::protobuf::Clear for WildcardMatchCommandDeleteArg {
    fn clear(&mut self) {
        self.values.clear();
        self.masks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WildcardMatchCommandDeleteArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WildcardMatchCommandDeleteArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WildcardMatchCommandClearArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WildcardMatchCommandClearArg {
    fn default() -> &'a WildcardMatchCommandClearArg {
        <WildcardMatchCommandClearArg as ::protobuf::Message>::default_instance()
    }
}

impl WildcardMatchCommandClearArg {
    pub fn new() -> WildcardMatchCommandClearArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WildcardMatchCommandClearArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WildcardMatchCommandClearArg {
        WildcardMatchCommandClearArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WildcardMatchCommandClearArg>(
                "WildcardMatchCommandClearArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static WildcardMatchCommandClearArg {
        static instance: ::protobuf::rt::LazyV2<WildcardMatchCommandClearArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(WildcardMatchCommandClearArg::new)
    }
}

impl ::protobuf::Clear for WildcardMatchCommandClearArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WildcardMatchCommandClearArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WildcardMatchCommandClearArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WildcardMatchCommandSetDefaultGateArg {
    // message fields
    pub gate: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WildcardMatchCommandSetDefaultGateArg {
    fn default() -> &'a WildcardMatchCommandSetDefaultGateArg {
        <WildcardMatchCommandSetDefaultGateArg as ::protobuf::Message>::default_instance()
    }
}

impl WildcardMatchCommandSetDefaultGateArg {
    pub fn new() -> WildcardMatchCommandSetDefaultGateArg {
        ::std::default::Default::default()
    }

    // uint64 gate = 1;

    pub fn get_gate(&self) -> u64 {
        self.gate
    }
    pub fn clear_gate(&mut self) {
        self.gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate(&mut self, v: u64) {
        self.gate = v;
    }
}

impl ::protobuf::Message for WildcardMatchCommandSetDefaultGateArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.gate = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gate != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.gate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.gate != 0 {
            os.write_uint64(1, self.gate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WildcardMatchCommandSetDefaultGateArg {
        WildcardMatchCommandSetDefaultGateArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "gate",
                |m: &WildcardMatchCommandSetDefaultGateArg| &m.gate,
                |m: &mut WildcardMatchCommandSetDefaultGateArg| &mut m.gate,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                WildcardMatchCommandSetDefaultGateArg,
            >(
                "WildcardMatchCommandSetDefaultGateArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static WildcardMatchCommandSetDefaultGateArg {
        static instance: ::protobuf::rt::LazyV2<WildcardMatchCommandSetDefaultGateArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(WildcardMatchCommandSetDefaultGateArg::new)
    }
}

impl ::protobuf::Clear for WildcardMatchCommandSetDefaultGateArg {
    fn clear(&mut self) {
        self.gate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WildcardMatchCommandSetDefaultGateArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WildcardMatchCommandSetDefaultGateArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ACLArg {
    // message fields
    pub rules: ::protobuf::RepeatedField<ACLArg_Rule>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACLArg {
    fn default() -> &'a ACLArg {
        <ACLArg as ::protobuf::Message>::default_instance()
    }
}

impl ACLArg {
    pub fn new() -> ACLArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.ACLArg.Rule rules = 1;

    pub fn get_rules(&self) -> &[ACLArg_Rule] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<ACLArg_Rule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<ACLArg_Rule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<ACLArg_Rule> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ACLArg {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rules {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACLArg {
        ACLArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<ACLArg_Rule>,
                >(
                    "rules",
                    |m: &ACLArg| &m.rules,
                    |m: &mut ACLArg| &mut m.rules,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACLArg>(
                "ACLArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ACLArg {
        static instance: ::protobuf::rt::LazyV2<ACLArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACLArg::new)
    }
}

impl ::protobuf::Clear for ACLArg {
    fn clear(&mut self) {
        self.rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACLArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACLArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ACLArg_Rule {
    // message fields
    pub src_ip: ::std::string::String,
    pub dst_ip: ::std::string::String,
    pub src_port: u32,
    pub dst_port: u32,
    pub established: bool,
    pub drop: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACLArg_Rule {
    fn default() -> &'a ACLArg_Rule {
        <ACLArg_Rule as ::protobuf::Message>::default_instance()
    }
}

impl ACLArg_Rule {
    pub fn new() -> ACLArg_Rule {
        ::std::default::Default::default()
    }

    // string src_ip = 1;

    pub fn get_src_ip(&self) -> &str {
        &self.src_ip
    }
    pub fn clear_src_ip(&mut self) {
        self.src_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_ip(&mut self, v: ::std::string::String) {
        self.src_ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_ip(&mut self) -> &mut ::std::string::String {
        &mut self.src_ip
    }

    // Take field
    pub fn take_src_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_ip, ::std::string::String::new())
    }

    // string dst_ip = 2;

    pub fn get_dst_ip(&self) -> &str {
        &self.dst_ip
    }
    pub fn clear_dst_ip(&mut self) {
        self.dst_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_ip(&mut self, v: ::std::string::String) {
        self.dst_ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_ip(&mut self) -> &mut ::std::string::String {
        &mut self.dst_ip
    }

    // Take field
    pub fn take_dst_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_ip, ::std::string::String::new())
    }

    // uint32 src_port = 3;

    pub fn get_src_port(&self) -> u32 {
        self.src_port
    }
    pub fn clear_src_port(&mut self) {
        self.src_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_port(&mut self, v: u32) {
        self.src_port = v;
    }

    // uint32 dst_port = 4;

    pub fn get_dst_port(&self) -> u32 {
        self.dst_port
    }
    pub fn clear_dst_port(&mut self) {
        self.dst_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_port(&mut self, v: u32) {
        self.dst_port = v;
    }

    // bool established = 5;

    pub fn get_established(&self) -> bool {
        self.established
    }
    pub fn clear_established(&mut self) {
        self.established = false;
    }

    // Param is passed by value, moved
    pub fn set_established(&mut self, v: bool) {
        self.established = v;
    }

    // bool drop = 6;

    pub fn get_drop(&self) -> bool {
        self.drop
    }
    pub fn clear_drop(&mut self) {
        self.drop = false;
    }

    // Param is passed by value, moved
    pub fn set_drop(&mut self, v: bool) {
        self.drop = v;
    }
}

impl ::protobuf::Message for ACLArg_Rule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.src_ip,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.dst_ip,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_port = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_port = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.established = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.drop = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.src_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.src_ip);
        }
        if !self.dst_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dst_ip);
        }
        if self.src_port != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.src_port,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.dst_port != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.dst_port,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.established != false {
            my_size += 2;
        }
        if self.drop != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.src_ip.is_empty() {
            os.write_string(1, &self.src_ip)?;
        }
        if !self.dst_ip.is_empty() {
            os.write_string(2, &self.dst_ip)?;
        }
        if self.src_port != 0 {
            os.write_uint32(3, self.src_port)?;
        }
        if self.dst_port != 0 {
            os.write_uint32(4, self.dst_port)?;
        }
        if self.established != false {
            os.write_bool(5, self.established)?;
        }
        if self.drop != false {
            os.write_bool(6, self.drop)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACLArg_Rule {
        ACLArg_Rule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "src_ip",
                |m: &ACLArg_Rule| &m.src_ip,
                |m: &mut ACLArg_Rule| &mut m.src_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "dst_ip",
                |m: &ACLArg_Rule| &m.dst_ip,
                |m: &mut ACLArg_Rule| &mut m.dst_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "src_port",
                |m: &ACLArg_Rule| &m.src_port,
                |m: &mut ACLArg_Rule| &mut m.src_port,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "dst_port",
                |m: &ACLArg_Rule| &m.dst_port,
                |m: &mut ACLArg_Rule| &mut m.dst_port,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "established",
                |m: &ACLArg_Rule| &m.established,
                |m: &mut ACLArg_Rule| &mut m.established,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "drop",
                |m: &ACLArg_Rule| &m.drop,
                |m: &mut ACLArg_Rule| &mut m.drop,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACLArg_Rule>(
                "ACLArg.Rule",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ACLArg_Rule {
        static instance: ::protobuf::rt::LazyV2<ACLArg_Rule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACLArg_Rule::new)
    }
}

impl ::protobuf::Clear for ACLArg_Rule {
    fn clear(&mut self) {
        self.src_ip.clear();
        self.dst_ip.clear();
        self.src_port = 0;
        self.dst_port = 0;
        self.established = false;
        self.drop = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACLArg_Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACLArg_Rule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BPFArg {
    // message fields
    pub filters: ::protobuf::RepeatedField<BPFArg_Filter>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BPFArg {
    fn default() -> &'a BPFArg {
        <BPFArg as ::protobuf::Message>::default_instance()
    }
}

impl BPFArg {
    pub fn new() -> BPFArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.BPFArg.Filter filters = 1;

    pub fn get_filters(&self) -> &[BPFArg_Filter] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<BPFArg_Filter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<BPFArg_Filter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<BPFArg_Filter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BPFArg {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.filters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BPFArg {
        BPFArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<BPFArg_Filter>,
                >(
                    "filters",
                    |m: &BPFArg| &m.filters,
                    |m: &mut BPFArg| &mut m.filters,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BPFArg>(
                "BPFArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static BPFArg {
        static instance: ::protobuf::rt::LazyV2<BPFArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BPFArg::new)
    }
}

impl ::protobuf::Clear for BPFArg {
    fn clear(&mut self) {
        self.filters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BPFArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BPFArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BPFArg_Filter {
    // message fields
    pub priority: i64,
    pub filter: ::std::string::String,
    pub gate: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BPFArg_Filter {
    fn default() -> &'a BPFArg_Filter {
        <BPFArg_Filter as ::protobuf::Message>::default_instance()
    }
}

impl BPFArg_Filter {
    pub fn new() -> BPFArg_Filter {
        ::std::default::Default::default()
    }

    // int64 priority = 1;

    pub fn get_priority(&self) -> i64 {
        self.priority
    }
    pub fn clear_priority(&mut self) {
        self.priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i64) {
        self.priority = v;
    }

    // string filter = 2;

    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int64 gate = 3;

    pub fn get_gate(&self) -> i64 {
        self.gate
    }
    pub fn clear_gate(&mut self) {
        self.gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_gate(&mut self, v: i64) {
        self.gate = v;
    }
}

impl ::protobuf::Message for BPFArg_Filter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.priority = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.filter,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.gate = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.priority != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.priority,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if self.gate != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.gate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.priority != 0 {
            os.write_int64(1, self.priority)?;
        }
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if self.gate != 0 {
            os.write_int64(3, self.gate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BPFArg_Filter {
        BPFArg_Filter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "priority",
                |m: &BPFArg_Filter| &m.priority,
                |m: &mut BPFArg_Filter| &mut m.priority,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "filter",
                |m: &BPFArg_Filter| &m.filter,
                |m: &mut BPFArg_Filter| &mut m.filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gate",
                |m: &BPFArg_Filter| &m.gate,
                |m: &mut BPFArg_Filter| &mut m.gate,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BPFArg_Filter>(
                "BPFArg.Filter",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static BPFArg_Filter {
        static instance: ::protobuf::rt::LazyV2<BPFArg_Filter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BPFArg_Filter::new)
    }
}

impl ::protobuf::Clear for BPFArg_Filter {
    fn clear(&mut self) {
        self.priority = 0;
        self.filter.clear();
        self.gate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BPFArg_Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BPFArg_Filter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BufferArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BufferArg {
    fn default() -> &'a BufferArg {
        <BufferArg as ::protobuf::Message>::default_instance()
    }
}

impl BufferArg {
    pub fn new() -> BufferArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BufferArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BufferArg {
        BufferArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BufferArg>(
                "BufferArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static BufferArg {
        static instance: ::protobuf::rt::LazyV2<BufferArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BufferArg::new)
    }
}

impl ::protobuf::Clear for BufferArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BufferArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BypassArg {
    // message fields
    pub cycles_per_batch: u32,
    pub cycles_per_packet: u32,
    pub cycles_per_byte: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BypassArg {
    fn default() -> &'a BypassArg {
        <BypassArg as ::protobuf::Message>::default_instance()
    }
}

impl BypassArg {
    pub fn new() -> BypassArg {
        ::std::default::Default::default()
    }

    // uint32 cycles_per_batch = 1;

    pub fn get_cycles_per_batch(&self) -> u32 {
        self.cycles_per_batch
    }
    pub fn clear_cycles_per_batch(&mut self) {
        self.cycles_per_batch = 0;
    }

    // Param is passed by value, moved
    pub fn set_cycles_per_batch(&mut self, v: u32) {
        self.cycles_per_batch = v;
    }

    // uint32 cycles_per_packet = 2;

    pub fn get_cycles_per_packet(&self) -> u32 {
        self.cycles_per_packet
    }
    pub fn clear_cycles_per_packet(&mut self) {
        self.cycles_per_packet = 0;
    }

    // Param is passed by value, moved
    pub fn set_cycles_per_packet(&mut self, v: u32) {
        self.cycles_per_packet = v;
    }

    // uint32 cycles_per_byte = 3;

    pub fn get_cycles_per_byte(&self) -> u32 {
        self.cycles_per_byte
    }
    pub fn clear_cycles_per_byte(&mut self) {
        self.cycles_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_cycles_per_byte(&mut self, v: u32) {
        self.cycles_per_byte = v;
    }
}

impl ::protobuf::Message for BypassArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.cycles_per_batch = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.cycles_per_packet = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.cycles_per_byte = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cycles_per_batch != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.cycles_per_batch,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.cycles_per_packet != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.cycles_per_packet,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.cycles_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.cycles_per_byte,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.cycles_per_batch != 0 {
            os.write_uint32(1, self.cycles_per_batch)?;
        }
        if self.cycles_per_packet != 0 {
            os.write_uint32(2, self.cycles_per_packet)?;
        }
        if self.cycles_per_byte != 0 {
            os.write_uint32(3, self.cycles_per_byte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BypassArg {
        BypassArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "cycles_per_batch",
                |m: &BypassArg| &m.cycles_per_batch,
                |m: &mut BypassArg| &mut m.cycles_per_batch,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "cycles_per_packet",
                |m: &BypassArg| &m.cycles_per_packet,
                |m: &mut BypassArg| &mut m.cycles_per_packet,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "cycles_per_byte",
                |m: &BypassArg| &m.cycles_per_byte,
                |m: &mut BypassArg| &mut m.cycles_per_byte,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BypassArg>(
                "BypassArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static BypassArg {
        static instance: ::protobuf::rt::LazyV2<BypassArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BypassArg::new)
    }
}

impl ::protobuf::Clear for BypassArg {
    fn clear(&mut self) {
        self.cycles_per_batch = 0;
        self.cycles_per_packet = 0;
        self.cycles_per_byte = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BypassArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BypassArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DumpArg {
    // message fields
    pub interval: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DumpArg {
    fn default() -> &'a DumpArg {
        <DumpArg as ::protobuf::Message>::default_instance()
    }
}

impl DumpArg {
    pub fn new() -> DumpArg {
        ::std::default::Default::default()
    }

    // double interval = 1;

    pub fn get_interval(&self) -> f64 {
        self.interval
    }
    pub fn clear_interval(&mut self) {
        self.interval = 0.;
    }

    // Param is passed by value, moved
    pub fn set_interval(&mut self, v: f64) {
        self.interval = v;
    }
}

impl ::protobuf::Message for DumpArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.interval = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.interval != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.interval != 0. {
            os.write_double(1, self.interval)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DumpArg {
        DumpArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "interval",
                |m: &DumpArg| &m.interval,
                |m: &mut DumpArg| &mut m.interval,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DumpArg>(
                "DumpArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DumpArg {
        static instance: ::protobuf::rt::LazyV2<DumpArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DumpArg::new)
    }
}

impl ::protobuf::Clear for DumpArg {
    fn clear(&mut self) {
        self.interval = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DumpArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DumpArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EtherEncapArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EtherEncapArg {
    fn default() -> &'a EtherEncapArg {
        <EtherEncapArg as ::protobuf::Message>::default_instance()
    }
}

impl EtherEncapArg {
    pub fn new() -> EtherEncapArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EtherEncapArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EtherEncapArg {
        EtherEncapArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EtherEncapArg>(
                "EtherEncapArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static EtherEncapArg {
        static instance: ::protobuf::rt::LazyV2<EtherEncapArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EtherEncapArg::new)
    }
}

impl ::protobuf::Clear for EtherEncapArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EtherEncapArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EtherEncapArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExactMatchArg {
    // message fields
    pub fields: ::protobuf::RepeatedField<super::util_msg::Field>,
    pub masks: ::protobuf::RepeatedField<super::util_msg::FieldData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExactMatchArg {
    fn default() -> &'a ExactMatchArg {
        <ExactMatchArg as ::protobuf::Message>::default_instance()
    }
}

impl ExactMatchArg {
    pub fn new() -> ExactMatchArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.Field fields = 1;

    pub fn get_fields(&self) -> &[super::util_msg::Field] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<super::util_msg::Field>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::Field> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<super::util_msg::Field> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }

    // repeated .bess.pb.FieldData masks = 2;

    pub fn get_masks(&self) -> &[super::util_msg::FieldData] {
        &self.masks
    }
    pub fn clear_masks(&mut self) {
        self.masks.clear();
    }

    // Param is passed by value, moved
    pub fn set_masks(&mut self, v: ::protobuf::RepeatedField<super::util_msg::FieldData>) {
        self.masks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_masks(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::FieldData> {
        &mut self.masks
    }

    // Take field
    pub fn take_masks(&mut self) -> ::protobuf::RepeatedField<super::util_msg::FieldData> {
        ::std::mem::replace(&mut self.masks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExactMatchArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.masks {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.masks)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.masks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.masks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExactMatchArg {
        ExactMatchArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::Field>,
                >(
                    "fields",
                    |m: &ExactMatchArg| &m.fields,
                    |m: &mut ExactMatchArg| &mut m.fields,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::FieldData>,
                >(
                    "masks",
                    |m: &ExactMatchArg| &m.masks,
                    |m: &mut ExactMatchArg| &mut m.masks,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExactMatchArg>(
                "ExactMatchArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ExactMatchArg {
        static instance: ::protobuf::rt::LazyV2<ExactMatchArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExactMatchArg::new)
    }
}

impl ::protobuf::Clear for ExactMatchArg {
    fn clear(&mut self) {
        self.fields.clear();
        self.masks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExactMatchArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExactMatchArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExactMatchConfig {
    // message fields
    pub default_gate: u64,
    pub rules: ::protobuf::RepeatedField<ExactMatchCommandAddArg>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExactMatchConfig {
    fn default() -> &'a ExactMatchConfig {
        <ExactMatchConfig as ::protobuf::Message>::default_instance()
    }
}

impl ExactMatchConfig {
    pub fn new() -> ExactMatchConfig {
        ::std::default::Default::default()
    }

    // uint64 default_gate = 1;

    pub fn get_default_gate(&self) -> u64 {
        self.default_gate
    }
    pub fn clear_default_gate(&mut self) {
        self.default_gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_default_gate(&mut self, v: u64) {
        self.default_gate = v;
    }

    // repeated .bess.pb.ExactMatchCommandAddArg rules = 2;

    pub fn get_rules(&self) -> &[ExactMatchCommandAddArg] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<ExactMatchCommandAddArg>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<ExactMatchCommandAddArg> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<ExactMatchCommandAddArg> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExactMatchConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_gate = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.default_gate != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.default_gate,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.default_gate != 0 {
            os.write_uint64(1, self.default_gate)?;
        }
        for v in &self.rules {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExactMatchConfig {
        ExactMatchConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "default_gate",
                |m: &ExactMatchConfig| &m.default_gate,
                |m: &mut ExactMatchConfig| &mut m.default_gate,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<ExactMatchCommandAddArg>,
                >(
                    "rules",
                    |m: &ExactMatchConfig| &m.rules,
                    |m: &mut ExactMatchConfig| &mut m.rules,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExactMatchConfig>(
                "ExactMatchConfig",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ExactMatchConfig {
        static instance: ::protobuf::rt::LazyV2<ExactMatchConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExactMatchConfig::new)
    }
}

impl ::protobuf::Clear for ExactMatchConfig {
    fn clear(&mut self) {
        self.default_gate = 0;
        self.rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExactMatchConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExactMatchConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FlowGenArg {
    // message fields
    pub template: ::std::vec::Vec<u8>,
    pub pps: f64,
    pub flow_rate: f64,
    pub flow_duration: f64,
    pub arrival: ::std::string::String,
    pub duration: ::std::string::String,
    pub quick_rampup: bool,
    pub ip_src_range: u32,
    pub ip_dst_range: u32,
    pub port_src_range: u32,
    pub port_dst_range: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowGenArg {
    fn default() -> &'a FlowGenArg {
        <FlowGenArg as ::protobuf::Message>::default_instance()
    }
}

impl FlowGenArg {
    pub fn new() -> FlowGenArg {
        ::std::default::Default::default()
    }

    // bytes template = 1;

    pub fn get_template(&self) -> &[u8] {
        &self.template
    }
    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: ::std::vec::Vec<u8>) {
        self.template = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.template
    }

    // Take field
    pub fn take_template(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.template, ::std::vec::Vec::new())
    }

    // double pps = 2;

    pub fn get_pps(&self) -> f64 {
        self.pps
    }
    pub fn clear_pps(&mut self) {
        self.pps = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pps(&mut self, v: f64) {
        self.pps = v;
    }

    // double flow_rate = 3;

    pub fn get_flow_rate(&self) -> f64 {
        self.flow_rate
    }
    pub fn clear_flow_rate(&mut self) {
        self.flow_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_flow_rate(&mut self, v: f64) {
        self.flow_rate = v;
    }

    // double flow_duration = 4;

    pub fn get_flow_duration(&self) -> f64 {
        self.flow_duration
    }
    pub fn clear_flow_duration(&mut self) {
        self.flow_duration = 0.;
    }

    // Param is passed by value, moved
    pub fn set_flow_duration(&mut self, v: f64) {
        self.flow_duration = v;
    }

    // string arrival = 5;

    pub fn get_arrival(&self) -> &str {
        &self.arrival
    }
    pub fn clear_arrival(&mut self) {
        self.arrival.clear();
    }

    // Param is passed by value, moved
    pub fn set_arrival(&mut self, v: ::std::string::String) {
        self.arrival = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arrival(&mut self) -> &mut ::std::string::String {
        &mut self.arrival
    }

    // Take field
    pub fn take_arrival(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.arrival, ::std::string::String::new())
    }

    // string duration = 6;

    pub fn get_duration(&self) -> &str {
        &self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::std::string::String) {
        self.duration = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::std::string::String {
        &mut self.duration
    }

    // Take field
    pub fn take_duration(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.duration, ::std::string::String::new())
    }

    // bool quick_rampup = 7;

    pub fn get_quick_rampup(&self) -> bool {
        self.quick_rampup
    }
    pub fn clear_quick_rampup(&mut self) {
        self.quick_rampup = false;
    }

    // Param is passed by value, moved
    pub fn set_quick_rampup(&mut self, v: bool) {
        self.quick_rampup = v;
    }

    // uint32 ip_src_range = 8;

    pub fn get_ip_src_range(&self) -> u32 {
        self.ip_src_range
    }
    pub fn clear_ip_src_range(&mut self) {
        self.ip_src_range = 0;
    }

    // Param is passed by value, moved
    pub fn set_ip_src_range(&mut self, v: u32) {
        self.ip_src_range = v;
    }

    // uint32 ip_dst_range = 9;

    pub fn get_ip_dst_range(&self) -> u32 {
        self.ip_dst_range
    }
    pub fn clear_ip_dst_range(&mut self) {
        self.ip_dst_range = 0;
    }

    // Param is passed by value, moved
    pub fn set_ip_dst_range(&mut self, v: u32) {
        self.ip_dst_range = v;
    }

    // uint32 port_src_range = 10;

    pub fn get_port_src_range(&self) -> u32 {
        self.port_src_range
    }
    pub fn clear_port_src_range(&mut self) {
        self.port_src_range = 0;
    }

    // Param is passed by value, moved
    pub fn set_port_src_range(&mut self, v: u32) {
        self.port_src_range = v;
    }

    // uint32 port_dst_range = 11;

    pub fn get_port_dst_range(&self) -> u32 {
        self.port_dst_range
    }
    pub fn clear_port_dst_range(&mut self) {
        self.port_dst_range = 0;
    }

    // Param is passed by value, moved
    pub fn set_port_dst_range(&mut self, v: u32) {
        self.port_dst_range = v;
    }
}

impl ::protobuf::Message for FlowGenArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(
                        wire_type,
                        is,
                        &mut self.template,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.pps = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.flow_rate = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.flow_duration = tmp;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.arrival,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.duration,
                    )?;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.quick_rampup = tmp;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.ip_src_range = tmp;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.ip_dst_range = tmp;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.port_src_range = tmp;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.port_dst_range = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.template.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.template);
        }
        if self.pps != 0. {
            my_size += 9;
        }
        if self.flow_rate != 0. {
            my_size += 9;
        }
        if self.flow_duration != 0. {
            my_size += 9;
        }
        if !self.arrival.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.arrival);
        }
        if !self.duration.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.duration);
        }
        if self.quick_rampup != false {
            my_size += 2;
        }
        if self.ip_src_range != 0 {
            my_size += ::protobuf::rt::value_size(
                8,
                self.ip_src_range,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.ip_dst_range != 0 {
            my_size += ::protobuf::rt::value_size(
                9,
                self.ip_dst_range,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.port_src_range != 0 {
            my_size += ::protobuf::rt::value_size(
                10,
                self.port_src_range,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.port_dst_range != 0 {
            my_size += ::protobuf::rt::value_size(
                11,
                self.port_dst_range,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.template.is_empty() {
            os.write_bytes(1, &self.template)?;
        }
        if self.pps != 0. {
            os.write_double(2, self.pps)?;
        }
        if self.flow_rate != 0. {
            os.write_double(3, self.flow_rate)?;
        }
        if self.flow_duration != 0. {
            os.write_double(4, self.flow_duration)?;
        }
        if !self.arrival.is_empty() {
            os.write_string(5, &self.arrival)?;
        }
        if !self.duration.is_empty() {
            os.write_string(6, &self.duration)?;
        }
        if self.quick_rampup != false {
            os.write_bool(7, self.quick_rampup)?;
        }
        if self.ip_src_range != 0 {
            os.write_uint32(8, self.ip_src_range)?;
        }
        if self.ip_dst_range != 0 {
            os.write_uint32(9, self.ip_dst_range)?;
        }
        if self.port_src_range != 0 {
            os.write_uint32(10, self.port_src_range)?;
        }
        if self.port_dst_range != 0 {
            os.write_uint32(11, self.port_dst_range)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowGenArg {
        FlowGenArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBytes,
            >(
                "template",
                |m: &FlowGenArg| &m.template,
                |m: &mut FlowGenArg| &mut m.template,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "pps",
                |m: &FlowGenArg| &m.pps,
                |m: &mut FlowGenArg| &mut m.pps,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "flow_rate",
                |m: &FlowGenArg| &m.flow_rate,
                |m: &mut FlowGenArg| &mut m.flow_rate,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "flow_duration",
                |m: &FlowGenArg| &m.flow_duration,
                |m: &mut FlowGenArg| &mut m.flow_duration,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "arrival",
                |m: &FlowGenArg| &m.arrival,
                |m: &mut FlowGenArg| &mut m.arrival,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "duration",
                |m: &FlowGenArg| &m.duration,
                |m: &mut FlowGenArg| &mut m.duration,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "quick_rampup",
                |m: &FlowGenArg| &m.quick_rampup,
                |m: &mut FlowGenArg| &mut m.quick_rampup,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "ip_src_range",
                |m: &FlowGenArg| &m.ip_src_range,
                |m: &mut FlowGenArg| &mut m.ip_src_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "ip_dst_range",
                |m: &FlowGenArg| &m.ip_dst_range,
                |m: &mut FlowGenArg| &mut m.ip_dst_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "port_src_range",
                |m: &FlowGenArg| &m.port_src_range,
                |m: &mut FlowGenArg| &mut m.port_src_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "port_dst_range",
                |m: &FlowGenArg| &m.port_dst_range,
                |m: &mut FlowGenArg| &mut m.port_dst_range,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlowGenArg>(
                "FlowGenArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static FlowGenArg {
        static instance: ::protobuf::rt::LazyV2<FlowGenArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FlowGenArg::new)
    }
}

impl ::protobuf::Clear for FlowGenArg {
    fn clear(&mut self) {
        self.template.clear();
        self.pps = 0.;
        self.flow_rate = 0.;
        self.flow_duration = 0.;
        self.arrival.clear();
        self.duration.clear();
        self.quick_rampup = false;
        self.ip_src_range = 0;
        self.ip_dst_range = 0;
        self.port_src_range = 0;
        self.port_dst_range = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowGenArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowGenArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenericDecapArg {
    // message fields
    pub bytes: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenericDecapArg {
    fn default() -> &'a GenericDecapArg {
        <GenericDecapArg as ::protobuf::Message>::default_instance()
    }
}

impl GenericDecapArg {
    pub fn new() -> GenericDecapArg {
        ::std::default::Default::default()
    }

    // uint64 bytes = 1;

    pub fn get_bytes(&self) -> u64 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = v;
    }
}

impl ::protobuf::Message for GenericDecapArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bytes != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.bytes != 0 {
            os.write_uint64(1, self.bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenericDecapArg {
        GenericDecapArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "bytes",
                |m: &GenericDecapArg| &m.bytes,
                |m: &mut GenericDecapArg| &mut m.bytes,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenericDecapArg>(
                "GenericDecapArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GenericDecapArg {
        static instance: ::protobuf::rt::LazyV2<GenericDecapArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenericDecapArg::new)
    }
}

impl ::protobuf::Clear for GenericDecapArg {
    fn clear(&mut self) {
        self.bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenericDecapArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericDecapArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenericEncapArg {
    // message fields
    pub fields: ::protobuf::RepeatedField<GenericEncapArg_EncapField>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenericEncapArg {
    fn default() -> &'a GenericEncapArg {
        <GenericEncapArg as ::protobuf::Message>::default_instance()
    }
}

impl GenericEncapArg {
    pub fn new() -> GenericEncapArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.GenericEncapArg.EncapField fields = 1;

    pub fn get_fields(&self) -> &[GenericEncapArg_EncapField] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<GenericEncapArg_EncapField>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<GenericEncapArg_EncapField> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<GenericEncapArg_EncapField> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GenericEncapArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenericEncapArg {
        GenericEncapArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GenericEncapArg_EncapField>,
                >(
                    "fields",
                    |m: &GenericEncapArg| &m.fields,
                    |m: &mut GenericEncapArg| &mut m.fields,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenericEncapArg>(
                "GenericEncapArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GenericEncapArg {
        static instance: ::protobuf::rt::LazyV2<GenericEncapArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenericEncapArg::new)
    }
}

impl ::protobuf::Clear for GenericEncapArg {
    fn clear(&mut self) {
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenericEncapArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericEncapArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenericEncapArg_EncapField {
    // message fields
    pub size: u64,
    // message oneof groups
    pub insertion: ::std::option::Option<GenericEncapArg_EncapField_oneof_insertion>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenericEncapArg_EncapField {
    fn default() -> &'a GenericEncapArg_EncapField {
        <GenericEncapArg_EncapField as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum GenericEncapArg_EncapField_oneof_insertion {
    attribute(::std::string::String),
    value(super::util_msg::FieldData),
}

impl GenericEncapArg_EncapField {
    pub fn new() -> GenericEncapArg_EncapField {
        ::std::default::Default::default()
    }

    // uint64 size = 1;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // string attribute = 2;

    pub fn get_attribute(&self) -> &str {
        match self.insertion {
            ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::attribute(
                ref v,
            )) => v,
            _ => "",
        }
    }
    pub fn clear_attribute(&mut self) {
        self.insertion = ::std::option::Option::None;
    }

    pub fn has_attribute(&self) -> bool {
        match self.insertion {
            ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::attribute(
                ..,
            )) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::std::string::String) {
        self.insertion =
            ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::attribute(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::attribute(
            _,
        )) = self.insertion
        {
        } else {
            self.insertion = ::std::option::Option::Some(
                GenericEncapArg_EncapField_oneof_insertion::attribute(::std::string::String::new()),
            );
        }
        match self.insertion {
            ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::attribute(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::std::string::String {
        if self.has_attribute() {
            match self.insertion.take() {
                ::std::option::Option::Some(
                    GenericEncapArg_EncapField_oneof_insertion::attribute(v),
                ) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .bess.pb.FieldData value = 3;

    pub fn get_value(&self) -> &super::util_msg::FieldData {
        match self.insertion {
            ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::value(
                ref v,
            )) => v,
            _ => <super::util_msg::FieldData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_value(&mut self) {
        self.insertion = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        match self.insertion {
            ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::value(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: super::util_msg::FieldData) {
        self.insertion =
            ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut super::util_msg::FieldData {
        if let ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::value(_)) =
            self.insertion
        {
        } else {
            self.insertion = ::std::option::Option::Some(
                GenericEncapArg_EncapField_oneof_insertion::value(super::util_msg::FieldData::new()),
            );
        }
        match self.insertion {
            ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::value(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value(&mut self) -> super::util_msg::FieldData {
        if self.has_value() {
            match self.insertion.take() {
                ::std::option::Option::Some(GenericEncapArg_EncapField_oneof_insertion::value(
                    v,
                )) => v,
                _ => panic!(),
            }
        } else {
            super::util_msg::FieldData::new()
        }
    }
}

impl ::protobuf::Message for GenericEncapArg_EncapField {
    fn is_initialized(&self) -> bool {
        if let Some(GenericEncapArg_EncapField_oneof_insertion::value(ref v)) = self.insertion {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.insertion = ::std::option::Option::Some(
                        GenericEncapArg_EncapField_oneof_insertion::attribute(is.read_string()?),
                    );
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.insertion = ::std::option::Option::Some(
                        GenericEncapArg_EncapField_oneof_insertion::value(is.read_message()?),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.insertion {
            match v {
                &GenericEncapArg_EncapField_oneof_insertion::attribute(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                &GenericEncapArg_EncapField_oneof_insertion::value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.size != 0 {
            os.write_uint64(1, self.size)?;
        }
        if let ::std::option::Option::Some(ref v) = self.insertion {
            match v {
                &GenericEncapArg_EncapField_oneof_insertion::attribute(ref v) => {
                    os.write_string(2, v)?;
                }
                &GenericEncapArg_EncapField_oneof_insertion::value(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenericEncapArg_EncapField {
        GenericEncapArg_EncapField::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &GenericEncapArg_EncapField| &m.size,
                |m: &mut GenericEncapArg_EncapField| &mut m.size,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "attribute",
                    GenericEncapArg_EncapField::has_attribute,
                    GenericEncapArg_EncapField::get_attribute,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_message_accessor::<
                    _,
                    super::util_msg::FieldData,
                >(
                    "value",
                    GenericEncapArg_EncapField::has_value,
                    GenericEncapArg_EncapField::get_value,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenericEncapArg_EncapField>(
                "GenericEncapArg.EncapField",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GenericEncapArg_EncapField {
        static instance: ::protobuf::rt::LazyV2<GenericEncapArg_EncapField> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GenericEncapArg_EncapField::new)
    }
}

impl ::protobuf::Clear for GenericEncapArg_EncapField {
    fn clear(&mut self) {
        self.size = 0;
        self.insertion = ::std::option::Option::None;
        self.insertion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenericEncapArg_EncapField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericEncapArg_EncapField {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct HashLBArg {
    // message fields
    pub gates: ::std::vec::Vec<i64>,
    pub mode: ::std::string::String,
    pub fields: ::protobuf::RepeatedField<super::util_msg::Field>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashLBArg {
    fn default() -> &'a HashLBArg {
        <HashLBArg as ::protobuf::Message>::default_instance()
    }
}

impl HashLBArg {
    pub fn new() -> HashLBArg {
        ::std::default::Default::default()
    }

    // repeated int64 gates = 1;

    pub fn get_gates(&self) -> &[i64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<i64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }

    // string mode = 2;

    pub fn get_mode(&self) -> &str {
        &self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ::std::string::String) {
        self.mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut ::std::string::String {
        &mut self.mode
    }

    // Take field
    pub fn take_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mode, ::std::string::String::new())
    }

    // repeated .bess.pb.Field fields = 3;

    pub fn get_fields(&self) -> &[super::util_msg::Field] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<super::util_msg::Field>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::Field> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<super::util_msg::Field> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HashLBArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gates)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mode,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mode);
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gates {
            os.write_int64(1, *v)?;
        }
        if !self.mode.is_empty() {
            os.write_string(2, &self.mode)?;
        }
        for v in &self.fields {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashLBArg {
        HashLBArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gates",
                |m: &HashLBArg| &m.gates,
                |m: &mut HashLBArg| &mut m.gates,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mode",
                |m: &HashLBArg| &m.mode,
                |m: &mut HashLBArg| &mut m.mode,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::Field>,
                >(
                    "fields",
                    |m: &HashLBArg| &m.fields,
                    |m: &mut HashLBArg| &mut m.fields,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HashLBArg>(
                "HashLBArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static HashLBArg {
        static instance: ::protobuf::rt::LazyV2<HashLBArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HashLBArg::new)
    }
}

impl ::protobuf::Clear for HashLBArg {
    fn clear(&mut self) {
        self.gates.clear();
        self.mode.clear();
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashLBArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashLBArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IPEncapArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPEncapArg {
    fn default() -> &'a IPEncapArg {
        <IPEncapArg as ::protobuf::Message>::default_instance()
    }
}

impl IPEncapArg {
    pub fn new() -> IPEncapArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IPEncapArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPEncapArg {
        IPEncapArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPEncapArg>(
                "IPEncapArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static IPEncapArg {
        static instance: ::protobuf::rt::LazyV2<IPEncapArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IPEncapArg::new)
    }
}

impl ::protobuf::Clear for IPEncapArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPEncapArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPEncapArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IPLookupArg {
    // message fields
    pub max_rules: u32,
    pub max_tbl8s: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPLookupArg {
    fn default() -> &'a IPLookupArg {
        <IPLookupArg as ::protobuf::Message>::default_instance()
    }
}

impl IPLookupArg {
    pub fn new() -> IPLookupArg {
        ::std::default::Default::default()
    }

    // uint32 max_rules = 1;

    pub fn get_max_rules(&self) -> u32 {
        self.max_rules
    }
    pub fn clear_max_rules(&mut self) {
        self.max_rules = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_rules(&mut self, v: u32) {
        self.max_rules = v;
    }

    // uint32 max_tbl8s = 2;

    pub fn get_max_tbl8s(&self) -> u32 {
        self.max_tbl8s
    }
    pub fn clear_max_tbl8s(&mut self) {
        self.max_tbl8s = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_tbl8s(&mut self, v: u32) {
        self.max_tbl8s = v;
    }
}

impl ::protobuf::Message for IPLookupArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_rules = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_tbl8s = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_rules != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.max_rules,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.max_tbl8s != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.max_tbl8s,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.max_rules != 0 {
            os.write_uint32(1, self.max_rules)?;
        }
        if self.max_tbl8s != 0 {
            os.write_uint32(2, self.max_tbl8s)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPLookupArg {
        IPLookupArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "max_rules",
                |m: &IPLookupArg| &m.max_rules,
                |m: &mut IPLookupArg| &mut m.max_rules,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "max_tbl8s",
                |m: &IPLookupArg| &m.max_tbl8s,
                |m: &mut IPLookupArg| &mut m.max_tbl8s,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPLookupArg>(
                "IPLookupArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static IPLookupArg {
        static instance: ::protobuf::rt::LazyV2<IPLookupArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IPLookupArg::new)
    }
}

impl ::protobuf::Clear for IPLookupArg {
    fn clear(&mut self) {
        self.max_rules = 0;
        self.max_tbl8s = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPLookupArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPLookupArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L2ForwardArg {
    // message fields
    pub size: i64,
    pub bucket: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L2ForwardArg {
    fn default() -> &'a L2ForwardArg {
        <L2ForwardArg as ::protobuf::Message>::default_instance()
    }
}

impl L2ForwardArg {
    pub fn new() -> L2ForwardArg {
        ::std::default::Default::default()
    }

    // int64 size = 1;

    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // int64 bucket = 2;

    pub fn get_bucket(&self) -> i64 {
        self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket = 0;
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: i64) {
        self.bucket = v;
    }
}

impl ::protobuf::Message for L2ForwardArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.bucket = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bucket != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.bucket, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.size != 0 {
            os.write_int64(1, self.size)?;
        }
        if self.bucket != 0 {
            os.write_int64(2, self.bucket)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L2ForwardArg {
        L2ForwardArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "size",
                |m: &L2ForwardArg| &m.size,
                |m: &mut L2ForwardArg| &mut m.size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "bucket",
                |m: &L2ForwardArg| &m.bucket,
                |m: &mut L2ForwardArg| &mut m.bucket,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L2ForwardArg>(
                "L2ForwardArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static L2ForwardArg {
        static instance: ::protobuf::rt::LazyV2<L2ForwardArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(L2ForwardArg::new)
    }
}

impl ::protobuf::Clear for L2ForwardArg {
    fn clear(&mut self) {
        self.size = 0;
        self.bucket = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L2ForwardArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L2ForwardArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MACSwapArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MACSwapArg {
    fn default() -> &'a MACSwapArg {
        <MACSwapArg as ::protobuf::Message>::default_instance()
    }
}

impl MACSwapArg {
    pub fn new() -> MACSwapArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MACSwapArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MACSwapArg {
        MACSwapArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MACSwapArg>(
                "MACSwapArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MACSwapArg {
        static instance: ::protobuf::rt::LazyV2<MACSwapArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MACSwapArg::new)
    }
}

impl ::protobuf::Clear for MACSwapArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MACSwapArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MACSwapArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MeasureArg {
    // message fields
    pub jitter_sample_prob: f64,
    pub latency_ns_max: u64,
    pub latency_ns_resolution: u32,
    // message oneof groups
    pub field_type: ::std::option::Option<MeasureArg_oneof_type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeasureArg {
    fn default() -> &'a MeasureArg {
        <MeasureArg as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum MeasureArg_oneof_type {
    offset(u64),
    attr_name(::std::string::String),
}

impl MeasureArg {
    pub fn new() -> MeasureArg {
        ::std::default::Default::default()
    }

    // uint64 offset = 2;

    pub fn get_offset(&self) -> u64 {
        match self.field_type {
            ::std::option::Option::Some(MeasureArg_oneof_type::offset(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_offset(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(MeasureArg_oneof_type::offset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.field_type = ::std::option::Option::Some(MeasureArg_oneof_type::offset(v))
    }

    // string attr_name = 6;

    pub fn get_attr_name(&self) -> &str {
        match self.field_type {
            ::std::option::Option::Some(MeasureArg_oneof_type::attr_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_attr_name(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_attr_name(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(MeasureArg_oneof_type::attr_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attr_name(&mut self, v: ::std::string::String) {
        self.field_type = ::std::option::Option::Some(MeasureArg_oneof_type::attr_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attr_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MeasureArg_oneof_type::attr_name(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(MeasureArg_oneof_type::attr_name(
                ::std::string::String::new(),
            ));
        }
        match self.field_type {
            ::std::option::Option::Some(MeasureArg_oneof_type::attr_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attr_name(&mut self) -> ::std::string::String {
        if self.has_attr_name() {
            match self.field_type.take() {
                ::std::option::Option::Some(MeasureArg_oneof_type::attr_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // double jitter_sample_prob = 3;

    pub fn get_jitter_sample_prob(&self) -> f64 {
        self.jitter_sample_prob
    }
    pub fn clear_jitter_sample_prob(&mut self) {
        self.jitter_sample_prob = 0.;
    }

    // Param is passed by value, moved
    pub fn set_jitter_sample_prob(&mut self, v: f64) {
        self.jitter_sample_prob = v;
    }

    // uint64 latency_ns_max = 4;

    pub fn get_latency_ns_max(&self) -> u64 {
        self.latency_ns_max
    }
    pub fn clear_latency_ns_max(&mut self) {
        self.latency_ns_max = 0;
    }

    // Param is passed by value, moved
    pub fn set_latency_ns_max(&mut self, v: u64) {
        self.latency_ns_max = v;
    }

    // uint32 latency_ns_resolution = 5;

    pub fn get_latency_ns_resolution(&self) -> u32 {
        self.latency_ns_resolution
    }
    pub fn clear_latency_ns_resolution(&mut self) {
        self.latency_ns_resolution = 0;
    }

    // Param is passed by value, moved
    pub fn set_latency_ns_resolution(&mut self, v: u32) {
        self.latency_ns_resolution = v;
    }
}

impl ::protobuf::Message for MeasureArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.field_type = ::std::option::Option::Some(MeasureArg_oneof_type::offset(
                        is.read_uint64()?,
                    ));
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.field_type = ::std::option::Option::Some(
                        MeasureArg_oneof_type::attr_name(is.read_string()?),
                    );
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.jitter_sample_prob = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.latency_ns_max = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.latency_ns_resolution = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.jitter_sample_prob != 0. {
            my_size += 9;
        }
        if self.latency_ns_max != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.latency_ns_max,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.latency_ns_resolution != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.latency_ns_resolution,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &MeasureArg_oneof_type::offset(v) => {
                    my_size +=
                        ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                }
                &MeasureArg_oneof_type::attr_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.jitter_sample_prob != 0. {
            os.write_double(3, self.jitter_sample_prob)?;
        }
        if self.latency_ns_max != 0 {
            os.write_uint64(4, self.latency_ns_max)?;
        }
        if self.latency_ns_resolution != 0 {
            os.write_uint32(5, self.latency_ns_resolution)?;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &MeasureArg_oneof_type::offset(v) => {
                    os.write_uint64(2, v)?;
                }
                &MeasureArg_oneof_type::attr_name(ref v) => {
                    os.write_string(6, v)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureArg {
        MeasureArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "offset",
                    MeasureArg::has_offset,
                    MeasureArg::get_offset,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "attr_name",
                    MeasureArg::has_attr_name,
                    MeasureArg::get_attr_name,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "jitter_sample_prob",
                |m: &MeasureArg| &m.jitter_sample_prob,
                |m: &mut MeasureArg| &mut m.jitter_sample_prob,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "latency_ns_max",
                |m: &MeasureArg| &m.latency_ns_max,
                |m: &mut MeasureArg| &mut m.latency_ns_max,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "latency_ns_resolution",
                |m: &MeasureArg| &m.latency_ns_resolution,
                |m: &mut MeasureArg| &mut m.latency_ns_resolution,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MeasureArg>(
                "MeasureArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MeasureArg {
        static instance: ::protobuf::rt::LazyV2<MeasureArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MeasureArg::new)
    }
}

impl ::protobuf::Clear for MeasureArg {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.jitter_sample_prob = 0.;
        self.latency_ns_max = 0;
        self.latency_ns_resolution = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MergeArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MergeArg {
    fn default() -> &'a MergeArg {
        <MergeArg as ::protobuf::Message>::default_instance()
    }
}

impl MergeArg {
    pub fn new() -> MergeArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MergeArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MergeArg {
        MergeArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MergeArg>(
                "MergeArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MergeArg {
        static instance: ::protobuf::rt::LazyV2<MergeArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MergeArg::new)
    }
}

impl ::protobuf::Clear for MergeArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MergeArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MergeArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MetadataTestArg {
    // message fields
    pub read: ::std::collections::HashMap<::std::string::String, i64>,
    pub write: ::std::collections::HashMap<::std::string::String, i64>,
    pub update: ::std::collections::HashMap<::std::string::String, i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetadataTestArg {
    fn default() -> &'a MetadataTestArg {
        <MetadataTestArg as ::protobuf::Message>::default_instance()
    }
}

impl MetadataTestArg {
    pub fn new() -> MetadataTestArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.MetadataTestArg.ReadEntry read = 1;

    pub fn get_read(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.read
    }
    pub fn clear_read(&mut self) {
        self.read.clear();
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.read = v;
    }

    // Mutable pointer to the field.
    pub fn mut_read(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.read
    }

    // Take field
    pub fn take_read(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.read, ::std::collections::HashMap::new())
    }

    // repeated .bess.pb.MetadataTestArg.WriteEntry write = 2;

    pub fn get_write(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.write
    }
    pub fn clear_write(&mut self) {
        self.write.clear();
    }

    // Param is passed by value, moved
    pub fn set_write(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.write = v;
    }

    // Mutable pointer to the field.
    pub fn mut_write(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.write
    }

    // Take field
    pub fn take_write(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.write, ::std::collections::HashMap::new())
    }

    // repeated .bess.pb.MetadataTestArg.UpdateEntry update = 3;

    pub fn get_update(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.update
    }
    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.update = v;
    }

    // Mutable pointer to the field.
    pub fn mut_update(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.update
    }

    // Take field
    pub fn take_update(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.update, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for MetadataTestArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeInt64,
                    >(wire_type, is, &mut self.read)?;
                }
                2 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeInt64,
                    >(wire_type, is, &mut self.write)?;
                }
                3 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeInt64,
                    >(wire_type, is, &mut self.update)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(1, &self.read);
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(2, &self.write);
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(3, &self.update);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(1, &self.read, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(2, &self.write, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(3, &self.update, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetadataTestArg {
        MetadataTestArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "read",
                |m: &MetadataTestArg| &m.read,
                |m: &mut MetadataTestArg| &mut m.read,
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "write",
                |m: &MetadataTestArg| &m.write,
                |m: &mut MetadataTestArg| &mut m.write,
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "update",
                |m: &MetadataTestArg| &m.update,
                |m: &mut MetadataTestArg| &mut m.update,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetadataTestArg>(
                "MetadataTestArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MetadataTestArg {
        static instance: ::protobuf::rt::LazyV2<MetadataTestArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetadataTestArg::new)
    }
}

impl ::protobuf::Clear for MetadataTestArg {
    fn clear(&mut self) {
        self.read.clear();
        self.write.clear();
        self.update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetadataTestArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetadataTestArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NATArg {
    // message fields
    pub ext_addrs: ::protobuf::RepeatedField<NATArg_ExternalAddress>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NATArg {
    fn default() -> &'a NATArg {
        <NATArg as ::protobuf::Message>::default_instance()
    }
}

impl NATArg {
    pub fn new() -> NATArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.NATArg.ExternalAddress ext_addrs = 1;

    pub fn get_ext_addrs(&self) -> &[NATArg_ExternalAddress] {
        &self.ext_addrs
    }
    pub fn clear_ext_addrs(&mut self) {
        self.ext_addrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ext_addrs(&mut self, v: ::protobuf::RepeatedField<NATArg_ExternalAddress>) {
        self.ext_addrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ext_addrs(&mut self) -> &mut ::protobuf::RepeatedField<NATArg_ExternalAddress> {
        &mut self.ext_addrs
    }

    // Take field
    pub fn take_ext_addrs(&mut self) -> ::protobuf::RepeatedField<NATArg_ExternalAddress> {
        ::std::mem::replace(&mut self.ext_addrs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NATArg {
    fn is_initialized(&self) -> bool {
        for v in &self.ext_addrs {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ext_addrs)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ext_addrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ext_addrs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NATArg {
        NATArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<NATArg_ExternalAddress>,
                >(
                    "ext_addrs",
                    |m: &NATArg| &m.ext_addrs,
                    |m: &mut NATArg| &mut m.ext_addrs,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NATArg>(
                "NATArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static NATArg {
        static instance: ::protobuf::rt::LazyV2<NATArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NATArg::new)
    }
}

impl ::protobuf::Clear for NATArg {
    fn clear(&mut self) {
        self.ext_addrs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NATArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NATArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NATArg_PortRange {
    // message fields
    pub begin: u32,
    pub end: u32,
    pub suspended: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NATArg_PortRange {
    fn default() -> &'a NATArg_PortRange {
        <NATArg_PortRange as ::protobuf::Message>::default_instance()
    }
}

impl NATArg_PortRange {
    pub fn new() -> NATArg_PortRange {
        ::std::default::Default::default()
    }

    // uint32 begin = 1;

    pub fn get_begin(&self) -> u32 {
        self.begin
    }
    pub fn clear_begin(&mut self) {
        self.begin = 0;
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: u32) {
        self.begin = v;
    }

    // uint32 end = 2;

    pub fn get_end(&self) -> u32 {
        self.end
    }
    pub fn clear_end(&mut self) {
        self.end = 0;
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u32) {
        self.end = v;
    }

    // bool suspended = 3;

    pub fn get_suspended(&self) -> bool {
        self.suspended
    }
    pub fn clear_suspended(&mut self) {
        self.suspended = false;
    }

    // Param is passed by value, moved
    pub fn set_suspended(&mut self, v: bool) {
        self.suspended = v;
    }
}

impl ::protobuf::Message for NATArg_PortRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.begin = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.end = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.suspended = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.begin != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.begin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.end, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.suspended != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.begin != 0 {
            os.write_uint32(1, self.begin)?;
        }
        if self.end != 0 {
            os.write_uint32(2, self.end)?;
        }
        if self.suspended != false {
            os.write_bool(3, self.suspended)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NATArg_PortRange {
        NATArg_PortRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "begin",
                |m: &NATArg_PortRange| &m.begin,
                |m: &mut NATArg_PortRange| &mut m.begin,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "end",
                |m: &NATArg_PortRange| &m.end,
                |m: &mut NATArg_PortRange| &mut m.end,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "suspended",
                |m: &NATArg_PortRange| &m.suspended,
                |m: &mut NATArg_PortRange| &mut m.suspended,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NATArg_PortRange>(
                "NATArg.PortRange",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static NATArg_PortRange {
        static instance: ::protobuf::rt::LazyV2<NATArg_PortRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NATArg_PortRange::new)
    }
}

impl ::protobuf::Clear for NATArg_PortRange {
    fn clear(&mut self) {
        self.begin = 0;
        self.end = 0;
        self.suspended = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NATArg_PortRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NATArg_PortRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NATArg_ExternalAddress {
    // message fields
    pub ext_addr: ::std::string::String,
    pub port_ranges: ::protobuf::RepeatedField<NATArg_PortRange>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NATArg_ExternalAddress {
    fn default() -> &'a NATArg_ExternalAddress {
        <NATArg_ExternalAddress as ::protobuf::Message>::default_instance()
    }
}

impl NATArg_ExternalAddress {
    pub fn new() -> NATArg_ExternalAddress {
        ::std::default::Default::default()
    }

    // string ext_addr = 1;

    pub fn get_ext_addr(&self) -> &str {
        &self.ext_addr
    }
    pub fn clear_ext_addr(&mut self) {
        self.ext_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_ext_addr(&mut self, v: ::std::string::String) {
        self.ext_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ext_addr(&mut self) -> &mut ::std::string::String {
        &mut self.ext_addr
    }

    // Take field
    pub fn take_ext_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ext_addr, ::std::string::String::new())
    }

    // repeated .bess.pb.NATArg.PortRange port_ranges = 2;

    pub fn get_port_ranges(&self) -> &[NATArg_PortRange] {
        &self.port_ranges
    }
    pub fn clear_port_ranges(&mut self) {
        self.port_ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_ranges(&mut self, v: ::protobuf::RepeatedField<NATArg_PortRange>) {
        self.port_ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_port_ranges(&mut self) -> &mut ::protobuf::RepeatedField<NATArg_PortRange> {
        &mut self.port_ranges
    }

    // Take field
    pub fn take_port_ranges(&mut self) -> ::protobuf::RepeatedField<NATArg_PortRange> {
        ::std::mem::replace(&mut self.port_ranges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NATArg_ExternalAddress {
    fn is_initialized(&self) -> bool {
        for v in &self.port_ranges {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.ext_addr,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.port_ranges,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ext_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ext_addr);
        }
        for value in &self.port_ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.ext_addr.is_empty() {
            os.write_string(1, &self.ext_addr)?;
        }
        for v in &self.port_ranges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NATArg_ExternalAddress {
        NATArg_ExternalAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "ext_addr",
                |m: &NATArg_ExternalAddress| &m.ext_addr,
                |m: &mut NATArg_ExternalAddress| &mut m.ext_addr,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<NATArg_PortRange>,
                >(
                    "port_ranges",
                    |m: &NATArg_ExternalAddress| &m.port_ranges,
                    |m: &mut NATArg_ExternalAddress| &mut m.port_ranges,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NATArg_ExternalAddress>(
                "NATArg.ExternalAddress",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static NATArg_ExternalAddress {
        static instance: ::protobuf::rt::LazyV2<NATArg_ExternalAddress> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(NATArg_ExternalAddress::new)
    }
}

impl ::protobuf::Clear for NATArg_ExternalAddress {
    fn clear(&mut self) {
        self.ext_addr.clear();
        self.port_ranges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NATArg_ExternalAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NATArg_ExternalAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StaticNATArg {
    // message fields
    pub pairs: ::protobuf::RepeatedField<StaticNATArg_AddressRangePair>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StaticNATArg {
    fn default() -> &'a StaticNATArg {
        <StaticNATArg as ::protobuf::Message>::default_instance()
    }
}

impl StaticNATArg {
    pub fn new() -> StaticNATArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.StaticNATArg.AddressRangePair pairs = 1;

    pub fn get_pairs(&self) -> &[StaticNATArg_AddressRangePair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<StaticNATArg_AddressRangePair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<StaticNATArg_AddressRangePair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<StaticNATArg_AddressRangePair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StaticNATArg {
    fn is_initialized(&self) -> bool {
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pairs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StaticNATArg {
        StaticNATArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<StaticNATArg_AddressRangePair>,
                >(
                    "pairs",
                    |m: &StaticNATArg| &m.pairs,
                    |m: &mut StaticNATArg| &mut m.pairs,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StaticNATArg>(
                "StaticNATArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static StaticNATArg {
        static instance: ::protobuf::rt::LazyV2<StaticNATArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StaticNATArg::new)
    }
}

impl ::protobuf::Clear for StaticNATArg {
    fn clear(&mut self) {
        self.pairs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StaticNATArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StaticNATArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StaticNATArg_AddressRange {
    // message fields
    pub start: ::std::string::String,
    pub end: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StaticNATArg_AddressRange {
    fn default() -> &'a StaticNATArg_AddressRange {
        <StaticNATArg_AddressRange as ::protobuf::Message>::default_instance()
    }
}

impl StaticNATArg_AddressRange {
    pub fn new() -> StaticNATArg_AddressRange {
        ::std::default::Default::default()
    }

    // string start = 1;

    pub fn get_start(&self) -> &str {
        &self.start
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::std::string::String) {
        self.start = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::std::string::String {
        &mut self.start
    }

    // Take field
    pub fn take_start(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.start, ::std::string::String::new())
    }

    // string end = 2;

    pub fn get_end(&self) -> &str {
        &self.end
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::std::string::String) {
        self.end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::std::string::String {
        &mut self.end
    }

    // Take field
    pub fn take_end(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.end, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StaticNATArg_AddressRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.start,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.end)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.start.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.start);
        }
        if !self.end.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.end);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.start.is_empty() {
            os.write_string(1, &self.start)?;
        }
        if !self.end.is_empty() {
            os.write_string(2, &self.end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StaticNATArg_AddressRange {
        StaticNATArg_AddressRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "start",
                |m: &StaticNATArg_AddressRange| &m.start,
                |m: &mut StaticNATArg_AddressRange| &mut m.start,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "end",
                |m: &StaticNATArg_AddressRange| &m.end,
                |m: &mut StaticNATArg_AddressRange| &mut m.end,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StaticNATArg_AddressRange>(
                "StaticNATArg.AddressRange",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static StaticNATArg_AddressRange {
        static instance: ::protobuf::rt::LazyV2<StaticNATArg_AddressRange> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(StaticNATArg_AddressRange::new)
    }
}

impl ::protobuf::Clear for StaticNATArg_AddressRange {
    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StaticNATArg_AddressRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StaticNATArg_AddressRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StaticNATArg_AddressRangePair {
    // message fields
    pub int_range: ::protobuf::SingularPtrField<StaticNATArg_AddressRange>,
    pub ext_range: ::protobuf::SingularPtrField<StaticNATArg_AddressRange>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StaticNATArg_AddressRangePair {
    fn default() -> &'a StaticNATArg_AddressRangePair {
        <StaticNATArg_AddressRangePair as ::protobuf::Message>::default_instance()
    }
}

impl StaticNATArg_AddressRangePair {
    pub fn new() -> StaticNATArg_AddressRangePair {
        ::std::default::Default::default()
    }

    // .bess.pb.StaticNATArg.AddressRange int_range = 1;

    pub fn get_int_range(&self) -> &StaticNATArg_AddressRange {
        self.int_range.as_ref().unwrap_or_else(|| {
            <StaticNATArg_AddressRange as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_int_range(&mut self) {
        self.int_range.clear();
    }

    pub fn has_int_range(&self) -> bool {
        self.int_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_range(&mut self, v: StaticNATArg_AddressRange) {
        self.int_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_int_range(&mut self) -> &mut StaticNATArg_AddressRange {
        if self.int_range.is_none() {
            self.int_range.set_default();
        }
        self.int_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_int_range(&mut self) -> StaticNATArg_AddressRange {
        self.int_range
            .take()
            .unwrap_or_else(|| StaticNATArg_AddressRange::new())
    }

    // .bess.pb.StaticNATArg.AddressRange ext_range = 2;

    pub fn get_ext_range(&self) -> &StaticNATArg_AddressRange {
        self.ext_range.as_ref().unwrap_or_else(|| {
            <StaticNATArg_AddressRange as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_ext_range(&mut self) {
        self.ext_range.clear();
    }

    pub fn has_ext_range(&self) -> bool {
        self.ext_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ext_range(&mut self, v: StaticNATArg_AddressRange) {
        self.ext_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ext_range(&mut self) -> &mut StaticNATArg_AddressRange {
        if self.ext_range.is_none() {
            self.ext_range.set_default();
        }
        self.ext_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_ext_range(&mut self) -> StaticNATArg_AddressRange {
        self.ext_range
            .take()
            .unwrap_or_else(|| StaticNATArg_AddressRange::new())
    }
}

impl ::protobuf::Message for StaticNATArg_AddressRangePair {
    fn is_initialized(&self) -> bool {
        for v in &self.int_range {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.ext_range {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.int_range)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ext_range)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.int_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ext_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.int_range.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ext_range.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StaticNATArg_AddressRangePair {
        StaticNATArg_AddressRangePair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<StaticNATArg_AddressRange>,
                >(
                    "int_range",
                    |m: &StaticNATArg_AddressRangePair| &m.int_range,
                    |m: &mut StaticNATArg_AddressRangePair| &mut m.int_range,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<StaticNATArg_AddressRange>,
                >(
                    "ext_range",
                    |m: &StaticNATArg_AddressRangePair| &m.ext_range,
                    |m: &mut StaticNATArg_AddressRangePair| &mut m.ext_range,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StaticNATArg_AddressRangePair>(
                "StaticNATArg.AddressRangePair",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static StaticNATArg_AddressRangePair {
        static instance: ::protobuf::rt::LazyV2<StaticNATArg_AddressRangePair> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(StaticNATArg_AddressRangePair::new)
    }
}

impl ::protobuf::Clear for StaticNATArg_AddressRangePair {
    fn clear(&mut self) {
        self.int_range.clear();
        self.ext_range.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StaticNATArg_AddressRangePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StaticNATArg_AddressRangePair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NoOpArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NoOpArg {
    fn default() -> &'a NoOpArg {
        <NoOpArg as ::protobuf::Message>::default_instance()
    }
}

impl NoOpArg {
    pub fn new() -> NoOpArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NoOpArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NoOpArg {
        NoOpArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NoOpArg>(
                "NoOpArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static NoOpArg {
        static instance: ::protobuf::rt::LazyV2<NoOpArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NoOpArg::new)
    }
}

impl ::protobuf::Clear for NoOpArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NoOpArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoOpArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PortIncArg {
    // message fields
    pub port: ::std::string::String,
    pub prefetch: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortIncArg {
    fn default() -> &'a PortIncArg {
        <PortIncArg as ::protobuf::Message>::default_instance()
    }
}

impl PortIncArg {
    pub fn new() -> PortIncArg {
        ::std::default::Default::default()
    }

    // string port = 1;

    pub fn get_port(&self) -> &str {
        &self.port
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: ::std::string::String) {
        self.port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut ::std::string::String {
        &mut self.port
    }

    // Take field
    pub fn take_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port, ::std::string::String::new())
    }

    // bool prefetch = 2;

    pub fn get_prefetch(&self) -> bool {
        self.prefetch
    }
    pub fn clear_prefetch(&mut self) {
        self.prefetch = false;
    }

    // Param is passed by value, moved
    pub fn set_prefetch(&mut self, v: bool) {
        self.prefetch = v;
    }
}

impl ::protobuf::Message for PortIncArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.port,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.prefetch = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port);
        }
        if self.prefetch != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.port.is_empty() {
            os.write_string(1, &self.port)?;
        }
        if self.prefetch != false {
            os.write_bool(2, self.prefetch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortIncArg {
        PortIncArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "port",
                |m: &PortIncArg| &m.port,
                |m: &mut PortIncArg| &mut m.port,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "prefetch",
                |m: &PortIncArg| &m.prefetch,
                |m: &mut PortIncArg| &mut m.prefetch,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortIncArg>(
                "PortIncArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static PortIncArg {
        static instance: ::protobuf::rt::LazyV2<PortIncArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortIncArg::new)
    }
}

impl ::protobuf::Clear for PortIncArg {
    fn clear(&mut self) {
        self.port.clear();
        self.prefetch = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortIncArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortIncArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PortOutArg {
    // message fields
    pub port: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortOutArg {
    fn default() -> &'a PortOutArg {
        <PortOutArg as ::protobuf::Message>::default_instance()
    }
}

impl PortOutArg {
    pub fn new() -> PortOutArg {
        ::std::default::Default::default()
    }

    // string port = 1;

    pub fn get_port(&self) -> &str {
        &self.port
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: ::std::string::String) {
        self.port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut ::std::string::String {
        &mut self.port
    }

    // Take field
    pub fn take_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PortOutArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.port,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.port.is_empty() {
            os.write_string(1, &self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortOutArg {
        PortOutArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "port",
                |m: &PortOutArg| &m.port,
                |m: &mut PortOutArg| &mut m.port,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortOutArg>(
                "PortOutArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static PortOutArg {
        static instance: ::protobuf::rt::LazyV2<PortOutArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortOutArg::new)
    }
}

impl ::protobuf::Clear for PortOutArg {
    fn clear(&mut self) {
        self.port.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortOutArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortOutArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct QueueIncArg {
    // message fields
    pub port: ::std::string::String,
    pub qid: u64,
    pub prefetch: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueIncArg {
    fn default() -> &'a QueueIncArg {
        <QueueIncArg as ::protobuf::Message>::default_instance()
    }
}

impl QueueIncArg {
    pub fn new() -> QueueIncArg {
        ::std::default::Default::default()
    }

    // string port = 1;

    pub fn get_port(&self) -> &str {
        &self.port
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: ::std::string::String) {
        self.port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut ::std::string::String {
        &mut self.port
    }

    // Take field
    pub fn take_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port, ::std::string::String::new())
    }

    // uint64 qid = 2;

    pub fn get_qid(&self) -> u64 {
        self.qid
    }
    pub fn clear_qid(&mut self) {
        self.qid = 0;
    }

    // Param is passed by value, moved
    pub fn set_qid(&mut self, v: u64) {
        self.qid = v;
    }

    // bool prefetch = 3;

    pub fn get_prefetch(&self) -> bool {
        self.prefetch
    }
    pub fn clear_prefetch(&mut self) {
        self.prefetch = false;
    }

    // Param is passed by value, moved
    pub fn set_prefetch(&mut self, v: bool) {
        self.prefetch = v;
    }
}

impl ::protobuf::Message for QueueIncArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.port,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.qid = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.prefetch = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port);
        }
        if self.qid != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.qid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prefetch != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.port.is_empty() {
            os.write_string(1, &self.port)?;
        }
        if self.qid != 0 {
            os.write_uint64(2, self.qid)?;
        }
        if self.prefetch != false {
            os.write_bool(3, self.prefetch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueIncArg {
        QueueIncArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "port",
                |m: &QueueIncArg| &m.port,
                |m: &mut QueueIncArg| &mut m.port,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "qid",
                |m: &QueueIncArg| &m.qid,
                |m: &mut QueueIncArg| &mut m.qid,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "prefetch",
                |m: &QueueIncArg| &m.prefetch,
                |m: &mut QueueIncArg| &mut m.prefetch,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueIncArg>(
                "QueueIncArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static QueueIncArg {
        static instance: ::protobuf::rt::LazyV2<QueueIncArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueIncArg::new)
    }
}

impl ::protobuf::Clear for QueueIncArg {
    fn clear(&mut self) {
        self.port.clear();
        self.qid = 0;
        self.prefetch = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueIncArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueIncArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct QueueOutArg {
    // message fields
    pub port: ::std::string::String,
    pub qid: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueOutArg {
    fn default() -> &'a QueueOutArg {
        <QueueOutArg as ::protobuf::Message>::default_instance()
    }
}

impl QueueOutArg {
    pub fn new() -> QueueOutArg {
        ::std::default::Default::default()
    }

    // string port = 1;

    pub fn get_port(&self) -> &str {
        &self.port
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: ::std::string::String) {
        self.port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut ::std::string::String {
        &mut self.port
    }

    // Take field
    pub fn take_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port, ::std::string::String::new())
    }

    // uint64 qid = 2;

    pub fn get_qid(&self) -> u64 {
        self.qid
    }
    pub fn clear_qid(&mut self) {
        self.qid = 0;
    }

    // Param is passed by value, moved
    pub fn set_qid(&mut self, v: u64) {
        self.qid = v;
    }
}

impl ::protobuf::Message for QueueOutArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.port,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.qid = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port);
        }
        if self.qid != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.qid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.port.is_empty() {
            os.write_string(1, &self.port)?;
        }
        if self.qid != 0 {
            os.write_uint64(2, self.qid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueOutArg {
        QueueOutArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "port",
                |m: &QueueOutArg| &m.port,
                |m: &mut QueueOutArg| &mut m.port,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "qid",
                |m: &QueueOutArg| &m.qid,
                |m: &mut QueueOutArg| &mut m.qid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueOutArg>(
                "QueueOutArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static QueueOutArg {
        static instance: ::protobuf::rt::LazyV2<QueueOutArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueOutArg::new)
    }
}

impl ::protobuf::Clear for QueueOutArg {
    fn clear(&mut self) {
        self.port.clear();
        self.qid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueOutArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueOutArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct QueueArg {
    // message fields
    pub size: u64,
    pub prefetch: bool,
    pub backpressure: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueArg {
    fn default() -> &'a QueueArg {
        <QueueArg as ::protobuf::Message>::default_instance()
    }
}

impl QueueArg {
    pub fn new() -> QueueArg {
        ::std::default::Default::default()
    }

    // uint64 size = 1;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // bool prefetch = 2;

    pub fn get_prefetch(&self) -> bool {
        self.prefetch
    }
    pub fn clear_prefetch(&mut self) {
        self.prefetch = false;
    }

    // Param is passed by value, moved
    pub fn set_prefetch(&mut self, v: bool) {
        self.prefetch = v;
    }

    // bool backpressure = 3;

    pub fn get_backpressure(&self) -> bool {
        self.backpressure
    }
    pub fn clear_backpressure(&mut self) {
        self.backpressure = false;
    }

    // Param is passed by value, moved
    pub fn set_backpressure(&mut self, v: bool) {
        self.backpressure = v;
    }
}

impl ::protobuf::Message for QueueArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.prefetch = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.backpressure = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prefetch != false {
            my_size += 2;
        }
        if self.backpressure != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.size != 0 {
            os.write_uint64(1, self.size)?;
        }
        if self.prefetch != false {
            os.write_bool(2, self.prefetch)?;
        }
        if self.backpressure != false {
            os.write_bool(3, self.backpressure)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueArg {
        QueueArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &QueueArg| &m.size,
                |m: &mut QueueArg| &mut m.size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "prefetch",
                |m: &QueueArg| &m.prefetch,
                |m: &mut QueueArg| &mut m.prefetch,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "backpressure",
                |m: &QueueArg| &m.backpressure,
                |m: &mut QueueArg| &mut m.backpressure,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueArg>(
                "QueueArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static QueueArg {
        static instance: ::protobuf::rt::LazyV2<QueueArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueArg::new)
    }
}

impl ::protobuf::Clear for QueueArg {
    fn clear(&mut self) {
        self.size = 0;
        self.prefetch = false;
        self.backpressure = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RandomSplitArg {
    // message fields
    pub drop_rate: f64,
    pub gates: ::std::vec::Vec<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomSplitArg {
    fn default() -> &'a RandomSplitArg {
        <RandomSplitArg as ::protobuf::Message>::default_instance()
    }
}

impl RandomSplitArg {
    pub fn new() -> RandomSplitArg {
        ::std::default::Default::default()
    }

    // double drop_rate = 1;

    pub fn get_drop_rate(&self) -> f64 {
        self.drop_rate
    }
    pub fn clear_drop_rate(&mut self) {
        self.drop_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_drop_rate(&mut self, v: f64) {
        self.drop_rate = v;
    }

    // repeated int64 gates = 2;

    pub fn get_gates(&self) -> &[i64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<i64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RandomSplitArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.drop_rate = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.drop_rate != 0. {
            my_size += 9;
        }
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.drop_rate != 0. {
            os.write_double(1, self.drop_rate)?;
        }
        for v in &self.gates {
            os.write_int64(2, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomSplitArg {
        RandomSplitArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "drop_rate",
                |m: &RandomSplitArg| &m.drop_rate,
                |m: &mut RandomSplitArg| &mut m.drop_rate,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gates",
                |m: &RandomSplitArg| &m.gates,
                |m: &mut RandomSplitArg| &mut m.gates,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandomSplitArg>(
                "RandomSplitArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RandomSplitArg {
        static instance: ::protobuf::rt::LazyV2<RandomSplitArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RandomSplitArg::new)
    }
}

impl ::protobuf::Clear for RandomSplitArg {
    fn clear(&mut self) {
        self.drop_rate = 0.;
        self.gates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandomSplitArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomSplitArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RandomSplitCommandSetDroprateArg {
    // message fields
    pub drop_rate: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomSplitCommandSetDroprateArg {
    fn default() -> &'a RandomSplitCommandSetDroprateArg {
        <RandomSplitCommandSetDroprateArg as ::protobuf::Message>::default_instance()
    }
}

impl RandomSplitCommandSetDroprateArg {
    pub fn new() -> RandomSplitCommandSetDroprateArg {
        ::std::default::Default::default()
    }

    // double drop_rate = 1;

    pub fn get_drop_rate(&self) -> f64 {
        self.drop_rate
    }
    pub fn clear_drop_rate(&mut self) {
        self.drop_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_drop_rate(&mut self, v: f64) {
        self.drop_rate = v;
    }
}

impl ::protobuf::Message for RandomSplitCommandSetDroprateArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.drop_rate = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.drop_rate != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.drop_rate != 0. {
            os.write_double(1, self.drop_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomSplitCommandSetDroprateArg {
        RandomSplitCommandSetDroprateArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "drop_rate",
                |m: &RandomSplitCommandSetDroprateArg| &m.drop_rate,
                |m: &mut RandomSplitCommandSetDroprateArg| &mut m.drop_rate,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandomSplitCommandSetDroprateArg>(
                "RandomSplitCommandSetDroprateArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RandomSplitCommandSetDroprateArg {
        static instance: ::protobuf::rt::LazyV2<RandomSplitCommandSetDroprateArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(RandomSplitCommandSetDroprateArg::new)
    }
}

impl ::protobuf::Clear for RandomSplitCommandSetDroprateArg {
    fn clear(&mut self) {
        self.drop_rate = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandomSplitCommandSetDroprateArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomSplitCommandSetDroprateArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RandomSplitCommandSetGatesArg {
    // message fields
    pub gates: ::std::vec::Vec<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomSplitCommandSetGatesArg {
    fn default() -> &'a RandomSplitCommandSetGatesArg {
        <RandomSplitCommandSetGatesArg as ::protobuf::Message>::default_instance()
    }
}

impl RandomSplitCommandSetGatesArg {
    pub fn new() -> RandomSplitCommandSetGatesArg {
        ::std::default::Default::default()
    }

    // repeated int64 gates = 1;

    pub fn get_gates(&self) -> &[i64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<i64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RandomSplitCommandSetGatesArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gates {
            os.write_int64(1, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomSplitCommandSetGatesArg {
        RandomSplitCommandSetGatesArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gates",
                |m: &RandomSplitCommandSetGatesArg| &m.gates,
                |m: &mut RandomSplitCommandSetGatesArg| &mut m.gates,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandomSplitCommandSetGatesArg>(
                "RandomSplitCommandSetGatesArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RandomSplitCommandSetGatesArg {
        static instance: ::protobuf::rt::LazyV2<RandomSplitCommandSetGatesArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(RandomSplitCommandSetGatesArg::new)
    }
}

impl ::protobuf::Clear for RandomSplitCommandSetGatesArg {
    fn clear(&mut self) {
        self.gates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandomSplitCommandSetGatesArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomSplitCommandSetGatesArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RandomUpdateArg {
    // message fields
    pub fields: ::protobuf::RepeatedField<RandomUpdateArg_Field>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomUpdateArg {
    fn default() -> &'a RandomUpdateArg {
        <RandomUpdateArg as ::protobuf::Message>::default_instance()
    }
}

impl RandomUpdateArg {
    pub fn new() -> RandomUpdateArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.RandomUpdateArg.Field fields = 1;

    pub fn get_fields(&self) -> &[RandomUpdateArg_Field] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<RandomUpdateArg_Field>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<RandomUpdateArg_Field> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<RandomUpdateArg_Field> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RandomUpdateArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomUpdateArg {
        RandomUpdateArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<RandomUpdateArg_Field>,
                >(
                    "fields",
                    |m: &RandomUpdateArg| &m.fields,
                    |m: &mut RandomUpdateArg| &mut m.fields,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandomUpdateArg>(
                "RandomUpdateArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RandomUpdateArg {
        static instance: ::protobuf::rt::LazyV2<RandomUpdateArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RandomUpdateArg::new)
    }
}

impl ::protobuf::Clear for RandomUpdateArg {
    fn clear(&mut self) {
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandomUpdateArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomUpdateArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RandomUpdateArg_Field {
    // message fields
    pub offset: i64,
    pub size: u64,
    pub min: u64,
    pub max: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomUpdateArg_Field {
    fn default() -> &'a RandomUpdateArg_Field {
        <RandomUpdateArg_Field as ::protobuf::Message>::default_instance()
    }
}

impl RandomUpdateArg_Field {
    pub fn new() -> RandomUpdateArg_Field {
        ::std::default::Default::default()
    }

    // int64 offset = 1;

    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // uint64 size = 2;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // uint64 min = 3;

    pub fn get_min(&self) -> u64 {
        self.min
    }
    pub fn clear_min(&mut self) {
        self.min = 0;
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: u64) {
        self.min = v;
    }

    // uint64 max = 4;

    pub fn get_max(&self) -> u64 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: u64) {
        self.max = v;
    }
}

impl ::protobuf::Message for RandomUpdateArg_Field {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.min = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.max = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.offset != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.min, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max != 0 {
            my_size +=
                ::protobuf::rt::value_size(4, self.max, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.offset != 0 {
            os.write_int64(1, self.offset)?;
        }
        if self.size != 0 {
            os.write_uint64(2, self.size)?;
        }
        if self.min != 0 {
            os.write_uint64(3, self.min)?;
        }
        if self.max != 0 {
            os.write_uint64(4, self.max)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomUpdateArg_Field {
        RandomUpdateArg_Field::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "offset",
                |m: &RandomUpdateArg_Field| &m.offset,
                |m: &mut RandomUpdateArg_Field| &mut m.offset,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &RandomUpdateArg_Field| &m.size,
                |m: &mut RandomUpdateArg_Field| &mut m.size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "min",
                |m: &RandomUpdateArg_Field| &m.min,
                |m: &mut RandomUpdateArg_Field| &mut m.min,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "max",
                |m: &RandomUpdateArg_Field| &m.max,
                |m: &mut RandomUpdateArg_Field| &mut m.max,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandomUpdateArg_Field>(
                "RandomUpdateArg.Field",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RandomUpdateArg_Field {
        static instance: ::protobuf::rt::LazyV2<RandomUpdateArg_Field> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(RandomUpdateArg_Field::new)
    }
}

impl ::protobuf::Clear for RandomUpdateArg_Field {
    fn clear(&mut self) {
        self.offset = 0;
        self.size = 0;
        self.min = 0;
        self.max = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandomUpdateArg_Field {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomUpdateArg_Field {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RewriteArg {
    // message fields
    pub templates: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewriteArg {
    fn default() -> &'a RewriteArg {
        <RewriteArg as ::protobuf::Message>::default_instance()
    }
}

impl RewriteArg {
    pub fn new() -> RewriteArg {
        ::std::default::Default::default()
    }

    // repeated bytes templates = 1;

    pub fn get_templates(&self) -> &[::std::vec::Vec<u8>] {
        &self.templates
    }
    pub fn clear_templates(&mut self) {
        self.templates.clear();
    }

    // Param is passed by value, moved
    pub fn set_templates(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.templates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_templates(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.templates
    }

    // Take field
    pub fn take_templates(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.templates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RewriteArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.templates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.templates {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.templates {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewriteArg {
        RewriteArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeBytes,
                >(
                    "templates",
                    |m: &RewriteArg| &m.templates,
                    |m: &mut RewriteArg| &mut m.templates,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RewriteArg>(
                "RewriteArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RewriteArg {
        static instance: ::protobuf::rt::LazyV2<RewriteArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RewriteArg::new)
    }
}

impl ::protobuf::Clear for RewriteArg {
    fn clear(&mut self) {
        self.templates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RewriteArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RewriteArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RoundRobinCommandSetGatesArg {
    // message fields
    pub gates: ::std::vec::Vec<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoundRobinCommandSetGatesArg {
    fn default() -> &'a RoundRobinCommandSetGatesArg {
        <RoundRobinCommandSetGatesArg as ::protobuf::Message>::default_instance()
    }
}

impl RoundRobinCommandSetGatesArg {
    pub fn new() -> RoundRobinCommandSetGatesArg {
        ::std::default::Default::default()
    }

    // repeated int64 gates = 1;

    pub fn get_gates(&self) -> &[i64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<i64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RoundRobinCommandSetGatesArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gates {
            os.write_int64(1, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoundRobinCommandSetGatesArg {
        RoundRobinCommandSetGatesArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gates",
                |m: &RoundRobinCommandSetGatesArg| &m.gates,
                |m: &mut RoundRobinCommandSetGatesArg| &mut m.gates,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoundRobinCommandSetGatesArg>(
                "RoundRobinCommandSetGatesArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RoundRobinCommandSetGatesArg {
        static instance: ::protobuf::rt::LazyV2<RoundRobinCommandSetGatesArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(RoundRobinCommandSetGatesArg::new)
    }
}

impl ::protobuf::Clear for RoundRobinCommandSetGatesArg {
    fn clear(&mut self) {
        self.gates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoundRobinCommandSetGatesArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoundRobinCommandSetGatesArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RoundRobinCommandSetModeArg {
    // message fields
    pub mode: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoundRobinCommandSetModeArg {
    fn default() -> &'a RoundRobinCommandSetModeArg {
        <RoundRobinCommandSetModeArg as ::protobuf::Message>::default_instance()
    }
}

impl RoundRobinCommandSetModeArg {
    pub fn new() -> RoundRobinCommandSetModeArg {
        ::std::default::Default::default()
    }

    // string mode = 1;

    pub fn get_mode(&self) -> &str {
        &self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ::std::string::String) {
        self.mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut ::std::string::String {
        &mut self.mode
    }

    // Take field
    pub fn take_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mode, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RoundRobinCommandSetModeArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mode,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.mode.is_empty() {
            os.write_string(1, &self.mode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoundRobinCommandSetModeArg {
        RoundRobinCommandSetModeArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mode",
                |m: &RoundRobinCommandSetModeArg| &m.mode,
                |m: &mut RoundRobinCommandSetModeArg| &mut m.mode,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoundRobinCommandSetModeArg>(
                "RoundRobinCommandSetModeArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RoundRobinCommandSetModeArg {
        static instance: ::protobuf::rt::LazyV2<RoundRobinCommandSetModeArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(RoundRobinCommandSetModeArg::new)
    }
}

impl ::protobuf::Clear for RoundRobinCommandSetModeArg {
    fn clear(&mut self) {
        self.mode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoundRobinCommandSetModeArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoundRobinCommandSetModeArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RoundRobinArg {
    // message fields
    pub gates: ::std::vec::Vec<i64>,
    pub mode: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoundRobinArg {
    fn default() -> &'a RoundRobinArg {
        <RoundRobinArg as ::protobuf::Message>::default_instance()
    }
}

impl RoundRobinArg {
    pub fn new() -> RoundRobinArg {
        ::std::default::Default::default()
    }

    // repeated int64 gates = 1;

    pub fn get_gates(&self) -> &[i64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<i64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }

    // string mode = 2;

    pub fn get_mode(&self) -> &str {
        &self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ::std::string::String) {
        self.mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut ::std::string::String {
        &mut self.mode
    }

    // Take field
    pub fn take_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mode, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RoundRobinArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gates)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mode,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gates {
            os.write_int64(1, *v)?;
        }
        if !self.mode.is_empty() {
            os.write_string(2, &self.mode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoundRobinArg {
        RoundRobinArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gates",
                |m: &RoundRobinArg| &m.gates,
                |m: &mut RoundRobinArg| &mut m.gates,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mode",
                |m: &RoundRobinArg| &m.mode,
                |m: &mut RoundRobinArg| &mut m.mode,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoundRobinArg>(
                "RoundRobinArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RoundRobinArg {
        static instance: ::protobuf::rt::LazyV2<RoundRobinArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoundRobinArg::new)
    }
}

impl ::protobuf::Clear for RoundRobinArg {
    fn clear(&mut self) {
        self.gates.clear();
        self.mode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoundRobinArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoundRobinArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ReplicateArg {
    // message fields
    pub gates: ::std::vec::Vec<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicateArg {
    fn default() -> &'a ReplicateArg {
        <ReplicateArg as ::protobuf::Message>::default_instance()
    }
}

impl ReplicateArg {
    pub fn new() -> ReplicateArg {
        ::std::default::Default::default()
    }

    // repeated int64 gates = 1;

    pub fn get_gates(&self) -> &[i64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<i64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReplicateArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gates {
            os.write_int64(1, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicateArg {
        ReplicateArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gates",
                |m: &ReplicateArg| &m.gates,
                |m: &mut ReplicateArg| &mut m.gates,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicateArg>(
                "ReplicateArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ReplicateArg {
        static instance: ::protobuf::rt::LazyV2<ReplicateArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicateArg::new)
    }
}

impl ::protobuf::Clear for ReplicateArg {
    fn clear(&mut self) {
        self.gates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicateArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicateArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ReplicateCommandSetGatesArg {
    // message fields
    pub gates: ::std::vec::Vec<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicateCommandSetGatesArg {
    fn default() -> &'a ReplicateCommandSetGatesArg {
        <ReplicateCommandSetGatesArg as ::protobuf::Message>::default_instance()
    }
}

impl ReplicateCommandSetGatesArg {
    pub fn new() -> ReplicateCommandSetGatesArg {
        ::std::default::Default::default()
    }

    // repeated int64 gates = 1;

    pub fn get_gates(&self) -> &[i64] {
        &self.gates
    }
    pub fn clear_gates(&mut self) {
        self.gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_gates(&mut self, v: ::std::vec::Vec<i64>) {
        self.gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gates(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gates
    }

    // Take field
    pub fn take_gates(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gates, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReplicateCommandSetGatesArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gates {
            my_size +=
                ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gates {
            os.write_int64(1, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicateCommandSetGatesArg {
        ReplicateCommandSetGatesArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "gates",
                |m: &ReplicateCommandSetGatesArg| &m.gates,
                |m: &mut ReplicateCommandSetGatesArg| &mut m.gates,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicateCommandSetGatesArg>(
                "ReplicateCommandSetGatesArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ReplicateCommandSetGatesArg {
        static instance: ::protobuf::rt::LazyV2<ReplicateCommandSetGatesArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicateCommandSetGatesArg::new)
    }
}

impl ::protobuf::Clear for ReplicateCommandSetGatesArg {
    fn clear(&mut self) {
        self.gates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicateCommandSetGatesArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicateCommandSetGatesArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SetMetadataArg {
    // message fields
    pub attrs: ::protobuf::RepeatedField<SetMetadataArg_Attribute>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMetadataArg {
    fn default() -> &'a SetMetadataArg {
        <SetMetadataArg as ::protobuf::Message>::default_instance()
    }
}

impl SetMetadataArg {
    pub fn new() -> SetMetadataArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.SetMetadataArg.Attribute attrs = 1;

    pub fn get_attrs(&self) -> &[SetMetadataArg_Attribute] {
        &self.attrs
    }
    pub fn clear_attrs(&mut self) {
        self.attrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_attrs(&mut self, v: ::protobuf::RepeatedField<SetMetadataArg_Attribute>) {
        self.attrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attrs(&mut self) -> &mut ::protobuf::RepeatedField<SetMetadataArg_Attribute> {
        &mut self.attrs
    }

    // Take field
    pub fn take_attrs(&mut self) -> ::protobuf::RepeatedField<SetMetadataArg_Attribute> {
        ::std::mem::replace(&mut self.attrs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SetMetadataArg {
    fn is_initialized(&self) -> bool {
        for v in &self.attrs {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attrs)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.attrs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMetadataArg {
        SetMetadataArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<SetMetadataArg_Attribute>,
                >(
                    "attrs",
                    |m: &SetMetadataArg| &m.attrs,
                    |m: &mut SetMetadataArg| &mut m.attrs,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetMetadataArg>(
                "SetMetadataArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static SetMetadataArg {
        static instance: ::protobuf::rt::LazyV2<SetMetadataArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMetadataArg::new)
    }
}

impl ::protobuf::Clear for SetMetadataArg {
    fn clear(&mut self) {
        self.attrs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMetadataArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMetadataArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SetMetadataArg_Attribute {
    // message fields
    pub name: ::std::string::String,
    pub size: u64,
    pub offset: i32,
    pub mask: ::std::vec::Vec<u8>,
    pub rshift_bits: i32,
    // message oneof groups
    pub value: ::std::option::Option<SetMetadataArg_Attribute_oneof_value>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMetadataArg_Attribute {
    fn default() -> &'a SetMetadataArg_Attribute {
        <SetMetadataArg_Attribute as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum SetMetadataArg_Attribute_oneof_value {
    value_int(u64),
    value_bin(::std::vec::Vec<u8>),
}

impl SetMetadataArg_Attribute {
    pub fn new() -> SetMetadataArg_Attribute {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 size = 2;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // uint64 value_int = 3;

    pub fn get_value_int(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_int(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_value_int(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value_int(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_int(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_int(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_int(v))
    }

    // bytes value_bin = 4;

    pub fn get_value_bin(&self) -> &[u8] {
        match self.value {
            ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_bin(ref v)) => {
                v
            }
            _ => &[],
        }
    }
    pub fn clear_value_bin(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value_bin(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_bin(..)) => {
                true
            }
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_bin(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_bin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_bin(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_bin(_)) =
            self.value
        {
        } else {
            self.value = ::std::option::Option::Some(
                SetMetadataArg_Attribute_oneof_value::value_bin(::std::vec::Vec::new()),
            );
        }
        match self.value {
            ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_bin(
                ref mut v,
            )) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_bin(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_value_bin() {
            match self.value.take() {
                ::std::option::Option::Some(SetMetadataArg_Attribute_oneof_value::value_bin(v)) => {
                    v
                }
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // int32 offset = 5;

    pub fn get_offset(&self) -> i32 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = v;
    }

    // bytes mask = 6;

    pub fn get_mask(&self) -> &[u8] {
        &self.mask
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.mask
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.mask, ::std::vec::Vec::new())
    }

    // int32 rshift_bits = 7;

    pub fn get_rshift_bits(&self) -> i32 {
        self.rshift_bits
    }
    pub fn clear_rshift_bits(&mut self) {
        self.rshift_bits = 0;
    }

    // Param is passed by value, moved
    pub fn set_rshift_bits(&mut self, v: i32) {
        self.rshift_bits = v;
    }
}

impl ::protobuf::Message for SetMetadataArg_Attribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.value = ::std::option::Option::Some(
                        SetMetadataArg_Attribute_oneof_value::value_int(is.read_uint64()?),
                    );
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.value = ::std::option::Option::Some(
                        SetMetadataArg_Attribute_oneof_value::value_bin(is.read_bytes()?),
                    );
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.offset = tmp;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.mask)?;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.rshift_bits = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size +=
                ::protobuf::rt::value_size(5, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mask.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.mask);
        }
        if self.rshift_bits != 0 {
            my_size += ::protobuf::rt::value_size(
                7,
                self.rshift_bits,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &SetMetadataArg_Attribute_oneof_value::value_int(v) => {
                    my_size +=
                        ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                }
                &SetMetadataArg_Attribute_oneof_value::value_bin(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.size != 0 {
            os.write_uint64(2, self.size)?;
        }
        if self.offset != 0 {
            os.write_int32(5, self.offset)?;
        }
        if !self.mask.is_empty() {
            os.write_bytes(6, &self.mask)?;
        }
        if self.rshift_bits != 0 {
            os.write_int32(7, self.rshift_bits)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &SetMetadataArg_Attribute_oneof_value::value_int(v) => {
                    os.write_uint64(3, v)?;
                }
                &SetMetadataArg_Attribute_oneof_value::value_bin(ref v) => {
                    os.write_bytes(4, v)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMetadataArg_Attribute {
        SetMetadataArg_Attribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &SetMetadataArg_Attribute| &m.name,
                |m: &mut SetMetadataArg_Attribute| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &SetMetadataArg_Attribute| &m.size,
                |m: &mut SetMetadataArg_Attribute| &mut m.size,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "value_int",
                    SetMetadataArg_Attribute::has_value_int,
                    SetMetadataArg_Attribute::get_value_int,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "value_bin",
                    SetMetadataArg_Attribute::has_value_bin,
                    SetMetadataArg_Attribute::get_value_bin,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "offset",
                |m: &SetMetadataArg_Attribute| &m.offset,
                |m: &mut SetMetadataArg_Attribute| &mut m.offset,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBytes,
            >(
                "mask",
                |m: &SetMetadataArg_Attribute| &m.mask,
                |m: &mut SetMetadataArg_Attribute| &mut m.mask,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "rshift_bits",
                |m: &SetMetadataArg_Attribute| &m.rshift_bits,
                |m: &mut SetMetadataArg_Attribute| &mut m.rshift_bits,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetMetadataArg_Attribute>(
                "SetMetadataArg.Attribute",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static SetMetadataArg_Attribute {
        static instance: ::protobuf::rt::LazyV2<SetMetadataArg_Attribute> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMetadataArg_Attribute::new)
    }
}

impl ::protobuf::Clear for SetMetadataArg_Attribute {
    fn clear(&mut self) {
        self.name.clear();
        self.size = 0;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.offset = 0;
        self.mask.clear();
        self.rshift_bits = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMetadataArg_Attribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMetadataArg_Attribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SinkArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SinkArg {
    fn default() -> &'a SinkArg {
        <SinkArg as ::protobuf::Message>::default_instance()
    }
}

impl SinkArg {
    pub fn new() -> SinkArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SinkArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SinkArg {
        SinkArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SinkArg>(
                "SinkArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static SinkArg {
        static instance: ::protobuf::rt::LazyV2<SinkArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SinkArg::new)
    }
}

impl ::protobuf::Clear for SinkArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SinkArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinkArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SourceCommandSetBurstArg {
    // message fields
    pub burst: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SourceCommandSetBurstArg {
    fn default() -> &'a SourceCommandSetBurstArg {
        <SourceCommandSetBurstArg as ::protobuf::Message>::default_instance()
    }
}

impl SourceCommandSetBurstArg {
    pub fn new() -> SourceCommandSetBurstArg {
        ::std::default::Default::default()
    }

    // uint64 burst = 1;

    pub fn get_burst(&self) -> u64 {
        self.burst
    }
    pub fn clear_burst(&mut self) {
        self.burst = 0;
    }

    // Param is passed by value, moved
    pub fn set_burst(&mut self, v: u64) {
        self.burst = v;
    }
}

impl ::protobuf::Message for SourceCommandSetBurstArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.burst = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.burst != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.burst, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.burst != 0 {
            os.write_uint64(1, self.burst)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SourceCommandSetBurstArg {
        SourceCommandSetBurstArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "burst",
                |m: &SourceCommandSetBurstArg| &m.burst,
                |m: &mut SourceCommandSetBurstArg| &mut m.burst,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SourceCommandSetBurstArg>(
                "SourceCommandSetBurstArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static SourceCommandSetBurstArg {
        static instance: ::protobuf::rt::LazyV2<SourceCommandSetBurstArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(SourceCommandSetBurstArg::new)
    }
}

impl ::protobuf::Clear for SourceCommandSetBurstArg {
    fn clear(&mut self) {
        self.burst = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SourceCommandSetBurstArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceCommandSetBurstArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SourceCommandSetPktSizeArg {
    // message fields
    pub pkt_size: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SourceCommandSetPktSizeArg {
    fn default() -> &'a SourceCommandSetPktSizeArg {
        <SourceCommandSetPktSizeArg as ::protobuf::Message>::default_instance()
    }
}

impl SourceCommandSetPktSizeArg {
    pub fn new() -> SourceCommandSetPktSizeArg {
        ::std::default::Default::default()
    }

    // uint64 pkt_size = 1;

    pub fn get_pkt_size(&self) -> u64 {
        self.pkt_size
    }
    pub fn clear_pkt_size(&mut self) {
        self.pkt_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_pkt_size(&mut self, v: u64) {
        self.pkt_size = v;
    }
}

impl ::protobuf::Message for SourceCommandSetPktSizeArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkt_size = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pkt_size != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.pkt_size,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.pkt_size != 0 {
            os.write_uint64(1, self.pkt_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SourceCommandSetPktSizeArg {
        SourceCommandSetPktSizeArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "pkt_size",
                |m: &SourceCommandSetPktSizeArg| &m.pkt_size,
                |m: &mut SourceCommandSetPktSizeArg| &mut m.pkt_size,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SourceCommandSetPktSizeArg>(
                "SourceCommandSetPktSizeArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static SourceCommandSetPktSizeArg {
        static instance: ::protobuf::rt::LazyV2<SourceCommandSetPktSizeArg> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(SourceCommandSetPktSizeArg::new)
    }
}

impl ::protobuf::Clear for SourceCommandSetPktSizeArg {
    fn clear(&mut self) {
        self.pkt_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SourceCommandSetPktSizeArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceCommandSetPktSizeArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SourceArg {
    // message fields
    pub pkt_size: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SourceArg {
    fn default() -> &'a SourceArg {
        <SourceArg as ::protobuf::Message>::default_instance()
    }
}

impl SourceArg {
    pub fn new() -> SourceArg {
        ::std::default::Default::default()
    }

    // uint64 pkt_size = 1;

    pub fn get_pkt_size(&self) -> u64 {
        self.pkt_size
    }
    pub fn clear_pkt_size(&mut self) {
        self.pkt_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_pkt_size(&mut self, v: u64) {
        self.pkt_size = v;
    }
}

impl ::protobuf::Message for SourceArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkt_size = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pkt_size != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.pkt_size,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.pkt_size != 0 {
            os.write_uint64(1, self.pkt_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SourceArg {
        SourceArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "pkt_size",
                |m: &SourceArg| &m.pkt_size,
                |m: &mut SourceArg| &mut m.pkt_size,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SourceArg>(
                "SourceArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static SourceArg {
        static instance: ::protobuf::rt::LazyV2<SourceArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SourceArg::new)
    }
}

impl ::protobuf::Clear for SourceArg {
    fn clear(&mut self) {
        self.pkt_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SourceArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IPChecksumArg {
    // message fields
    pub verify: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPChecksumArg {
    fn default() -> &'a IPChecksumArg {
        <IPChecksumArg as ::protobuf::Message>::default_instance()
    }
}

impl IPChecksumArg {
    pub fn new() -> IPChecksumArg {
        ::std::default::Default::default()
    }

    // bool verify = 1;

    pub fn get_verify(&self) -> bool {
        self.verify
    }
    pub fn clear_verify(&mut self) {
        self.verify = false;
    }

    // Param is passed by value, moved
    pub fn set_verify(&mut self, v: bool) {
        self.verify = v;
    }
}

impl ::protobuf::Message for IPChecksumArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.verify = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.verify != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.verify != false {
            os.write_bool(1, self.verify)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPChecksumArg {
        IPChecksumArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "verify",
                |m: &IPChecksumArg| &m.verify,
                |m: &mut IPChecksumArg| &mut m.verify,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPChecksumArg>(
                "IPChecksumArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static IPChecksumArg {
        static instance: ::protobuf::rt::LazyV2<IPChecksumArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IPChecksumArg::new)
    }
}

impl ::protobuf::Clear for IPChecksumArg {
    fn clear(&mut self) {
        self.verify = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPChecksumArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPChecksumArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct L4ChecksumArg {
    // message fields
    pub verify: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L4ChecksumArg {
    fn default() -> &'a L4ChecksumArg {
        <L4ChecksumArg as ::protobuf::Message>::default_instance()
    }
}

impl L4ChecksumArg {
    pub fn new() -> L4ChecksumArg {
        ::std::default::Default::default()
    }

    // bool verify = 1;

    pub fn get_verify(&self) -> bool {
        self.verify
    }
    pub fn clear_verify(&mut self) {
        self.verify = false;
    }

    // Param is passed by value, moved
    pub fn set_verify(&mut self, v: bool) {
        self.verify = v;
    }
}

impl ::protobuf::Message for L4ChecksumArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.verify = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.verify != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.verify != false {
            os.write_bool(1, self.verify)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L4ChecksumArg {
        L4ChecksumArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "verify",
                |m: &L4ChecksumArg| &m.verify,
                |m: &mut L4ChecksumArg| &mut m.verify,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L4ChecksumArg>(
                "L4ChecksumArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static L4ChecksumArg {
        static instance: ::protobuf::rt::LazyV2<L4ChecksumArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(L4ChecksumArg::new)
    }
}

impl ::protobuf::Clear for L4ChecksumArg {
    fn clear(&mut self) {
        self.verify = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L4ChecksumArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L4ChecksumArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SplitArg {
    // message fields
    pub size: u64,
    // message oneof groups
    pub field_type: ::std::option::Option<SplitArg_oneof_type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SplitArg {
    fn default() -> &'a SplitArg {
        <SplitArg as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum SplitArg_oneof_type {
    attribute(::std::string::String),
    offset(i64),
}

impl SplitArg {
    pub fn new() -> SplitArg {
        ::std::default::Default::default()
    }

    // uint64 size = 1;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // string attribute = 2;

    pub fn get_attribute(&self) -> &str {
        match self.field_type {
            ::std::option::Option::Some(SplitArg_oneof_type::attribute(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_attribute(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_attribute(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(SplitArg_oneof_type::attribute(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::std::string::String) {
        self.field_type = ::std::option::Option::Some(SplitArg_oneof_type::attribute(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(SplitArg_oneof_type::attribute(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(SplitArg_oneof_type::attribute(
                ::std::string::String::new(),
            ));
        }
        match self.field_type {
            ::std::option::Option::Some(SplitArg_oneof_type::attribute(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::std::string::String {
        if self.has_attribute() {
            match self.field_type.take() {
                ::std::option::Option::Some(SplitArg_oneof_type::attribute(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int64 offset = 3;

    pub fn get_offset(&self) -> i64 {
        match self.field_type {
            ::std::option::Option::Some(SplitArg_oneof_type::offset(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_offset(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(SplitArg_oneof_type::offset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.field_type = ::std::option::Option::Some(SplitArg_oneof_type::offset(v))
    }
}

impl ::protobuf::Message for SplitArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.field_type = ::std::option::Option::Some(SplitArg_oneof_type::attribute(
                        is.read_string()?,
                    ));
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.field_type =
                        ::std::option::Option::Some(SplitArg_oneof_type::offset(is.read_int64()?));
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &SplitArg_oneof_type::attribute(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                &SplitArg_oneof_type::offset(v) => {
                    my_size +=
                        ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.size != 0 {
            os.write_uint64(1, self.size)?;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &SplitArg_oneof_type::attribute(ref v) => {
                    os.write_string(2, v)?;
                }
                &SplitArg_oneof_type::offset(v) => {
                    os.write_int64(3, v)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SplitArg {
        SplitArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &SplitArg| &m.size,
                |m: &mut SplitArg| &mut m.size,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "attribute",
                    SplitArg::has_attribute,
                    SplitArg::get_attribute,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "offset",
                    SplitArg::has_offset,
                    SplitArg::get_offset,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SplitArg>(
                "SplitArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static SplitArg {
        static instance: ::protobuf::rt::LazyV2<SplitArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SplitArg::new)
    }
}

impl ::protobuf::Clear for SplitArg {
    fn clear(&mut self) {
        self.size = 0;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SplitArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TimestampArg {
    // message oneof groups
    pub field_type: ::std::option::Option<TimestampArg_oneof_type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimestampArg {
    fn default() -> &'a TimestampArg {
        <TimestampArg as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum TimestampArg_oneof_type {
    offset(u64),
    attr_name(::std::string::String),
}

impl TimestampArg {
    pub fn new() -> TimestampArg {
        ::std::default::Default::default()
    }

    // uint64 offset = 1;

    pub fn get_offset(&self) -> u64 {
        match self.field_type {
            ::std::option::Option::Some(TimestampArg_oneof_type::offset(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_offset(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TimestampArg_oneof_type::offset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.field_type = ::std::option::Option::Some(TimestampArg_oneof_type::offset(v))
    }

    // string attr_name = 2;

    pub fn get_attr_name(&self) -> &str {
        match self.field_type {
            ::std::option::Option::Some(TimestampArg_oneof_type::attr_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_attr_name(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_attr_name(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TimestampArg_oneof_type::attr_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attr_name(&mut self, v: ::std::string::String) {
        self.field_type = ::std::option::Option::Some(TimestampArg_oneof_type::attr_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attr_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TimestampArg_oneof_type::attr_name(_)) = self.field_type
        {
        } else {
            self.field_type = ::std::option::Option::Some(TimestampArg_oneof_type::attr_name(
                ::std::string::String::new(),
            ));
        }
        match self.field_type {
            ::std::option::Option::Some(TimestampArg_oneof_type::attr_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attr_name(&mut self) -> ::std::string::String {
        if self.has_attr_name() {
            match self.field_type.take() {
                ::std::option::Option::Some(TimestampArg_oneof_type::attr_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for TimestampArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.field_type = ::std::option::Option::Some(TimestampArg_oneof_type::offset(
                        is.read_uint64()?,
                    ));
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.field_type = ::std::option::Option::Some(
                        TimestampArg_oneof_type::attr_name(is.read_string()?),
                    );
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &TimestampArg_oneof_type::offset(v) => {
                    my_size +=
                        ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                }
                &TimestampArg_oneof_type::attr_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &TimestampArg_oneof_type::offset(v) => {
                    os.write_uint64(1, v)?;
                }
                &TimestampArg_oneof_type::attr_name(ref v) => {
                    os.write_string(2, v)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimestampArg {
        TimestampArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                    "offset",
                    TimestampArg::has_offset,
                    TimestampArg::get_offset,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "attr_name",
                    TimestampArg::has_attr_name,
                    TimestampArg::get_attr_name,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimestampArg>(
                "TimestampArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static TimestampArg {
        static instance: ::protobuf::rt::LazyV2<TimestampArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimestampArg::new)
    }
}

impl ::protobuf::Clear for TimestampArg {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimestampArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateArg {
    // message fields
    pub fields: ::protobuf::RepeatedField<UpdateArg_Field>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateArg {
    fn default() -> &'a UpdateArg {
        <UpdateArg as ::protobuf::Message>::default_instance()
    }
}

impl UpdateArg {
    pub fn new() -> UpdateArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.UpdateArg.Field fields = 1;

    pub fn get_fields(&self) -> &[UpdateArg_Field] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<UpdateArg_Field>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<UpdateArg_Field> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<UpdateArg_Field> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateArg {
        UpdateArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<UpdateArg_Field>,
                >(
                    "fields",
                    |m: &UpdateArg| &m.fields,
                    |m: &mut UpdateArg| &mut m.fields,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateArg>(
                "UpdateArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UpdateArg {
        static instance: ::protobuf::rt::LazyV2<UpdateArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateArg::new)
    }
}

impl ::protobuf::Clear for UpdateArg {
    fn clear(&mut self) {
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateArg_Field {
    // message fields
    pub offset: i64,
    pub size: u64,
    pub value: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateArg_Field {
    fn default() -> &'a UpdateArg_Field {
        <UpdateArg_Field as ::protobuf::Message>::default_instance()
    }
}

impl UpdateArg_Field {
    pub fn new() -> UpdateArg_Field {
        ::std::default::Default::default()
    }

    // int64 offset = 1;

    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // uint64 size = 2;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // uint64 value = 3;

    pub fn get_value(&self) -> u64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }
}

impl ::protobuf::Message for UpdateArg_Field {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.offset != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.offset != 0 {
            os.write_int64(1, self.offset)?;
        }
        if self.size != 0 {
            os.write_uint64(2, self.size)?;
        }
        if self.value != 0 {
            os.write_uint64(3, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateArg_Field {
        UpdateArg_Field::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "offset",
                |m: &UpdateArg_Field| &m.offset,
                |m: &mut UpdateArg_Field| &mut m.offset,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &UpdateArg_Field| &m.size,
                |m: &mut UpdateArg_Field| &mut m.size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "value",
                |m: &UpdateArg_Field| &m.value,
                |m: &mut UpdateArg_Field| &mut m.value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateArg_Field>(
                "UpdateArg.Field",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UpdateArg_Field {
        static instance: ::protobuf::rt::LazyV2<UpdateArg_Field> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateArg_Field::new)
    }
}

impl ::protobuf::Clear for UpdateArg_Field {
    fn clear(&mut self) {
        self.offset = 0;
        self.size = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateArg_Field {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateArg_Field {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UrlFilterArg {
    // message fields
    pub blacklist: ::protobuf::RepeatedField<UrlFilterArg_Url>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UrlFilterArg {
    fn default() -> &'a UrlFilterArg {
        <UrlFilterArg as ::protobuf::Message>::default_instance()
    }
}

impl UrlFilterArg {
    pub fn new() -> UrlFilterArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.UrlFilterArg.Url blacklist = 1;

    pub fn get_blacklist(&self) -> &[UrlFilterArg_Url] {
        &self.blacklist
    }
    pub fn clear_blacklist(&mut self) {
        self.blacklist.clear();
    }

    // Param is passed by value, moved
    pub fn set_blacklist(&mut self, v: ::protobuf::RepeatedField<UrlFilterArg_Url>) {
        self.blacklist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blacklist(&mut self) -> &mut ::protobuf::RepeatedField<UrlFilterArg_Url> {
        &mut self.blacklist
    }

    // Take field
    pub fn take_blacklist(&mut self) -> ::protobuf::RepeatedField<UrlFilterArg_Url> {
        ::std::mem::replace(&mut self.blacklist, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UrlFilterArg {
    fn is_initialized(&self) -> bool {
        for v in &self.blacklist {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blacklist)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blacklist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blacklist {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UrlFilterArg {
        UrlFilterArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<UrlFilterArg_Url>,
                >(
                    "blacklist",
                    |m: &UrlFilterArg| &m.blacklist,
                    |m: &mut UrlFilterArg| &mut m.blacklist,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UrlFilterArg>(
                "UrlFilterArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UrlFilterArg {
        static instance: ::protobuf::rt::LazyV2<UrlFilterArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UrlFilterArg::new)
    }
}

impl ::protobuf::Clear for UrlFilterArg {
    fn clear(&mut self) {
        self.blacklist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UrlFilterArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UrlFilterArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UrlFilterArg_Url {
    // message fields
    pub host: ::std::string::String,
    pub path: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UrlFilterArg_Url {
    fn default() -> &'a UrlFilterArg_Url {
        <UrlFilterArg_Url as ::protobuf::Message>::default_instance()
    }
}

impl UrlFilterArg_Url {
    pub fn new() -> UrlFilterArg_Url {
        ::std::default::Default::default()
    }

    // string host = 1;

    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // string path = 2;

    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UrlFilterArg_Url {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.host,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.path,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UrlFilterArg_Url {
        UrlFilterArg_Url::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "host",
                |m: &UrlFilterArg_Url| &m.host,
                |m: &mut UrlFilterArg_Url| &mut m.host,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "path",
                |m: &UrlFilterArg_Url| &m.path,
                |m: &mut UrlFilterArg_Url| &mut m.path,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UrlFilterArg_Url>(
                "UrlFilterArg.Url",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UrlFilterArg_Url {
        static instance: ::protobuf::rt::LazyV2<UrlFilterArg_Url> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UrlFilterArg_Url::new)
    }
}

impl ::protobuf::Clear for UrlFilterArg_Url {
    fn clear(&mut self) {
        self.host.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UrlFilterArg_Url {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UrlFilterArg_Url {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UrlFilterConfig {
    // message fields
    pub blacklist: ::protobuf::RepeatedField<UrlFilterArg_Url>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UrlFilterConfig {
    fn default() -> &'a UrlFilterConfig {
        <UrlFilterConfig as ::protobuf::Message>::default_instance()
    }
}

impl UrlFilterConfig {
    pub fn new() -> UrlFilterConfig {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.UrlFilterArg.Url blacklist = 1;

    pub fn get_blacklist(&self) -> &[UrlFilterArg_Url] {
        &self.blacklist
    }
    pub fn clear_blacklist(&mut self) {
        self.blacklist.clear();
    }

    // Param is passed by value, moved
    pub fn set_blacklist(&mut self, v: ::protobuf::RepeatedField<UrlFilterArg_Url>) {
        self.blacklist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blacklist(&mut self) -> &mut ::protobuf::RepeatedField<UrlFilterArg_Url> {
        &mut self.blacklist
    }

    // Take field
    pub fn take_blacklist(&mut self) -> ::protobuf::RepeatedField<UrlFilterArg_Url> {
        ::std::mem::replace(&mut self.blacklist, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UrlFilterConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.blacklist {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blacklist)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blacklist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blacklist {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UrlFilterConfig {
        UrlFilterConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<UrlFilterArg_Url>,
                >(
                    "blacklist",
                    |m: &UrlFilterConfig| &m.blacklist,
                    |m: &mut UrlFilterConfig| &mut m.blacklist,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UrlFilterConfig>(
                "UrlFilterConfig",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UrlFilterConfig {
        static instance: ::protobuf::rt::LazyV2<UrlFilterConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UrlFilterConfig::new)
    }
}

impl ::protobuf::Clear for UrlFilterConfig {
    fn clear(&mut self) {
        self.blacklist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UrlFilterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UrlFilterConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VLANPopArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VLANPopArg {
    fn default() -> &'a VLANPopArg {
        <VLANPopArg as ::protobuf::Message>::default_instance()
    }
}

impl VLANPopArg {
    pub fn new() -> VLANPopArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VLANPopArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VLANPopArg {
        VLANPopArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VLANPopArg>(
                "VLANPopArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static VLANPopArg {
        static instance: ::protobuf::rt::LazyV2<VLANPopArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VLANPopArg::new)
    }
}

impl ::protobuf::Clear for VLANPopArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VLANPopArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VLANPopArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VLANPushArg {
    // message fields
    pub tci: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VLANPushArg {
    fn default() -> &'a VLANPushArg {
        <VLANPushArg as ::protobuf::Message>::default_instance()
    }
}

impl VLANPushArg {
    pub fn new() -> VLANPushArg {
        ::std::default::Default::default()
    }

    // uint64 tci = 1;

    pub fn get_tci(&self) -> u64 {
        self.tci
    }
    pub fn clear_tci(&mut self) {
        self.tci = 0;
    }

    // Param is passed by value, moved
    pub fn set_tci(&mut self, v: u64) {
        self.tci = v;
    }
}

impl ::protobuf::Message for VLANPushArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.tci = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tci != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.tci, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.tci != 0 {
            os.write_uint64(1, self.tci)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VLANPushArg {
        VLANPushArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "tci",
                |m: &VLANPushArg| &m.tci,
                |m: &mut VLANPushArg| &mut m.tci,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VLANPushArg>(
                "VLANPushArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static VLANPushArg {
        static instance: ::protobuf::rt::LazyV2<VLANPushArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VLANPushArg::new)
    }
}

impl ::protobuf::Clear for VLANPushArg {
    fn clear(&mut self) {
        self.tci = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VLANPushArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VLANPushArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VLANSplitArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VLANSplitArg {
    fn default() -> &'a VLANSplitArg {
        <VLANSplitArg as ::protobuf::Message>::default_instance()
    }
}

impl VLANSplitArg {
    pub fn new() -> VLANSplitArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VLANSplitArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VLANSplitArg {
        VLANSplitArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VLANSplitArg>(
                "VLANSplitArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static VLANSplitArg {
        static instance: ::protobuf::rt::LazyV2<VLANSplitArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VLANSplitArg::new)
    }
}

impl ::protobuf::Clear for VLANSplitArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VLANSplitArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VLANSplitArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VXLANDecapArg {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VXLANDecapArg {
    fn default() -> &'a VXLANDecapArg {
        <VXLANDecapArg as ::protobuf::Message>::default_instance()
    }
}

impl VXLANDecapArg {
    pub fn new() -> VXLANDecapArg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VXLANDecapArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VXLANDecapArg {
        VXLANDecapArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VXLANDecapArg>(
                "VXLANDecapArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static VXLANDecapArg {
        static instance: ::protobuf::rt::LazyV2<VXLANDecapArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VXLANDecapArg::new)
    }
}

impl ::protobuf::Clear for VXLANDecapArg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VXLANDecapArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VXLANDecapArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VXLANEncapArg {
    // message fields
    pub dstport: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VXLANEncapArg {
    fn default() -> &'a VXLANEncapArg {
        <VXLANEncapArg as ::protobuf::Message>::default_instance()
    }
}

impl VXLANEncapArg {
    pub fn new() -> VXLANEncapArg {
        ::std::default::Default::default()
    }

    // uint64 dstport = 1;

    pub fn get_dstport(&self) -> u64 {
        self.dstport
    }
    pub fn clear_dstport(&mut self) {
        self.dstport = 0;
    }

    // Param is passed by value, moved
    pub fn set_dstport(&mut self, v: u64) {
        self.dstport = v;
    }
}

impl ::protobuf::Message for VXLANEncapArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.dstport = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dstport != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.dstport,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.dstport != 0 {
            os.write_uint64(1, self.dstport)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VXLANEncapArg {
        VXLANEncapArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "dstport",
                |m: &VXLANEncapArg| &m.dstport,
                |m: &mut VXLANEncapArg| &mut m.dstport,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VXLANEncapArg>(
                "VXLANEncapArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static VXLANEncapArg {
        static instance: ::protobuf::rt::LazyV2<VXLANEncapArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VXLANEncapArg::new)
    }
}

impl ::protobuf::Clear for VXLANEncapArg {
    fn clear(&mut self) {
        self.dstport = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VXLANEncapArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VXLANEncapArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WildcardMatchArg {
    // message fields
    pub fields: ::protobuf::RepeatedField<super::util_msg::Field>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WildcardMatchArg {
    fn default() -> &'a WildcardMatchArg {
        <WildcardMatchArg as ::protobuf::Message>::default_instance()
    }
}

impl WildcardMatchArg {
    pub fn new() -> WildcardMatchArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.Field fields = 1;

    pub fn get_fields(&self) -> &[super::util_msg::Field] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<super::util_msg::Field>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<super::util_msg::Field> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<super::util_msg::Field> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WildcardMatchArg {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WildcardMatchArg {
        WildcardMatchArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::util_msg::Field>,
                >(
                    "fields",
                    |m: &WildcardMatchArg| &m.fields,
                    |m: &mut WildcardMatchArg| &mut m.fields,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WildcardMatchArg>(
                "WildcardMatchArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static WildcardMatchArg {
        static instance: ::protobuf::rt::LazyV2<WildcardMatchArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WildcardMatchArg::new)
    }
}

impl ::protobuf::Clear for WildcardMatchArg {
    fn clear(&mut self) {
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WildcardMatchArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WildcardMatchArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WildcardMatchConfig {
    // message fields
    pub default_gate: u64,
    pub rules: ::protobuf::RepeatedField<WildcardMatchCommandAddArg>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WildcardMatchConfig {
    fn default() -> &'a WildcardMatchConfig {
        <WildcardMatchConfig as ::protobuf::Message>::default_instance()
    }
}

impl WildcardMatchConfig {
    pub fn new() -> WildcardMatchConfig {
        ::std::default::Default::default()
    }

    // uint64 default_gate = 1;

    pub fn get_default_gate(&self) -> u64 {
        self.default_gate
    }
    pub fn clear_default_gate(&mut self) {
        self.default_gate = 0;
    }

    // Param is passed by value, moved
    pub fn set_default_gate(&mut self, v: u64) {
        self.default_gate = v;
    }

    // repeated .bess.pb.WildcardMatchCommandAddArg rules = 2;

    pub fn get_rules(&self) -> &[WildcardMatchCommandAddArg] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<WildcardMatchCommandAddArg>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<WildcardMatchCommandAddArg> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<WildcardMatchCommandAddArg> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WildcardMatchConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_gate = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.default_gate != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.default_gate,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.default_gate != 0 {
            os.write_uint64(1, self.default_gate)?;
        }
        for v in &self.rules {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WildcardMatchConfig {
        WildcardMatchConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "default_gate",
                |m: &WildcardMatchConfig| &m.default_gate,
                |m: &mut WildcardMatchConfig| &mut m.default_gate,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<WildcardMatchCommandAddArg>,
                >(
                    "rules",
                    |m: &WildcardMatchConfig| &m.rules,
                    |m: &mut WildcardMatchConfig| &mut m.rules,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WildcardMatchConfig>(
                "WildcardMatchConfig",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static WildcardMatchConfig {
        static instance: ::protobuf::rt::LazyV2<WildcardMatchConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WildcardMatchConfig::new)
    }
}

impl ::protobuf::Clear for WildcardMatchConfig {
    fn clear(&mut self) {
        self.default_gate = 0;
        self.rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WildcardMatchConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WildcardMatchConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ArpResponderArg {
    // message fields
    pub ip: ::std::string::String,
    pub mac_addr: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArpResponderArg {
    fn default() -> &'a ArpResponderArg {
        <ArpResponderArg as ::protobuf::Message>::default_instance()
    }
}

impl ArpResponderArg {
    pub fn new() -> ArpResponderArg {
        ::std::default::Default::default()
    }

    // string ip = 1;

    pub fn get_ip(&self) -> &str {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }

    // string mac_addr = 2;

    pub fn get_mac_addr(&self) -> &str {
        &self.mac_addr
    }
    pub fn clear_mac_addr(&mut self) {
        self.mac_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_addr(&mut self, v: ::std::string::String) {
        self.mac_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_addr(&mut self) -> &mut ::std::string::String {
        &mut self.mac_addr
    }

    // Take field
    pub fn take_mac_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ArpResponderArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mac_addr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ip);
        }
        if !self.mac_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mac_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.ip.is_empty() {
            os.write_string(1, &self.ip)?;
        }
        if !self.mac_addr.is_empty() {
            os.write_string(2, &self.mac_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArpResponderArg {
        ArpResponderArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "ip",
                |m: &ArpResponderArg| &m.ip,
                |m: &mut ArpResponderArg| &mut m.ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mac_addr",
                |m: &ArpResponderArg| &m.mac_addr,
                |m: &mut ArpResponderArg| &mut m.mac_addr,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArpResponderArg>(
                "ArpResponderArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ArpResponderArg {
        static instance: ::protobuf::rt::LazyV2<ArpResponderArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArpResponderArg::new)
    }
}

impl ::protobuf::Clear for ArpResponderArg {
    fn clear(&mut self) {
        self.ip.clear();
        self.mac_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArpResponderArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArpResponderArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MplsPopArg {
    // message fields
    pub remove_eth_header: bool,
    pub next_eth_type: u32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MplsPopArg {
    fn default() -> &'a MplsPopArg {
        <MplsPopArg as ::protobuf::Message>::default_instance()
    }
}

impl MplsPopArg {
    pub fn new() -> MplsPopArg {
        ::std::default::Default::default()
    }

    // bool remove_eth_header = 1;

    pub fn get_remove_eth_header(&self) -> bool {
        self.remove_eth_header
    }
    pub fn clear_remove_eth_header(&mut self) {
        self.remove_eth_header = false;
    }

    // Param is passed by value, moved
    pub fn set_remove_eth_header(&mut self, v: bool) {
        self.remove_eth_header = v;
    }

    // uint32 next_eth_type = 2;

    pub fn get_next_eth_type(&self) -> u32 {
        self.next_eth_type
    }
    pub fn clear_next_eth_type(&mut self) {
        self.next_eth_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_eth_type(&mut self, v: u32) {
        self.next_eth_type = v;
    }
}

impl ::protobuf::Message for MplsPopArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.remove_eth_header = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.next_eth_type = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.remove_eth_header != false {
            my_size += 2;
        }
        if self.next_eth_type != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.next_eth_type,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.remove_eth_header != false {
            os.write_bool(1, self.remove_eth_header)?;
        }
        if self.next_eth_type != 0 {
            os.write_uint32(2, self.next_eth_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MplsPopArg {
        MplsPopArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "remove_eth_header",
                |m: &MplsPopArg| &m.remove_eth_header,
                |m: &mut MplsPopArg| &mut m.remove_eth_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "next_eth_type",
                |m: &MplsPopArg| &m.next_eth_type,
                |m: &mut MplsPopArg| &mut m.next_eth_type,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MplsPopArg>(
                "MplsPopArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MplsPopArg {
        static instance: ::protobuf::rt::LazyV2<MplsPopArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MplsPopArg::new)
    }
}

impl ::protobuf::Clear for MplsPopArg {
    fn clear(&mut self) {
        self.remove_eth_header = false;
        self.next_eth_type = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MplsPopArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MplsPopArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WorkerSplitArg {
    // message fields
    pub worker_gates: ::std::collections::HashMap<u32, u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorkerSplitArg {
    fn default() -> &'a WorkerSplitArg {
        <WorkerSplitArg as ::protobuf::Message>::default_instance()
    }
}

impl WorkerSplitArg {
    pub fn new() -> WorkerSplitArg {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.WorkerSplitArg.WorkerGatesEntry worker_gates = 1;

    pub fn get_worker_gates(&self) -> &::std::collections::HashMap<u32, u32> {
        &self.worker_gates
    }
    pub fn clear_worker_gates(&mut self) {
        self.worker_gates.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_gates(&mut self, v: ::std::collections::HashMap<u32, u32>) {
        self.worker_gates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_worker_gates(&mut self) -> &mut ::std::collections::HashMap<u32, u32> {
        &mut self.worker_gates
    }

    // Take field
    pub fn take_worker_gates(&mut self) -> ::std::collections::HashMap<u32, u32> {
        ::std::mem::replace(&mut self.worker_gates, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for WorkerSplitArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeUint32,
                        ::protobuf::types::ProtobufTypeUint32,
                    >(wire_type, is, &mut self.worker_gates)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeUint32,
            ::protobuf::types::ProtobufTypeUint32,
        >(1, &self.worker_gates);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeUint32,
            ::protobuf::types::ProtobufTypeUint32,
        >(1, &self.worker_gates, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerSplitArg {
        WorkerSplitArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "worker_gates",
                |m: &WorkerSplitArg| &m.worker_gates,
                |m: &mut WorkerSplitArg| &mut m.worker_gates,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorkerSplitArg>(
                "WorkerSplitArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static WorkerSplitArg {
        static instance: ::protobuf::rt::LazyV2<WorkerSplitArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorkerSplitArg::new)
    }
}

impl ::protobuf::Clear for WorkerSplitArg {
    fn clear(&mut self) {
        self.worker_gates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerSplitArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerSplitArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10module_msg.proto\x12\x07bess.pb\x1a\x0eutil_msg.proto\"\n\n\x08Emp\
    tyArg\"\x14\n\x12BPFCommandClearArg\"Y\n\x17ExactMatchCommandAddArg\x12\
    \x12\n\x04gate\x18\x01\x20\x01(\x04R\x04gate\x12*\n\x06fields\x18\x02\
    \x20\x03(\x0b2\x12.bess.pb.FieldDataR\x06fields\"H\n\x1aExactMatchComman\
    dDeleteArg\x12*\n\x06fields\x18\x02\x20\x03(\x0b2\x12.bess.pb.FieldDataR\
    \x06fields\"\x1b\n\x19ExactMatchCommandClearArg\"8\n\"ExactMatchCommandS\
    etDefaultGateArg\x12\x12\n\x04gate\x18\x01\x20\x01(\x04R\x04gate\"1\n\
    \x19FlowGenCommandSetBurstArg\x12\x14\n\x05burst\x18\x01\x20\x01(\x04R\
    \x05burst\"U\n\x17HashLBCommandSetModeArg\x12\x12\n\x04mode\x18\x01\x20\
    \x01(\tR\x04mode\x12&\n\x06fields\x18\x02\x20\x03(\x0b2\x0e.bess.pb.Fiel\
    dR\x06fields\"0\n\x18HashLBCommandSetGatesArg\x12\x14\n\x05gates\x18\x01\
    \x20\x03(\x03R\x05gates\"b\n\x15IPLookupCommandAddArg\x12\x16\n\x06prefi\
    x\x18\x01\x20\x01(\tR\x06prefix\x12\x1d\n\nprefix_len\x18\x02\x20\x01(\
    \x04R\tprefixLen\x12\x12\n\x04gate\x18\x03\x20\x01(\x04R\x04gate\"Q\n\
    \x18IPLookupCommandDeleteArg\x12\x16\n\x06prefix\x18\x01\x20\x01(\tR\x06\
    prefix\x12\x1d\n\nprefix_len\x18\x02\x20\x01(\x04R\tprefixLen\"\x19\n\
    \x17IPLookupCommandClearArg\"\x8a\x01\n\x16L2ForwardCommandAddArg\x12?\n\
    \x07entries\x18\x01\x20\x03(\x0b2%.bess.pb.L2ForwardCommandAddArg.EntryR\
    \x07entries\x1a/\n\x05Entry\x12\x12\n\x04addr\x18\x01\x20\x01(\tR\x04add\
    r\x12\x12\n\x04gate\x18\x02\x20\x01(\x03R\x04gate\"1\n\x19L2ForwardComma\
    ndDeleteArg\x12\x14\n\x05addrs\x18\x01\x20\x03(\tR\x05addrs\"7\n!L2Forwa\
    rdCommandSetDefaultGateArg\x12\x12\n\x04gate\x18\x01\x20\x01(\x03R\x04ga\
    te\"1\n\x19L2ForwardCommandLookupArg\x12\x14\n\x05addrs\x18\x01\x20\x03(\
    \tR\x05addrs\"6\n\x1eL2ForwardCommandLookupResponse\x12\x14\n\x05gates\
    \x18\x01\x20\x03(\x04R\x05gates\"f\n\x1bL2ForwardCommandPopulateArg\x12\
    \x12\n\x04base\x18\x01\x20\x01(\tR\x04base\x12\x14\n\x05count\x18\x02\
    \x20\x01(\x03R\x05count\x12\x1d\n\ngate_count\x18\x03\x20\x01(\x03R\tgat\
    eCount\"\x93\x01\n\x1bMeasureCommandGetSummaryArg\x12\x14\n\x05clear\x18\
    \x01\x20\x01(\x08R\x05clear\x12/\n\x13latency_percentiles\x18\x02\x20\
    \x03(\x01R\x12latencyPercentiles\x12-\n\x12jitter_percentiles\x18\x03\
    \x20\x03(\x01R\x11jitterPercentiles\"\x86\x04\n\x20MeasureCommandGetSumm\
    aryResponse\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x01R\ttimestamp\x12\
    \x18\n\x07packets\x18\x02\x20\x01(\x04R\x07packets\x12\x12\n\x04bits\x18\
    \x03\x20\x01(\x04R\x04bits\x12M\n\x07latency\x18\x04\x20\x01(\x0b23.bess\
    .pb.MeasureCommandGetSummaryResponse.HistogramR\x07latency\x12K\n\x06jit\
    ter\x18\x05\x20\x01(\x0b23.bess.pb.MeasureCommandGetSummaryResponse.Hist\
    ogramR\x06jitter\x1a\xf9\x01\n\tHistogram\x12\x14\n\x05count\x18\x01\x20\
    \x01(\x04R\x05count\x12\x1f\n\x0babove_range\x18\x02\x20\x01(\x04R\nabov\
    eRange\x12#\n\rresolution_ns\x18\x08\x20\x01(\x04R\x0cresolutionNs\x12\
    \x15\n\x06min_ns\x18\x03\x20\x01(\x04R\x05minNs\x12\x15\n\x06avg_ns\x18\
    \x04\x20\x01(\x04R\x05avgNs\x12\x15\n\x06max_ns\x18\x05\x20\x01(\x04R\
    \x05maxNs\x12\x19\n\x08total_ns\x18\x06\x20\x01(\x04R\x07totalNs\x120\n\
    \x14percentile_values_ns\x18\x07\x20\x03(\x04R\x12percentileValuesNs\"n\
    \n\x06DRRArg\x12\x1b\n\tnum_flows\x18\x01\x20\x01(\rR\x08numFlows\x12\
    \x18\n\x07quantum\x18\x02\x20\x01(\x04R\x07quantum\x12-\n\x13max_flow_qu\
    eue_size\x18\x03\x20\x01(\rR\x10maxFlowQueueSize\")\n\rDRRQuantumArg\x12\
    \x18\n\x07quantum\x18\x01\x20\x01(\rR\x07quantum\">\n\x16DRRMaxFlowQueue\
    SizeArg\x12$\n\x0emax_queue_size\x18\x01\x20\x01(\rR\x0cmaxQueueSize\"1\
    \n\x19PortIncCommandSetBurstArg\x12\x14\n\x05burst\x18\x01\x20\x01(\x04R\
    \x05burst\"2\n\x1aQueueIncCommandSetBurstArg\x12\x14\n\x05burst\x18\x01\
    \x20\x01(\x04R\x05burst\"/\n\x17QueueCommandSetBurstArg\x12\x14\n\x05bur\
    st\x18\x01\x20\x01(\x04R\x05burst\",\n\x16QueueCommandSetSizeArg\x12\x12\
    \n\x04size\x18\x01\x20\x01(\x04R\x04size\"\x1a\n\x18QueueCommandGetStatu\
    sArg\"\x9b\x01\n\x1dQueueCommandGetStatusResponse\x12\x14\n\x05count\x18\
    \x01\x20\x01(\x04R\x05count\x12\x12\n\x04size\x18\x02\x20\x01(\x04R\x04s\
    ize\x12\x1a\n\x08enqueued\x18\x03\x20\x01(\x04R\x08enqueued\x12\x1a\n\
    \x08dequeued\x18\x04\x20\x01(\x04R\x08dequeued\x12\x18\n\x07dropped\x18\
    \x05\x20\x01(\x04R\x07dropped\"\x1d\n\x1bRandomUpdateCommandClearArg\"\
    \x18\n\x16RewriteCommandClearArg\"\x17\n\x15UpdateCommandClearArg\"\xa2\
    \x01\n\x1aWildcardMatchCommandAddArg\x12\x12\n\x04gate\x18\x01\x20\x01(\
    \x04R\x04gate\x12\x1a\n\x08priority\x18\x02\x20\x01(\x03R\x08priority\
    \x12*\n\x06values\x18\x03\x20\x03(\x0b2\x12.bess.pb.FieldDataR\x06values\
    \x12(\n\x05masks\x18\x04\x20\x03(\x0b2\x12.bess.pb.FieldDataR\x05masks\"\
    u\n\x1dWildcardMatchCommandDeleteArg\x12*\n\x06values\x18\x01\x20\x03(\
    \x0b2\x12.bess.pb.FieldDataR\x06values\x12(\n\x05masks\x18\x02\x20\x03(\
    \x0b2\x12.bess.pb.FieldDataR\x05masks\"\x1e\n\x1cWildcardMatchCommandCle\
    arArg\";\n%WildcardMatchCommandSetDefaultGateArg\x12\x12\n\x04gate\x18\
    \x01\x20\x01(\x04R\x04gate\"\xd7\x01\n\x06ACLArg\x12*\n\x05rules\x18\x01\
    \x20\x03(\x0b2\x14.bess.pb.ACLArg.RuleR\x05rules\x1a\xa0\x01\n\x04Rule\
    \x12\x15\n\x06src_ip\x18\x01\x20\x01(\tR\x05srcIp\x12\x15\n\x06dst_ip\
    \x18\x02\x20\x01(\tR\x05dstIp\x12\x19\n\x08src_port\x18\x03\x20\x01(\rR\
    \x07srcPort\x12\x19\n\x08dst_port\x18\x04\x20\x01(\rR\x07dstPort\x12\x20\
    \n\x0bestablished\x18\x05\x20\x01(\x08R\x0bestablished\x12\x12\n\x04drop\
    \x18\x06\x20\x01(\x08R\x04drop\"\x8c\x01\n\x06BPFArg\x120\n\x07filters\
    \x18\x01\x20\x03(\x0b2\x16.bess.pb.BPFArg.FilterR\x07filters\x1aP\n\x06F\
    ilter\x12\x1a\n\x08priority\x18\x01\x20\x01(\x03R\x08priority\x12\x16\n\
    \x06filter\x18\x02\x20\x01(\tR\x06filter\x12\x12\n\x04gate\x18\x03\x20\
    \x01(\x03R\x04gate\"\x0b\n\tBufferArg\"\x89\x01\n\tBypassArg\x12(\n\x10c\
    ycles_per_batch\x18\x01\x20\x01(\rR\x0ecyclesPerBatch\x12*\n\x11cycles_p\
    er_packet\x18\x02\x20\x01(\rR\x0fcyclesPerPacket\x12&\n\x0fcycles_per_by\
    te\x18\x03\x20\x01(\rR\rcyclesPerByte\"%\n\x07DumpArg\x12\x1a\n\x08inter\
    val\x18\x01\x20\x01(\x01R\x08interval\"\x0f\n\rEtherEncapArg\"a\n\rExact\
    MatchArg\x12&\n\x06fields\x18\x01\x20\x03(\x0b2\x0e.bess.pb.FieldR\x06fi\
    elds\x12(\n\x05masks\x18\x02\x20\x03(\x0b2\x12.bess.pb.FieldDataR\x05mas\
    ks\"m\n\x10ExactMatchConfig\x12!\n\x0cdefault_gate\x18\x01\x20\x01(\x04R\
    \x0bdefaultGate\x126\n\x05rules\x18\x02\x20\x03(\x0b2\x20.bess.pb.ExactM\
    atchCommandAddArgR\x05rules\"\xe5\x02\n\nFlowGenArg\x12\x1a\n\x08templat\
    e\x18\x01\x20\x01(\x0cR\x08template\x12\x10\n\x03pps\x18\x02\x20\x01(\
    \x01R\x03pps\x12\x1b\n\tflow_rate\x18\x03\x20\x01(\x01R\x08flowRate\x12#\
    \n\rflow_duration\x18\x04\x20\x01(\x01R\x0cflowDuration\x12\x18\n\x07arr\
    ival\x18\x05\x20\x01(\tR\x07arrival\x12\x1a\n\x08duration\x18\x06\x20\
    \x01(\tR\x08duration\x12!\n\x0cquick_rampup\x18\x07\x20\x01(\x08R\x0bqui\
    ckRampup\x12\x20\n\x0cip_src_range\x18\x08\x20\x01(\rR\nipSrcRange\x12\
    \x20\n\x0cip_dst_range\x18\t\x20\x01(\rR\nipDstRange\x12$\n\x0eport_src_\
    range\x18\n\x20\x01(\rR\x0cportSrcRange\x12$\n\x0eport_dst_range\x18\x0b\
    \x20\x01(\rR\x0cportDstRange\"'\n\x0fGenericDecapArg\x12\x14\n\x05bytes\
    \x18\x01\x20\x01(\x04R\x05bytes\"\xc9\x01\n\x0fGenericEncapArg\x12;\n\
    \x06fields\x18\x01\x20\x03(\x0b2#.bess.pb.GenericEncapArg.EncapFieldR\
    \x06fields\x1ay\n\nEncapField\x12\x12\n\x04size\x18\x01\x20\x01(\x04R\
    \x04size\x12\x1e\n\tattribute\x18\x02\x20\x01(\tH\0R\tattribute\x12*\n\
    \x05value\x18\x03\x20\x01(\x0b2\x12.bess.pb.FieldDataH\0R\x05valueB\x0b\
    \n\tinsertion\"]\n\tHashLBArg\x12\x14\n\x05gates\x18\x01\x20\x03(\x03R\
    \x05gates\x12\x12\n\x04mode\x18\x02\x20\x01(\tR\x04mode\x12&\n\x06fields\
    \x18\x03\x20\x03(\x0b2\x0e.bess.pb.FieldR\x06fields\"\x0c\n\nIPEncapArg\
    \"G\n\x0bIPLookupArg\x12\x1b\n\tmax_rules\x18\x01\x20\x01(\rR\x08maxRule\
    s\x12\x1b\n\tmax_tbl8s\x18\x02\x20\x01(\rR\x08maxTbl8s\":\n\x0cL2Forward\
    Arg\x12\x12\n\x04size\x18\x01\x20\x01(\x03R\x04size\x12\x16\n\x06bucket\
    \x18\x02\x20\x01(\x03R\x06bucket\"\x0c\n\nMACSwapArg\"\xd5\x01\n\nMeasur\
    eArg\x12\x18\n\x06offset\x18\x02\x20\x01(\x04H\0R\x06offset\x12\x1d\n\ta\
    ttr_name\x18\x06\x20\x01(\tH\0R\x08attrName\x12,\n\x12jitter_sample_prob\
    \x18\x03\x20\x01(\x01R\x10jitterSampleProb\x12$\n\x0elatency_ns_max\x18\
    \x04\x20\x01(\x04R\x0clatencyNsMax\x122\n\x15latency_ns_resolution\x18\
    \x05\x20\x01(\rR\x13latencyNsResolutionB\x06\n\x04type\"\n\n\x08MergeArg\
    \"\xf0\x02\n\x0fMetadataTestArg\x126\n\x04read\x18\x01\x20\x03(\x0b2\".b\
    ess.pb.MetadataTestArg.ReadEntryR\x04read\x129\n\x05write\x18\x02\x20\
    \x03(\x0b2#.bess.pb.MetadataTestArg.WriteEntryR\x05write\x12<\n\x06updat\
    e\x18\x03\x20\x03(\x0b2$.bess.pb.MetadataTestArg.UpdateEntryR\x06update\
    \x1a7\n\tReadEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x03R\x05value:\x028\x01\x1a8\n\nWriteEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x03R\x05value:\x028\x01\x1a9\n\x0bUpdateEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05\
    value:\x028\x01\"\x83\x02\n\x06NATArg\x12<\n\text_addrs\x18\x01\x20\x03(\
    \x0b2\x1f.bess.pb.NATArg.ExternalAddressR\x08extAddrs\x1aQ\n\tPortRange\
    \x12\x14\n\x05begin\x18\x01\x20\x01(\rR\x05begin\x12\x10\n\x03end\x18\
    \x02\x20\x01(\rR\x03end\x12\x1c\n\tsuspended\x18\x03\x20\x01(\x08R\tsusp\
    ended\x1ah\n\x0fExternalAddress\x12\x19\n\x08ext_addr\x18\x01\x20\x01(\t\
    R\x07extAddr\x12:\n\x0bport_ranges\x18\x02\x20\x03(\x0b2\x19.bess.pb.NAT\
    Arg.PortRangeR\nportRanges\"\x9b\x02\n\x0cStaticNATArg\x12<\n\x05pairs\
    \x18\x01\x20\x03(\x0b2&.bess.pb.StaticNATArg.AddressRangePairR\x05pairs\
    \x1a6\n\x0cAddressRange\x12\x14\n\x05start\x18\x01\x20\x01(\tR\x05start\
    \x12\x10\n\x03end\x18\x02\x20\x01(\tR\x03end\x1a\x94\x01\n\x10AddressRan\
    gePair\x12?\n\tint_range\x18\x01\x20\x01(\x0b2\".bess.pb.StaticNATArg.Ad\
    dressRangeR\x08intRange\x12?\n\text_range\x18\x02\x20\x01(\x0b2\".bess.p\
    b.StaticNATArg.AddressRangeR\x08extRange\"\t\n\x07NoOpArg\"<\n\nPortIncA\
    rg\x12\x12\n\x04port\x18\x01\x20\x01(\tR\x04port\x12\x1a\n\x08prefetch\
    \x18\x02\x20\x01(\x08R\x08prefetch\"\x20\n\nPortOutArg\x12\x12\n\x04port\
    \x18\x01\x20\x01(\tR\x04port\"O\n\x0bQueueIncArg\x12\x12\n\x04port\x18\
    \x01\x20\x01(\tR\x04port\x12\x10\n\x03qid\x18\x02\x20\x01(\x04R\x03qid\
    \x12\x1a\n\x08prefetch\x18\x03\x20\x01(\x08R\x08prefetch\"3\n\x0bQueueOu\
    tArg\x12\x12\n\x04port\x18\x01\x20\x01(\tR\x04port\x12\x10\n\x03qid\x18\
    \x02\x20\x01(\x04R\x03qid\"^\n\x08QueueArg\x12\x12\n\x04size\x18\x01\x20\
    \x01(\x04R\x04size\x12\x1a\n\x08prefetch\x18\x02\x20\x01(\x08R\x08prefet\
    ch\x12\"\n\x0cbackpressure\x18\x03\x20\x01(\x08R\x0cbackpressure\"C\n\
    \x0eRandomSplitArg\x12\x1b\n\tdrop_rate\x18\x01\x20\x01(\x01R\x08dropRat\
    e\x12\x14\n\x05gates\x18\x02\x20\x03(\x03R\x05gates\"?\n\x20RandomSplitC\
    ommandSetDroprateArg\x12\x1b\n\tdrop_rate\x18\x01\x20\x01(\x01R\x08dropR\
    ate\"5\n\x1dRandomSplitCommandSetGatesArg\x12\x14\n\x05gates\x18\x01\x20\
    \x03(\x03R\x05gates\"\xa2\x01\n\x0fRandomUpdateArg\x126\n\x06fields\x18\
    \x01\x20\x03(\x0b2\x1e.bess.pb.RandomUpdateArg.FieldR\x06fields\x1aW\n\
    \x05Field\x12\x16\n\x06offset\x18\x01\x20\x01(\x03R\x06offset\x12\x12\n\
    \x04size\x18\x02\x20\x01(\x04R\x04size\x12\x10\n\x03min\x18\x03\x20\x01(\
    \x04R\x03min\x12\x10\n\x03max\x18\x04\x20\x01(\x04R\x03max\"*\n\nRewrite\
    Arg\x12\x1c\n\ttemplates\x18\x01\x20\x03(\x0cR\ttemplates\"4\n\x1cRoundR\
    obinCommandSetGatesArg\x12\x14\n\x05gates\x18\x01\x20\x03(\x03R\x05gates\
    \"1\n\x1bRoundRobinCommandSetModeArg\x12\x12\n\x04mode\x18\x01\x20\x01(\
    \tR\x04mode\"9\n\rRoundRobinArg\x12\x14\n\x05gates\x18\x01\x20\x03(\x03R\
    \x05gates\x12\x12\n\x04mode\x18\x02\x20\x01(\tR\x04mode\"$\n\x0cReplicat\
    eArg\x12\x14\n\x05gates\x18\x01\x20\x03(\x03R\x05gates\"3\n\x1bReplicate\
    CommandSetGatesArg\x12\x14\n\x05gates\x18\x01\x20\x03(\x03R\x05gates\"\
    \x93\x02\n\x0eSetMetadataArg\x127\n\x05attrs\x18\x01\x20\x03(\x0b2!.bess\
    .pb.SetMetadataArg.AttributeR\x05attrs\x1a\xc7\x01\n\tAttribute\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04size\x18\x02\x20\x01\
    (\x04R\x04size\x12\x1d\n\tvalue_int\x18\x03\x20\x01(\x04H\0R\x08valueInt\
    \x12\x1d\n\tvalue_bin\x18\x04\x20\x01(\x0cH\0R\x08valueBin\x12\x16\n\x06\
    offset\x18\x05\x20\x01(\x05R\x06offset\x12\x12\n\x04mask\x18\x06\x20\x01\
    (\x0cR\x04mask\x12\x1f\n\x0brshift_bits\x18\x07\x20\x01(\x05R\nrshiftBit\
    sB\x07\n\x05value\"\t\n\x07SinkArg\"0\n\x18SourceCommandSetBurstArg\x12\
    \x14\n\x05burst\x18\x01\x20\x01(\x04R\x05burst\"7\n\x1aSourceCommandSetP\
    ktSizeArg\x12\x19\n\x08pkt_size\x18\x01\x20\x01(\x04R\x07pktSize\"&\n\tS\
    ourceArg\x12\x19\n\x08pkt_size\x18\x01\x20\x01(\x04R\x07pktSize\"'\n\rIP\
    ChecksumArg\x12\x16\n\x06verify\x18\x01\x20\x01(\x08R\x06verify\"'\n\rL4\
    ChecksumArg\x12\x16\n\x06verify\x18\x01\x20\x01(\x08R\x06verify\"`\n\x08\
    SplitArg\x12\x12\n\x04size\x18\x01\x20\x01(\x04R\x04size\x12\x1e\n\tattr\
    ibute\x18\x02\x20\x01(\tH\0R\tattribute\x12\x18\n\x06offset\x18\x03\x20\
    \x01(\x03H\0R\x06offsetB\x06\n\x04type\"O\n\x0cTimestampArg\x12\x18\n\
    \x06offset\x18\x01\x20\x01(\x04H\0R\x06offset\x12\x1d\n\tattr_name\x18\
    \x02\x20\x01(\tH\0R\x08attrNameB\x06\n\x04type\"\x88\x01\n\tUpdateArg\
    \x120\n\x06fields\x18\x01\x20\x03(\x0b2\x18.bess.pb.UpdateArg.FieldR\x06\
    fields\x1aI\n\x05Field\x12\x16\n\x06offset\x18\x01\x20\x01(\x03R\x06offs\
    et\x12\x12\n\x04size\x18\x02\x20\x01(\x04R\x04size\x12\x14\n\x05value\
    \x18\x03\x20\x01(\x04R\x05value\"v\n\x0cUrlFilterArg\x127\n\tblacklist\
    \x18\x01\x20\x03(\x0b2\x19.bess.pb.UrlFilterArg.UrlR\tblacklist\x1a-\n\
    \x03Url\x12\x12\n\x04host\x18\x01\x20\x01(\tR\x04host\x12\x12\n\x04path\
    \x18\x02\x20\x01(\tR\x04path\"J\n\x0fUrlFilterConfig\x127\n\tblacklist\
    \x18\x01\x20\x03(\x0b2\x19.bess.pb.UrlFilterArg.UrlR\tblacklist\"\x0c\n\
    \nVLANPopArg\"\x1f\n\x0bVLANPushArg\x12\x10\n\x03tci\x18\x01\x20\x01(\
    \x04R\x03tci\"\x0e\n\x0cVLANSplitArg\"\x0f\n\rVXLANDecapArg\")\n\rVXLANE\
    ncapArg\x12\x18\n\x07dstport\x18\x01\x20\x01(\x04R\x07dstport\":\n\x10Wi\
    ldcardMatchArg\x12&\n\x06fields\x18\x01\x20\x03(\x0b2\x0e.bess.pb.FieldR\
    \x06fields\"s\n\x13WildcardMatchConfig\x12!\n\x0cdefault_gate\x18\x01\
    \x20\x01(\x04R\x0bdefaultGate\x129\n\x05rules\x18\x02\x20\x03(\x0b2#.bes\
    s.pb.WildcardMatchCommandAddArgR\x05rules\"<\n\x0fArpResponderArg\x12\
    \x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\x12\x19\n\x08mac_addr\x18\x02\x20\
    \x01(\tR\x07macAddr\"\\\n\nMplsPopArg\x12*\n\x11remove_eth_header\x18\
    \x01\x20\x01(\x08R\x0fremoveEthHeader\x12\"\n\rnext_eth_type\x18\x02\x20\
    \x01(\rR\x0bnextEthType\"\x9d\x01\n\x0eWorkerSplitArg\x12K\n\x0cworker_g\
    ates\x18\x01\x20\x03(\x0b2(.bess.pb.WorkerSplitArg.WorkerGatesEntryR\x0b\
    workerGates\x1a>\n\x10WorkerGatesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \rR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value:\x028\x01b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<
    ::protobuf::descriptor::FileDescriptorProto,
> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| parse_descriptor_proto())
}
