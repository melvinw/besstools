// This file is generated by rust-protobuf 2.16.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `bess_msg.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_16_2;

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EmptyRequest {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmptyRequest {
    fn default() -> &'a EmptyRequest {
        <EmptyRequest as ::protobuf::Message>::default_instance()
    }
}

impl EmptyRequest {
    pub fn new() -> EmptyRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EmptyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmptyRequest {
        EmptyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmptyRequest>(
                "EmptyRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static EmptyRequest {
        static instance: ::protobuf::rt::LazyV2<EmptyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmptyRequest::new)
    }
}

impl ::protobuf::Clear for EmptyRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmptyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EmptyResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmptyResponse {
    fn default() -> &'a EmptyResponse {
        <EmptyResponse as ::protobuf::Message>::default_instance()
    }
}

impl EmptyResponse {
    pub fn new() -> EmptyResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }
}

impl ::protobuf::Message for EmptyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmptyResponse {
        EmptyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &EmptyResponse| &m.error,
                    |m: &mut EmptyResponse| &mut m.error,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmptyResponse>(
                "EmptyResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static EmptyResponse {
        static instance: ::protobuf::rt::LazyV2<EmptyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmptyResponse::new)
    }
}

impl ::protobuf::Clear for EmptyResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmptyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VersionResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub version: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionResponse {
    fn default() -> &'a VersionResponse {
        <VersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl VersionResponse {
    pub fn new() -> VersionResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // string version = 2;

    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VersionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.version,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionResponse {
        VersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &VersionResponse| &m.error,
                    |m: &mut VersionResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "version",
                |m: &VersionResponse| &m.version,
                |m: &mut VersionResponse| &mut m.version,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VersionResponse>(
                "VersionResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static VersionResponse {
        static instance: ::protobuf::rt::LazyV2<VersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VersionResponse::new)
    }
}

impl ::protobuf::Clear for VersionResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ImportPluginRequest {
    // message fields
    pub path: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportPluginRequest {
    fn default() -> &'a ImportPluginRequest {
        <ImportPluginRequest as ::protobuf::Message>::default_instance()
    }
}

impl ImportPluginRequest {
    pub fn new() -> ImportPluginRequest {
        ::std::default::Default::default()
    }

    // string path = 1;

    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ImportPluginRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.path,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportPluginRequest {
        ImportPluginRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "path",
                |m: &ImportPluginRequest| &m.path,
                |m: &mut ImportPluginRequest| &mut m.path,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImportPluginRequest>(
                "ImportPluginRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ImportPluginRequest {
        static instance: ::protobuf::rt::LazyV2<ImportPluginRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImportPluginRequest::new)
    }
}

impl ::protobuf::Clear for ImportPluginRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImportPluginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportPluginRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UnloadPluginRequest {
    // message fields
    pub path: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnloadPluginRequest {
    fn default() -> &'a UnloadPluginRequest {
        <UnloadPluginRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnloadPluginRequest {
    pub fn new() -> UnloadPluginRequest {
        ::std::default::Default::default()
    }

    // string path = 1;

    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnloadPluginRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.path,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnloadPluginRequest {
        UnloadPluginRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "path",
                |m: &UnloadPluginRequest| &m.path,
                |m: &mut UnloadPluginRequest| &mut m.path,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnloadPluginRequest>(
                "UnloadPluginRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UnloadPluginRequest {
        static instance: ::protobuf::rt::LazyV2<UnloadPluginRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnloadPluginRequest::new)
    }
}

impl ::protobuf::Clear for UnloadPluginRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnloadPluginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnloadPluginRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListPluginsResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub paths: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPluginsResponse {
    fn default() -> &'a ListPluginsResponse {
        <ListPluginsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPluginsResponse {
    pub fn new() -> ListPluginsResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated string paths = 2;

    pub fn get_paths(&self) -> &[::std::string::String] {
        &self.paths
    }
    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.paths, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListPluginsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.paths)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.paths {
            my_size += ::protobuf::rt::string_size(2, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.paths {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPluginsResponse {
        ListPluginsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListPluginsResponse| &m.error,
                    |m: &mut ListPluginsResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "paths",
                    |m: &ListPluginsResponse| &m.paths,
                    |m: &mut ListPluginsResponse| &mut m.paths,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPluginsResponse>(
                "ListPluginsResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListPluginsResponse {
        static instance: ::protobuf::rt::LazyV2<ListPluginsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPluginsResponse::new)
    }
}

impl ::protobuf::Clear for ListPluginsResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPluginsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPluginsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListWorkersResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub workers_status: ::protobuf::RepeatedField<ListWorkersResponse_WorkerStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListWorkersResponse {
    fn default() -> &'a ListWorkersResponse {
        <ListWorkersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkersResponse {
    pub fn new() -> ListWorkersResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated .bess.pb.ListWorkersResponse.WorkerStatus workers_status = 2;

    pub fn get_workers_status(&self) -> &[ListWorkersResponse_WorkerStatus] {
        &self.workers_status
    }
    pub fn clear_workers_status(&mut self) {
        self.workers_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_workers_status(
        &mut self,
        v: ::protobuf::RepeatedField<ListWorkersResponse_WorkerStatus>,
    ) {
        self.workers_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workers_status(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<ListWorkersResponse_WorkerStatus> {
        &mut self.workers_status
    }

    // Take field
    pub fn take_workers_status(
        &mut self,
    ) -> ::protobuf::RepeatedField<ListWorkersResponse_WorkerStatus> {
        ::std::mem::replace(&mut self.workers_status, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListWorkersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.workers_status {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.workers_status,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.workers_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.workers_status {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListWorkersResponse {
        ListWorkersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListWorkersResponse| &m.error,
                    |m: &mut ListWorkersResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<ListWorkersResponse_WorkerStatus>,
                >(
                    "workers_status",
                    |m: &ListWorkersResponse| &m.workers_status,
                    |m: &mut ListWorkersResponse| &mut m.workers_status,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListWorkersResponse>(
                "ListWorkersResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListWorkersResponse {
        static instance: ::protobuf::rt::LazyV2<ListWorkersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListWorkersResponse::new)
    }
}

impl ::protobuf::Clear for ListWorkersResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.workers_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListWorkersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListWorkersResponse_WorkerStatus {
    // message fields
    pub wid: i64,
    pub core: i64,
    pub running: bool,
    pub num_tcs: i64,
    pub silent_drops: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListWorkersResponse_WorkerStatus {
    fn default() -> &'a ListWorkersResponse_WorkerStatus {
        <ListWorkersResponse_WorkerStatus as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkersResponse_WorkerStatus {
    pub fn new() -> ListWorkersResponse_WorkerStatus {
        ::std::default::Default::default()
    }

    // int64 wid = 1;

    pub fn get_wid(&self) -> i64 {
        self.wid
    }
    pub fn clear_wid(&mut self) {
        self.wid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wid(&mut self, v: i64) {
        self.wid = v;
    }

    // int64 core = 2;

    pub fn get_core(&self) -> i64 {
        self.core
    }
    pub fn clear_core(&mut self) {
        self.core = 0;
    }

    // Param is passed by value, moved
    pub fn set_core(&mut self, v: i64) {
        self.core = v;
    }

    // bool running = 3;

    pub fn get_running(&self) -> bool {
        self.running
    }
    pub fn clear_running(&mut self) {
        self.running = false;
    }

    // Param is passed by value, moved
    pub fn set_running(&mut self, v: bool) {
        self.running = v;
    }

    // int64 num_tcs = 4;

    pub fn get_num_tcs(&self) -> i64 {
        self.num_tcs
    }
    pub fn clear_num_tcs(&mut self) {
        self.num_tcs = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_tcs(&mut self, v: i64) {
        self.num_tcs = v;
    }

    // int64 silent_drops = 5;

    pub fn get_silent_drops(&self) -> i64 {
        self.silent_drops
    }
    pub fn clear_silent_drops(&mut self) {
        self.silent_drops = 0;
    }

    // Param is passed by value, moved
    pub fn set_silent_drops(&mut self, v: i64) {
        self.silent_drops = v;
    }
}

impl ::protobuf::Message for ListWorkersResponse_WorkerStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.wid = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.core = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.running = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.num_tcs = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.silent_drops = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wid != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.wid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.core != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.core, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.running != false {
            my_size += 2;
        }
        if self.num_tcs != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.num_tcs,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.silent_drops != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.silent_drops,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.wid != 0 {
            os.write_int64(1, self.wid)?;
        }
        if self.core != 0 {
            os.write_int64(2, self.core)?;
        }
        if self.running != false {
            os.write_bool(3, self.running)?;
        }
        if self.num_tcs != 0 {
            os.write_int64(4, self.num_tcs)?;
        }
        if self.silent_drops != 0 {
            os.write_int64(5, self.silent_drops)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListWorkersResponse_WorkerStatus {
        ListWorkersResponse_WorkerStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "wid",
                |m: &ListWorkersResponse_WorkerStatus| &m.wid,
                |m: &mut ListWorkersResponse_WorkerStatus| &mut m.wid,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "core",
                |m: &ListWorkersResponse_WorkerStatus| &m.core,
                |m: &mut ListWorkersResponse_WorkerStatus| &mut m.core,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "running",
                |m: &ListWorkersResponse_WorkerStatus| &m.running,
                |m: &mut ListWorkersResponse_WorkerStatus| &mut m.running,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "num_tcs",
                |m: &ListWorkersResponse_WorkerStatus| &m.num_tcs,
                |m: &mut ListWorkersResponse_WorkerStatus| &mut m.num_tcs,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "silent_drops",
                |m: &ListWorkersResponse_WorkerStatus| &m.silent_drops,
                |m: &mut ListWorkersResponse_WorkerStatus| &mut m.silent_drops,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListWorkersResponse_WorkerStatus>(
                "ListWorkersResponse.WorkerStatus",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListWorkersResponse_WorkerStatus {
        static instance: ::protobuf::rt::LazyV2<ListWorkersResponse_WorkerStatus> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ListWorkersResponse_WorkerStatus::new)
    }
}

impl ::protobuf::Clear for ListWorkersResponse_WorkerStatus {
    fn clear(&mut self) {
        self.wid = 0;
        self.core = 0;
        self.running = false;
        self.num_tcs = 0;
        self.silent_drops = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListWorkersResponse_WorkerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkersResponse_WorkerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AddWorkerRequest {
    // message fields
    pub wid: i64,
    pub core: i64,
    pub scheduler: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddWorkerRequest {
    fn default() -> &'a AddWorkerRequest {
        <AddWorkerRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddWorkerRequest {
    pub fn new() -> AddWorkerRequest {
        ::std::default::Default::default()
    }

    // int64 wid = 1;

    pub fn get_wid(&self) -> i64 {
        self.wid
    }
    pub fn clear_wid(&mut self) {
        self.wid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wid(&mut self, v: i64) {
        self.wid = v;
    }

    // int64 core = 2;

    pub fn get_core(&self) -> i64 {
        self.core
    }
    pub fn clear_core(&mut self) {
        self.core = 0;
    }

    // Param is passed by value, moved
    pub fn set_core(&mut self, v: i64) {
        self.core = v;
    }

    // string scheduler = 3;

    pub fn get_scheduler(&self) -> &str {
        &self.scheduler
    }
    pub fn clear_scheduler(&mut self) {
        self.scheduler.clear();
    }

    // Param is passed by value, moved
    pub fn set_scheduler(&mut self, v: ::std::string::String) {
        self.scheduler = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduler(&mut self) -> &mut ::std::string::String {
        &mut self.scheduler
    }

    // Take field
    pub fn take_scheduler(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scheduler, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddWorkerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.wid = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.core = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.scheduler,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wid != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.wid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.core != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.core, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.scheduler.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.scheduler);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.wid != 0 {
            os.write_int64(1, self.wid)?;
        }
        if self.core != 0 {
            os.write_int64(2, self.core)?;
        }
        if !self.scheduler.is_empty() {
            os.write_string(3, &self.scheduler)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddWorkerRequest {
        AddWorkerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "wid",
                |m: &AddWorkerRequest| &m.wid,
                |m: &mut AddWorkerRequest| &mut m.wid,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "core",
                |m: &AddWorkerRequest| &m.core,
                |m: &mut AddWorkerRequest| &mut m.core,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "scheduler",
                |m: &AddWorkerRequest| &m.scheduler,
                |m: &mut AddWorkerRequest| &mut m.scheduler,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddWorkerRequest>(
                "AddWorkerRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static AddWorkerRequest {
        static instance: ::protobuf::rt::LazyV2<AddWorkerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddWorkerRequest::new)
    }
}

impl ::protobuf::Clear for AddWorkerRequest {
    fn clear(&mut self) {
        self.wid = 0;
        self.core = 0;
        self.scheduler.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddWorkerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddWorkerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DestroyWorkerRequest {
    // message fields
    pub wid: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DestroyWorkerRequest {
    fn default() -> &'a DestroyWorkerRequest {
        <DestroyWorkerRequest as ::protobuf::Message>::default_instance()
    }
}

impl DestroyWorkerRequest {
    pub fn new() -> DestroyWorkerRequest {
        ::std::default::Default::default()
    }

    // int64 wid = 1;

    pub fn get_wid(&self) -> i64 {
        self.wid
    }
    pub fn clear_wid(&mut self) {
        self.wid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wid(&mut self, v: i64) {
        self.wid = v;
    }
}

impl ::protobuf::Message for DestroyWorkerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.wid = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wid != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.wid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.wid != 0 {
            os.write_int64(1, self.wid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DestroyWorkerRequest {
        DestroyWorkerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "wid",
                |m: &DestroyWorkerRequest| &m.wid,
                |m: &mut DestroyWorkerRequest| &mut m.wid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DestroyWorkerRequest>(
                "DestroyWorkerRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DestroyWorkerRequest {
        static instance: ::protobuf::rt::LazyV2<DestroyWorkerRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(DestroyWorkerRequest::new)
    }
}

impl ::protobuf::Clear for DestroyWorkerRequest {
    fn clear(&mut self) {
        self.wid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DestroyWorkerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DestroyWorkerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TrafficClass {
    // message fields
    pub parent: ::std::string::String,
    pub name: ::std::string::String,
    pub blocked: bool,
    pub policy: ::std::string::String,
    pub resource: ::std::string::String,
    pub wid: i64,
    pub limit: ::std::collections::HashMap<::std::string::String, i64>,
    pub max_burst: ::std::collections::HashMap<::std::string::String, i64>,
    pub leaf_module_name: ::std::string::String,
    pub leaf_module_taskid: u64,
    // message oneof groups
    pub arg: ::std::option::Option<TrafficClass_oneof_arg>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrafficClass {
    fn default() -> &'a TrafficClass {
        <TrafficClass as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum TrafficClass_oneof_arg {
    priority(i64),
    share(i64),
}

impl TrafficClass {
    pub fn new() -> TrafficClass {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool blocked = 3;

    pub fn get_blocked(&self) -> bool {
        self.blocked
    }
    pub fn clear_blocked(&mut self) {
        self.blocked = false;
    }

    // Param is passed by value, moved
    pub fn set_blocked(&mut self, v: bool) {
        self.blocked = v;
    }

    // string policy = 4;

    pub fn get_policy(&self) -> &str {
        &self.policy
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: ::std::string::String) {
        self.policy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut ::std::string::String {
        &mut self.policy
    }

    // Take field
    pub fn take_policy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.policy, ::std::string::String::new())
    }

    // string resource = 5;

    pub fn get_resource(&self) -> &str {
        &self.resource
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        &mut self.resource
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource, ::std::string::String::new())
    }

    // int64 priority = 6;

    pub fn get_priority(&self) -> i64 {
        match self.arg {
            ::std::option::Option::Some(TrafficClass_oneof_arg::priority(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_priority(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(TrafficClass_oneof_arg::priority(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i64) {
        self.arg = ::std::option::Option::Some(TrafficClass_oneof_arg::priority(v))
    }

    // int64 share = 7;

    pub fn get_share(&self) -> i64 {
        match self.arg {
            ::std::option::Option::Some(TrafficClass_oneof_arg::share(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_share(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_share(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(TrafficClass_oneof_arg::share(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_share(&mut self, v: i64) {
        self.arg = ::std::option::Option::Some(TrafficClass_oneof_arg::share(v))
    }

    // int64 wid = 8;

    pub fn get_wid(&self) -> i64 {
        self.wid
    }
    pub fn clear_wid(&mut self) {
        self.wid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wid(&mut self, v: i64) {
        self.wid = v;
    }

    // repeated .bess.pb.TrafficClass.LimitEntry limit = 9;

    pub fn get_limit(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.limit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limit(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.limit
    }

    // Take field
    pub fn take_limit(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.limit, ::std::collections::HashMap::new())
    }

    // repeated .bess.pb.TrafficClass.MaxBurstEntry max_burst = 10;

    pub fn get_max_burst(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.max_burst
    }
    pub fn clear_max_burst(&mut self) {
        self.max_burst.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_burst(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.max_burst = v;
    }

    // Mutable pointer to the field.
    pub fn mut_max_burst(
        &mut self,
    ) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.max_burst
    }

    // Take field
    pub fn take_max_burst(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.max_burst, ::std::collections::HashMap::new())
    }

    // string leaf_module_name = 11;

    pub fn get_leaf_module_name(&self) -> &str {
        &self.leaf_module_name
    }
    pub fn clear_leaf_module_name(&mut self) {
        self.leaf_module_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaf_module_name(&mut self, v: ::std::string::String) {
        self.leaf_module_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaf_module_name(&mut self) -> &mut ::std::string::String {
        &mut self.leaf_module_name
    }

    // Take field
    pub fn take_leaf_module_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.leaf_module_name, ::std::string::String::new())
    }

    // uint64 leaf_module_taskid = 12;

    pub fn get_leaf_module_taskid(&self) -> u64 {
        self.leaf_module_taskid
    }
    pub fn clear_leaf_module_taskid(&mut self) {
        self.leaf_module_taskid = 0;
    }

    // Param is passed by value, moved
    pub fn set_leaf_module_taskid(&mut self, v: u64) {
        self.leaf_module_taskid = v;
    }
}

impl ::protobuf::Message for TrafficClass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.parent,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.blocked = tmp;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.policy,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.resource,
                    )?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.arg = ::std::option::Option::Some(TrafficClass_oneof_arg::priority(
                        is.read_int64()?,
                    ));
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.arg = ::std::option::Option::Some(TrafficClass_oneof_arg::share(
                        is.read_int64()?,
                    ));
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.wid = tmp;
                }
                9 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeInt64,
                    >(wire_type, is, &mut self.limit)?;
                }
                10 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeInt64,
                    >(wire_type, is, &mut self.max_burst)?;
                }
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.leaf_module_name,
                    )?;
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.leaf_module_taskid = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.blocked != false {
            my_size += 2;
        }
        if !self.policy.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.policy);
        }
        if !self.resource.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.resource);
        }
        if self.wid != 0 {
            my_size +=
                ::protobuf::rt::value_size(8, self.wid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(9, &self.limit);
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(10, &self.max_burst);
        if !self.leaf_module_name.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.leaf_module_name);
        }
        if self.leaf_module_taskid != 0 {
            my_size += ::protobuf::rt::value_size(
                12,
                self.leaf_module_taskid,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &TrafficClass_oneof_arg::priority(v) => {
                    my_size +=
                        ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                }
                &TrafficClass_oneof_arg::share(v) => {
                    my_size +=
                        ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.blocked != false {
            os.write_bool(3, self.blocked)?;
        }
        if !self.policy.is_empty() {
            os.write_string(4, &self.policy)?;
        }
        if !self.resource.is_empty() {
            os.write_string(5, &self.resource)?;
        }
        if self.wid != 0 {
            os.write_int64(8, self.wid)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(9, &self.limit, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeInt64,
        >(10, &self.max_burst, os)?;
        if !self.leaf_module_name.is_empty() {
            os.write_string(11, &self.leaf_module_name)?;
        }
        if self.leaf_module_taskid != 0 {
            os.write_uint64(12, self.leaf_module_taskid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &TrafficClass_oneof_arg::priority(v) => {
                    os.write_int64(6, v)?;
                }
                &TrafficClass_oneof_arg::share(v) => {
                    os.write_int64(7, v)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrafficClass {
        TrafficClass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "parent",
                |m: &TrafficClass| &m.parent,
                |m: &mut TrafficClass| &mut m.parent,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &TrafficClass| &m.name,
                |m: &mut TrafficClass| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "blocked",
                |m: &TrafficClass| &m.blocked,
                |m: &mut TrafficClass| &mut m.blocked,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "policy",
                |m: &TrafficClass| &m.policy,
                |m: &mut TrafficClass| &mut m.policy,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "resource",
                |m: &TrafficClass| &m.resource,
                |m: &mut TrafficClass| &mut m.resource,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "priority",
                    TrafficClass::has_priority,
                    TrafficClass::get_priority,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "share",
                    TrafficClass::has_share,
                    TrafficClass::get_share,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "wid",
                |m: &TrafficClass| &m.wid,
                |m: &mut TrafficClass| &mut m.wid,
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "limit",
                |m: &TrafficClass| &m.limit,
                |m: &mut TrafficClass| &mut m.limit,
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "max_burst",
                |m: &TrafficClass| &m.max_burst,
                |m: &mut TrafficClass| &mut m.max_burst,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "leaf_module_name",
                |m: &TrafficClass| &m.leaf_module_name,
                |m: &mut TrafficClass| &mut m.leaf_module_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "leaf_module_taskid",
                |m: &TrafficClass| &m.leaf_module_taskid,
                |m: &mut TrafficClass| &mut m.leaf_module_taskid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrafficClass>(
                "TrafficClass",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static TrafficClass {
        static instance: ::protobuf::rt::LazyV2<TrafficClass> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrafficClass::new)
    }
}

impl ::protobuf::Clear for TrafficClass {
    fn clear(&mut self) {
        self.parent.clear();
        self.name.clear();
        self.blocked = false;
        self.policy.clear();
        self.resource.clear();
        self.arg = ::std::option::Option::None;
        self.arg = ::std::option::Option::None;
        self.wid = 0;
        self.limit.clear();
        self.max_burst.clear();
        self.leaf_module_name.clear();
        self.leaf_module_taskid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrafficClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficClass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListTcsRequest {
    // message fields
    pub wid: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTcsRequest {
    fn default() -> &'a ListTcsRequest {
        <ListTcsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTcsRequest {
    pub fn new() -> ListTcsRequest {
        ::std::default::Default::default()
    }

    // int64 wid = 1;

    pub fn get_wid(&self) -> i64 {
        self.wid
    }
    pub fn clear_wid(&mut self) {
        self.wid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wid(&mut self, v: i64) {
        self.wid = v;
    }
}

impl ::protobuf::Message for ListTcsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.wid = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wid != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.wid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.wid != 0 {
            os.write_int64(1, self.wid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTcsRequest {
        ListTcsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "wid",
                |m: &ListTcsRequest| &m.wid,
                |m: &mut ListTcsRequest| &mut m.wid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTcsRequest>(
                "ListTcsRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListTcsRequest {
        static instance: ::protobuf::rt::LazyV2<ListTcsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTcsRequest::new)
    }
}

impl ::protobuf::Clear for ListTcsRequest {
    fn clear(&mut self) {
        self.wid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTcsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTcsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListTcsResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub classes_status: ::protobuf::RepeatedField<ListTcsResponse_TrafficClassStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTcsResponse {
    fn default() -> &'a ListTcsResponse {
        <ListTcsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTcsResponse {
    pub fn new() -> ListTcsResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated .bess.pb.ListTcsResponse.TrafficClassStatus classes_status = 2;

    pub fn get_classes_status(&self) -> &[ListTcsResponse_TrafficClassStatus] {
        &self.classes_status
    }
    pub fn clear_classes_status(&mut self) {
        self.classes_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_classes_status(
        &mut self,
        v: ::protobuf::RepeatedField<ListTcsResponse_TrafficClassStatus>,
    ) {
        self.classes_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_classes_status(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<ListTcsResponse_TrafficClassStatus> {
        &mut self.classes_status
    }

    // Take field
    pub fn take_classes_status(
        &mut self,
    ) -> ::protobuf::RepeatedField<ListTcsResponse_TrafficClassStatus> {
        ::std::mem::replace(&mut self.classes_status, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListTcsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.classes_status {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.classes_status,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.classes_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.classes_status {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTcsResponse {
        ListTcsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListTcsResponse| &m.error,
                    |m: &mut ListTcsResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<ListTcsResponse_TrafficClassStatus>,
                >(
                    "classes_status",
                    |m: &ListTcsResponse| &m.classes_status,
                    |m: &mut ListTcsResponse| &mut m.classes_status,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTcsResponse>(
                "ListTcsResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListTcsResponse {
        static instance: ::protobuf::rt::LazyV2<ListTcsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTcsResponse::new)
    }
}

impl ::protobuf::Clear for ListTcsResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.classes_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTcsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTcsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListTcsResponse_TrafficClassStatus {
    // message fields
    pub class: ::protobuf::SingularPtrField<TrafficClass>,
    pub parent: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTcsResponse_TrafficClassStatus {
    fn default() -> &'a ListTcsResponse_TrafficClassStatus {
        <ListTcsResponse_TrafficClassStatus as ::protobuf::Message>::default_instance()
    }
}

impl ListTcsResponse_TrafficClassStatus {
    pub fn new() -> ListTcsResponse_TrafficClassStatus {
        ::std::default::Default::default()
    }

    // .bess.pb.TrafficClass class = 1;

    pub fn get_class(&self) -> &TrafficClass {
        self.class
            .as_ref()
            .unwrap_or_else(|| <TrafficClass as ::protobuf::Message>::default_instance())
    }
    pub fn clear_class(&mut self) {
        self.class.clear();
    }

    pub fn has_class(&self) -> bool {
        self.class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class(&mut self, v: TrafficClass) {
        self.class = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class(&mut self) -> &mut TrafficClass {
        if self.class.is_none() {
            self.class.set_default();
        }
        self.class.as_mut().unwrap()
    }

    // Take field
    pub fn take_class(&mut self) -> TrafficClass {
        self.class.take().unwrap_or_else(|| TrafficClass::new())
    }

    // string parent = 2;

    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTcsResponse_TrafficClassStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.class {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.class)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.parent,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.class.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.class.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.parent.is_empty() {
            os.write_string(2, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTcsResponse_TrafficClassStatus {
        ListTcsResponse_TrafficClassStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrafficClass>>(
                "class",
                |m: &ListTcsResponse_TrafficClassStatus| { &m.class },
                |m: &mut ListTcsResponse_TrafficClassStatus| { &mut m.class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListTcsResponse_TrafficClassStatus| { &m.parent },
                |m: &mut ListTcsResponse_TrafficClassStatus| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTcsResponse_TrafficClassStatus>(
                "ListTcsResponse.TrafficClassStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTcsResponse_TrafficClassStatus {
        static instance: ::protobuf::rt::LazyV2<ListTcsResponse_TrafficClassStatus> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTcsResponse_TrafficClassStatus::new)
    }
}

impl ::protobuf::Clear for ListTcsResponse_TrafficClassStatus {
    fn clear(&mut self) {
        self.class.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTcsResponse_TrafficClassStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTcsResponse_TrafficClassStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CheckSchedulingConstraintsResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub fatal: bool,
    pub violations: ::protobuf::RepeatedField<CheckSchedulingConstraintsResponse_ViolatingClass>,
    pub modules: ::protobuf::RepeatedField<CheckSchedulingConstraintsResponse_ViolatingModule>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckSchedulingConstraintsResponse {
    fn default() -> &'a CheckSchedulingConstraintsResponse {
        <CheckSchedulingConstraintsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CheckSchedulingConstraintsResponse {
    pub fn new() -> CheckSchedulingConstraintsResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // bool fatal = 2;

    pub fn get_fatal(&self) -> bool {
        self.fatal
    }
    pub fn clear_fatal(&mut self) {
        self.fatal = false;
    }

    // Param is passed by value, moved
    pub fn set_fatal(&mut self, v: bool) {
        self.fatal = v;
    }

    // repeated .bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass violations = 3;

    pub fn get_violations(&self) -> &[CheckSchedulingConstraintsResponse_ViolatingClass] {
        &self.violations
    }
    pub fn clear_violations(&mut self) {
        self.violations.clear();
    }

    // Param is passed by value, moved
    pub fn set_violations(
        &mut self,
        v: ::protobuf::RepeatedField<CheckSchedulingConstraintsResponse_ViolatingClass>,
    ) {
        self.violations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_violations(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<CheckSchedulingConstraintsResponse_ViolatingClass> {
        &mut self.violations
    }

    // Take field
    pub fn take_violations(
        &mut self,
    ) -> ::protobuf::RepeatedField<CheckSchedulingConstraintsResponse_ViolatingClass> {
        ::std::mem::replace(&mut self.violations, ::protobuf::RepeatedField::new())
    }

    // repeated .bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule modules = 4;

    pub fn get_modules(&self) -> &[CheckSchedulingConstraintsResponse_ViolatingModule] {
        &self.modules
    }
    pub fn clear_modules(&mut self) {
        self.modules.clear();
    }

    // Param is passed by value, moved
    pub fn set_modules(
        &mut self,
        v: ::protobuf::RepeatedField<CheckSchedulingConstraintsResponse_ViolatingModule>,
    ) {
        self.modules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modules(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<CheckSchedulingConstraintsResponse_ViolatingModule> {
        &mut self.modules
    }

    // Take field
    pub fn take_modules(
        &mut self,
    ) -> ::protobuf::RepeatedField<CheckSchedulingConstraintsResponse_ViolatingModule> {
        ::std::mem::replace(&mut self.modules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CheckSchedulingConstraintsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.violations {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.modules {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.fatal = tmp;
                }
                3 => {
                    ::protobuf::rt::read_repeated_message_into(
                        wire_type,
                        is,
                        &mut self.violations,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modules)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.fatal != false {
            my_size += 2;
        }
        for value in &self.violations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.fatal != false {
            os.write_bool(2, self.fatal)?;
        }
        for v in &self.violations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.modules {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckSchedulingConstraintsResponse {
        CheckSchedulingConstraintsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::error::Error>>(
                "error",
                |m: &CheckSchedulingConstraintsResponse| { &m.error },
                |m: &mut CheckSchedulingConstraintsResponse| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fatal",
                |m: &CheckSchedulingConstraintsResponse| { &m.fatal },
                |m: &mut CheckSchedulingConstraintsResponse| { &mut m.fatal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckSchedulingConstraintsResponse_ViolatingClass>>(
                "violations",
                |m: &CheckSchedulingConstraintsResponse| { &m.violations },
                |m: &mut CheckSchedulingConstraintsResponse| { &mut m.violations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckSchedulingConstraintsResponse_ViolatingModule>>(
                "modules",
                |m: &CheckSchedulingConstraintsResponse| { &m.modules },
                |m: &mut CheckSchedulingConstraintsResponse| { &mut m.modules },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckSchedulingConstraintsResponse>(
                "CheckSchedulingConstraintsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckSchedulingConstraintsResponse {
        static instance: ::protobuf::rt::LazyV2<CheckSchedulingConstraintsResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckSchedulingConstraintsResponse::new)
    }
}

impl ::protobuf::Clear for CheckSchedulingConstraintsResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.fatal = false;
        self.violations.clear();
        self.modules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckSchedulingConstraintsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckSchedulingConstraintsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CheckSchedulingConstraintsResponse_ViolatingClass {
    // message fields
    pub name: ::std::string::String,
    pub constraint: i32,
    pub assigned_node: i32,
    pub assigned_core: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckSchedulingConstraintsResponse_ViolatingClass {
    fn default() -> &'a CheckSchedulingConstraintsResponse_ViolatingClass {
        <CheckSchedulingConstraintsResponse_ViolatingClass as ::protobuf::Message>::default_instance(
        )
    }
}

impl CheckSchedulingConstraintsResponse_ViolatingClass {
    pub fn new() -> CheckSchedulingConstraintsResponse_ViolatingClass {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 constraint = 2;

    pub fn get_constraint(&self) -> i32 {
        self.constraint
    }
    pub fn clear_constraint(&mut self) {
        self.constraint = 0;
    }

    // Param is passed by value, moved
    pub fn set_constraint(&mut self, v: i32) {
        self.constraint = v;
    }

    // int32 assigned_node = 3;

    pub fn get_assigned_node(&self) -> i32 {
        self.assigned_node
    }
    pub fn clear_assigned_node(&mut self) {
        self.assigned_node = 0;
    }

    // Param is passed by value, moved
    pub fn set_assigned_node(&mut self, v: i32) {
        self.assigned_node = v;
    }

    // int32 assigned_core = 4;

    pub fn get_assigned_core(&self) -> i32 {
        self.assigned_core
    }
    pub fn clear_assigned_core(&mut self) {
        self.assigned_core = 0;
    }

    // Param is passed by value, moved
    pub fn set_assigned_core(&mut self, v: i32) {
        self.assigned_core = v;
    }
}

impl ::protobuf::Message for CheckSchedulingConstraintsResponse_ViolatingClass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.constraint = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.assigned_node = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.assigned_core = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.constraint != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.constraint,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.assigned_node != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.assigned_node,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.assigned_core != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.assigned_core,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.constraint != 0 {
            os.write_int32(2, self.constraint)?;
        }
        if self.assigned_node != 0 {
            os.write_int32(3, self.assigned_node)?;
        }
        if self.assigned_core != 0 {
            os.write_int32(4, self.assigned_core)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckSchedulingConstraintsResponse_ViolatingClass {
        CheckSchedulingConstraintsResponse_ViolatingClass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &CheckSchedulingConstraintsResponse_ViolatingClass| &m.name,
                |m: &mut CheckSchedulingConstraintsResponse_ViolatingClass| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "constraint",
                |m: &CheckSchedulingConstraintsResponse_ViolatingClass| &m.constraint,
                |m: &mut CheckSchedulingConstraintsResponse_ViolatingClass| &mut m.constraint,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "assigned_node",
                |m: &CheckSchedulingConstraintsResponse_ViolatingClass| &m.assigned_node,
                |m: &mut CheckSchedulingConstraintsResponse_ViolatingClass| &mut m.assigned_node,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "assigned_core",
                |m: &CheckSchedulingConstraintsResponse_ViolatingClass| &m.assigned_core,
                |m: &mut CheckSchedulingConstraintsResponse_ViolatingClass| &mut m.assigned_core,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                CheckSchedulingConstraintsResponse_ViolatingClass,
            >(
                "CheckSchedulingConstraintsResponse.ViolatingClass",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CheckSchedulingConstraintsResponse_ViolatingClass {
        static instance: ::protobuf::rt::LazyV2<CheckSchedulingConstraintsResponse_ViolatingClass> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckSchedulingConstraintsResponse_ViolatingClass::new)
    }
}

impl ::protobuf::Clear for CheckSchedulingConstraintsResponse_ViolatingClass {
    fn clear(&mut self) {
        self.name.clear();
        self.constraint = 0;
        self.assigned_node = 0;
        self.assigned_core = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckSchedulingConstraintsResponse_ViolatingClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckSchedulingConstraintsResponse_ViolatingClass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CheckSchedulingConstraintsResponse_ViolatingModule {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckSchedulingConstraintsResponse_ViolatingModule {
    fn default() -> &'a CheckSchedulingConstraintsResponse_ViolatingModule {
        <CheckSchedulingConstraintsResponse_ViolatingModule as ::protobuf::Message>::default_instance()
    }
}

impl CheckSchedulingConstraintsResponse_ViolatingModule {
    pub fn new() -> CheckSchedulingConstraintsResponse_ViolatingModule {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CheckSchedulingConstraintsResponse_ViolatingModule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckSchedulingConstraintsResponse_ViolatingModule {
        CheckSchedulingConstraintsResponse_ViolatingModule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &CheckSchedulingConstraintsResponse_ViolatingModule| &m.name,
                |m: &mut CheckSchedulingConstraintsResponse_ViolatingModule| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                CheckSchedulingConstraintsResponse_ViolatingModule,
            >(
                "CheckSchedulingConstraintsResponse.ViolatingModule",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CheckSchedulingConstraintsResponse_ViolatingModule {
        static instance: ::protobuf::rt::LazyV2<
            CheckSchedulingConstraintsResponse_ViolatingModule,
        > = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckSchedulingConstraintsResponse_ViolatingModule::new)
    }
}

impl ::protobuf::Clear for CheckSchedulingConstraintsResponse_ViolatingModule {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckSchedulingConstraintsResponse_ViolatingModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckSchedulingConstraintsResponse_ViolatingModule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AddTcRequest {
    // message fields
    pub class: ::protobuf::SingularPtrField<TrafficClass>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddTcRequest {
    fn default() -> &'a AddTcRequest {
        <AddTcRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddTcRequest {
    pub fn new() -> AddTcRequest {
        ::std::default::Default::default()
    }

    // .bess.pb.TrafficClass class = 1;

    pub fn get_class(&self) -> &TrafficClass {
        self.class
            .as_ref()
            .unwrap_or_else(|| <TrafficClass as ::protobuf::Message>::default_instance())
    }
    pub fn clear_class(&mut self) {
        self.class.clear();
    }

    pub fn has_class(&self) -> bool {
        self.class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class(&mut self, v: TrafficClass) {
        self.class = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class(&mut self) -> &mut TrafficClass {
        if self.class.is_none() {
            self.class.set_default();
        }
        self.class.as_mut().unwrap()
    }

    // Take field
    pub fn take_class(&mut self) -> TrafficClass {
        self.class.take().unwrap_or_else(|| TrafficClass::new())
    }
}

impl ::protobuf::Message for AddTcRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.class {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.class)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.class.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.class.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddTcRequest {
        AddTcRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<TrafficClass>,
                >(
                    "class",
                    |m: &AddTcRequest| &m.class,
                    |m: &mut AddTcRequest| &mut m.class,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddTcRequest>(
                "AddTcRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static AddTcRequest {
        static instance: ::protobuf::rt::LazyV2<AddTcRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddTcRequest::new)
    }
}

impl ::protobuf::Clear for AddTcRequest {
    fn clear(&mut self) {
        self.class.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddTcRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddTcRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateTcParamsRequest {
    // message fields
    pub class: ::protobuf::SingularPtrField<TrafficClass>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTcParamsRequest {
    fn default() -> &'a UpdateTcParamsRequest {
        <UpdateTcParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTcParamsRequest {
    pub fn new() -> UpdateTcParamsRequest {
        ::std::default::Default::default()
    }

    // .bess.pb.TrafficClass class = 1;

    pub fn get_class(&self) -> &TrafficClass {
        self.class
            .as_ref()
            .unwrap_or_else(|| <TrafficClass as ::protobuf::Message>::default_instance())
    }
    pub fn clear_class(&mut self) {
        self.class.clear();
    }

    pub fn has_class(&self) -> bool {
        self.class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class(&mut self, v: TrafficClass) {
        self.class = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class(&mut self) -> &mut TrafficClass {
        if self.class.is_none() {
            self.class.set_default();
        }
        self.class.as_mut().unwrap()
    }

    // Take field
    pub fn take_class(&mut self) -> TrafficClass {
        self.class.take().unwrap_or_else(|| TrafficClass::new())
    }
}

impl ::protobuf::Message for UpdateTcParamsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.class {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.class)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.class.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.class.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTcParamsRequest {
        UpdateTcParamsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<TrafficClass>,
                >(
                    "class",
                    |m: &UpdateTcParamsRequest| &m.class,
                    |m: &mut UpdateTcParamsRequest| &mut m.class,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTcParamsRequest>(
                "UpdateTcParamsRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UpdateTcParamsRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateTcParamsRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTcParamsRequest::new)
    }
}

impl ::protobuf::Clear for UpdateTcParamsRequest {
    fn clear(&mut self) {
        self.class.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTcParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTcParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateTcParentRequest {
    // message fields
    pub class: ::protobuf::SingularPtrField<TrafficClass>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTcParentRequest {
    fn default() -> &'a UpdateTcParentRequest {
        <UpdateTcParentRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTcParentRequest {
    pub fn new() -> UpdateTcParentRequest {
        ::std::default::Default::default()
    }

    // .bess.pb.TrafficClass class = 1;

    pub fn get_class(&self) -> &TrafficClass {
        self.class
            .as_ref()
            .unwrap_or_else(|| <TrafficClass as ::protobuf::Message>::default_instance())
    }
    pub fn clear_class(&mut self) {
        self.class.clear();
    }

    pub fn has_class(&self) -> bool {
        self.class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class(&mut self, v: TrafficClass) {
        self.class = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class(&mut self) -> &mut TrafficClass {
        if self.class.is_none() {
            self.class.set_default();
        }
        self.class.as_mut().unwrap()
    }

    // Take field
    pub fn take_class(&mut self) -> TrafficClass {
        self.class.take().unwrap_or_else(|| TrafficClass::new())
    }
}

impl ::protobuf::Message for UpdateTcParentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.class {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.class)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.class.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.class.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTcParentRequest {
        UpdateTcParentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<TrafficClass>,
                >(
                    "class",
                    |m: &UpdateTcParentRequest| &m.class,
                    |m: &mut UpdateTcParentRequest| &mut m.class,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTcParentRequest>(
                "UpdateTcParentRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static UpdateTcParentRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateTcParentRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTcParentRequest::new)
    }
}

impl ::protobuf::Clear for UpdateTcParentRequest {
    fn clear(&mut self) {
        self.class.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTcParentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTcParentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetTcStatsRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTcStatsRequest {
    fn default() -> &'a GetTcStatsRequest {
        <GetTcStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTcStatsRequest {
    pub fn new() -> GetTcStatsRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTcStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTcStatsRequest {
        GetTcStatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetTcStatsRequest| &m.name,
                |m: &mut GetTcStatsRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTcStatsRequest>(
                "GetTcStatsRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetTcStatsRequest {
        static instance: ::protobuf::rt::LazyV2<GetTcStatsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTcStatsRequest::new)
    }
}

impl ::protobuf::Clear for GetTcStatsRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTcStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTcStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetTcStatsResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub timestamp: f64,
    pub count: u64,
    pub cycles: u64,
    pub packets: u64,
    pub bits: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTcStatsResponse {
    fn default() -> &'a GetTcStatsResponse {
        <GetTcStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTcStatsResponse {
    pub fn new() -> GetTcStatsResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // double timestamp = 2;

    pub fn get_timestamp(&self) -> f64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0.;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = v;
    }

    // uint64 count = 3;

    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }

    // uint64 cycles = 4;

    pub fn get_cycles(&self) -> u64 {
        self.cycles
    }
    pub fn clear_cycles(&mut self) {
        self.cycles = 0;
    }

    // Param is passed by value, moved
    pub fn set_cycles(&mut self, v: u64) {
        self.cycles = v;
    }

    // uint64 packets = 5;

    pub fn get_packets(&self) -> u64 {
        self.packets
    }
    pub fn clear_packets(&mut self) {
        self.packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: u64) {
        self.packets = v;
    }

    // uint64 bits = 6;

    pub fn get_bits(&self) -> u64 {
        self.bits
    }
    pub fn clear_bits(&mut self) {
        self.bits = 0;
    }

    // Param is passed by value, moved
    pub fn set_bits(&mut self, v: u64) {
        self.bits = v;
    }
}

impl ::protobuf::Message for GetTcStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.timestamp = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.cycles = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.bits = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0. {
            my_size += 9;
        }
        if self.count != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cycles != 0 {
            my_size +=
                ::protobuf::rt::value_size(4, self.cycles, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.packets != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.packets,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.bits != 0 {
            my_size +=
                ::protobuf::rt::value_size(6, self.bits, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0. {
            os.write_double(2, self.timestamp)?;
        }
        if self.count != 0 {
            os.write_uint64(3, self.count)?;
        }
        if self.cycles != 0 {
            os.write_uint64(4, self.cycles)?;
        }
        if self.packets != 0 {
            os.write_uint64(5, self.packets)?;
        }
        if self.bits != 0 {
            os.write_uint64(6, self.bits)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTcStatsResponse {
        GetTcStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &GetTcStatsResponse| &m.error,
                    |m: &mut GetTcStatsResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "timestamp",
                |m: &GetTcStatsResponse| &m.timestamp,
                |m: &mut GetTcStatsResponse| &mut m.timestamp,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "count",
                |m: &GetTcStatsResponse| &m.count,
                |m: &mut GetTcStatsResponse| &mut m.count,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "cycles",
                |m: &GetTcStatsResponse| &m.cycles,
                |m: &mut GetTcStatsResponse| &mut m.cycles,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "packets",
                |m: &GetTcStatsResponse| &m.packets,
                |m: &mut GetTcStatsResponse| &mut m.packets,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "bits",
                |m: &GetTcStatsResponse| &m.bits,
                |m: &mut GetTcStatsResponse| &mut m.bits,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTcStatsResponse>(
                "GetTcStatsResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetTcStatsResponse {
        static instance: ::protobuf::rt::LazyV2<GetTcStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTcStatsResponse::new)
    }
}

impl ::protobuf::Clear for GetTcStatsResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.timestamp = 0.;
        self.count = 0;
        self.cycles = 0;
        self.packets = 0;
        self.bits = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTcStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTcStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListDriversResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub driver_names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDriversResponse {
    fn default() -> &'a ListDriversResponse {
        <ListDriversResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDriversResponse {
    pub fn new() -> ListDriversResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated string driver_names = 2;

    pub fn get_driver_names(&self) -> &[::std::string::String] {
        &self.driver_names
    }
    pub fn clear_driver_names(&mut self) {
        self.driver_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.driver_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_driver_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.driver_names
    }

    // Take field
    pub fn take_driver_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.driver_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListDriversResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_string_into(
                        wire_type,
                        is,
                        &mut self.driver_names,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.driver_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.driver_names {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDriversResponse {
        ListDriversResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListDriversResponse| &m.error,
                    |m: &mut ListDriversResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "driver_names",
                    |m: &ListDriversResponse| &m.driver_names,
                    |m: &mut ListDriversResponse| &mut m.driver_names,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDriversResponse>(
                "ListDriversResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListDriversResponse {
        static instance: ::protobuf::rt::LazyV2<ListDriversResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDriversResponse::new)
    }
}

impl ::protobuf::Clear for ListDriversResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.driver_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDriversResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDriversResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetDriverInfoRequest {
    // message fields
    pub driver_name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDriverInfoRequest {
    fn default() -> &'a GetDriverInfoRequest {
        <GetDriverInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDriverInfoRequest {
    pub fn new() -> GetDriverInfoRequest {
        ::std::default::Default::default()
    }

    // string driver_name = 1;

    pub fn get_driver_name(&self) -> &str {
        &self.driver_name
    }
    pub fn clear_driver_name(&mut self) {
        self.driver_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver_name(&mut self, v: ::std::string::String) {
        self.driver_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver_name(&mut self) -> &mut ::std::string::String {
        &mut self.driver_name
    }

    // Take field
    pub fn take_driver_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.driver_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDriverInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.driver_name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.driver_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.driver_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.driver_name.is_empty() {
            os.write_string(1, &self.driver_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDriverInfoRequest {
        GetDriverInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "driver_name",
                |m: &GetDriverInfoRequest| &m.driver_name,
                |m: &mut GetDriverInfoRequest| &mut m.driver_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDriverInfoRequest>(
                "GetDriverInfoRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetDriverInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetDriverInfoRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDriverInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetDriverInfoRequest {
    fn clear(&mut self) {
        self.driver_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDriverInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDriverInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetDriverInfoResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub name: ::std::string::String,
    pub help: ::std::string::String,
    pub commands: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDriverInfoResponse {
    fn default() -> &'a GetDriverInfoResponse {
        <GetDriverInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDriverInfoResponse {
    pub fn new() -> GetDriverInfoResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string help = 3;

    pub fn get_help(&self) -> &str {
        &self.help
    }
    pub fn clear_help(&mut self) {
        self.help.clear();
    }

    // Param is passed by value, moved
    pub fn set_help(&mut self, v: ::std::string::String) {
        self.help = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_help(&mut self) -> &mut ::std::string::String {
        &mut self.help
    }

    // Take field
    pub fn take_help(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.help, ::std::string::String::new())
    }

    // repeated string commands = 4;

    pub fn get_commands(&self) -> &[::std::string::String] {
        &self.commands
    }
    pub fn clear_commands(&mut self) {
        self.commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_commands(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commands(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.commands
    }

    // Take field
    pub fn take_commands(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.commands, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDriverInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.help,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.commands)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.help.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.help);
        }
        for value in &self.commands {
            my_size += ::protobuf::rt::string_size(4, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.help.is_empty() {
            os.write_string(3, &self.help)?;
        }
        for v in &self.commands {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDriverInfoResponse {
        GetDriverInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &GetDriverInfoResponse| &m.error,
                    |m: &mut GetDriverInfoResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetDriverInfoResponse| &m.name,
                |m: &mut GetDriverInfoResponse| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "help",
                |m: &GetDriverInfoResponse| &m.help,
                |m: &mut GetDriverInfoResponse| &mut m.help,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "commands",
                    |m: &GetDriverInfoResponse| &m.commands,
                    |m: &mut GetDriverInfoResponse| &mut m.commands,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDriverInfoResponse>(
                "GetDriverInfoResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetDriverInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetDriverInfoResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDriverInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetDriverInfoResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.name.clear();
        self.help.clear();
        self.commands.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDriverInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDriverInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListPortsResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub ports: ::protobuf::RepeatedField<ListPortsResponse_Port>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPortsResponse {
    fn default() -> &'a ListPortsResponse {
        <ListPortsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPortsResponse {
    pub fn new() -> ListPortsResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated .bess.pb.ListPortsResponse.Port ports = 2;

    pub fn get_ports(&self) -> &[ListPortsResponse_Port] {
        &self.ports
    }
    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<ListPortsResponse_Port>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<ListPortsResponse_Port> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<ListPortsResponse_Port> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListPortsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ports {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPortsResponse {
        ListPortsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListPortsResponse| &m.error,
                    |m: &mut ListPortsResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<ListPortsResponse_Port>,
                >(
                    "ports",
                    |m: &ListPortsResponse| &m.ports,
                    |m: &mut ListPortsResponse| &mut m.ports,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPortsResponse>(
                "ListPortsResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListPortsResponse {
        static instance: ::protobuf::rt::LazyV2<ListPortsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPortsResponse::new)
    }
}

impl ::protobuf::Clear for ListPortsResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.ports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPortsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPortsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListPortsResponse_Port {
    // message fields
    pub name: ::std::string::String,
    pub driver: ::std::string::String,
    pub mac_addr: ::std::string::String,
    pub num_inc_q: u64,
    pub num_out_q: u64,
    pub size_inc_q: u64,
    pub size_out_q: u64,
    pub driver_arg: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPortsResponse_Port {
    fn default() -> &'a ListPortsResponse_Port {
        <ListPortsResponse_Port as ::protobuf::Message>::default_instance()
    }
}

impl ListPortsResponse_Port {
    pub fn new() -> ListPortsResponse_Port {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string driver = 2;

    pub fn get_driver(&self) -> &str {
        &self.driver
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        &mut self.driver
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.driver, ::std::string::String::new())
    }

    // string mac_addr = 3;

    pub fn get_mac_addr(&self) -> &str {
        &self.mac_addr
    }
    pub fn clear_mac_addr(&mut self) {
        self.mac_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_addr(&mut self, v: ::std::string::String) {
        self.mac_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_addr(&mut self) -> &mut ::std::string::String {
        &mut self.mac_addr
    }

    // Take field
    pub fn take_mac_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_addr, ::std::string::String::new())
    }

    // uint64 num_inc_q = 4;

    pub fn get_num_inc_q(&self) -> u64 {
        self.num_inc_q
    }
    pub fn clear_num_inc_q(&mut self) {
        self.num_inc_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_inc_q(&mut self, v: u64) {
        self.num_inc_q = v;
    }

    // uint64 num_out_q = 5;

    pub fn get_num_out_q(&self) -> u64 {
        self.num_out_q
    }
    pub fn clear_num_out_q(&mut self) {
        self.num_out_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_out_q(&mut self, v: u64) {
        self.num_out_q = v;
    }

    // uint64 size_inc_q = 6;

    pub fn get_size_inc_q(&self) -> u64 {
        self.size_inc_q
    }
    pub fn clear_size_inc_q(&mut self) {
        self.size_inc_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_size_inc_q(&mut self, v: u64) {
        self.size_inc_q = v;
    }

    // uint64 size_out_q = 7;

    pub fn get_size_out_q(&self) -> u64 {
        self.size_out_q
    }
    pub fn clear_size_out_q(&mut self) {
        self.size_out_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_size_out_q(&mut self, v: u64) {
        self.size_out_q = v;
    }

    // .google.protobuf.Any driver_arg = 8;

    pub fn get_driver_arg(&self) -> &::protobuf::well_known_types::Any {
        self.driver_arg.as_ref().unwrap_or_else(|| {
            <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_driver_arg(&mut self) {
        self.driver_arg.clear();
    }

    pub fn has_driver_arg(&self) -> bool {
        self.driver_arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver_arg(&mut self, v: ::protobuf::well_known_types::Any) {
        self.driver_arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver_arg(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.driver_arg.is_none() {
            self.driver_arg.set_default();
        }
        self.driver_arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver_arg(&mut self) -> ::protobuf::well_known_types::Any {
        self.driver_arg
            .take()
            .unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for ListPortsResponse_Port {
    fn is_initialized(&self) -> bool {
        for v in &self.driver_arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.driver,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mac_addr,
                    )?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_inc_q = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_out_q = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size_inc_q = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size_out_q = tmp;
                }
                8 => {
                    ::protobuf::rt::read_singular_message_into(
                        wire_type,
                        is,
                        &mut self.driver_arg,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.driver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.driver);
        }
        if !self.mac_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mac_addr);
        }
        if self.num_inc_q != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.num_inc_q,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.num_out_q != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.num_out_q,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.size_inc_q != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.size_inc_q,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.size_out_q != 0 {
            my_size += ::protobuf::rt::value_size(
                7,
                self.size_out_q,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let Some(ref v) = self.driver_arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.driver.is_empty() {
            os.write_string(2, &self.driver)?;
        }
        if !self.mac_addr.is_empty() {
            os.write_string(3, &self.mac_addr)?;
        }
        if self.num_inc_q != 0 {
            os.write_uint64(4, self.num_inc_q)?;
        }
        if self.num_out_q != 0 {
            os.write_uint64(5, self.num_out_q)?;
        }
        if self.size_inc_q != 0 {
            os.write_uint64(6, self.size_inc_q)?;
        }
        if self.size_out_q != 0 {
            os.write_uint64(7, self.size_out_q)?;
        }
        if let Some(ref v) = self.driver_arg.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPortsResponse_Port {
        ListPortsResponse_Port::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &ListPortsResponse_Port| &m.name,
                |m: &mut ListPortsResponse_Port| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "driver",
                |m: &ListPortsResponse_Port| &m.driver,
                |m: &mut ListPortsResponse_Port| &mut m.driver,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mac_addr",
                |m: &ListPortsResponse_Port| &m.mac_addr,
                |m: &mut ListPortsResponse_Port| &mut m.mac_addr,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "num_inc_q",
                |m: &ListPortsResponse_Port| &m.num_inc_q,
                |m: &mut ListPortsResponse_Port| &mut m.num_inc_q,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "num_out_q",
                |m: &ListPortsResponse_Port| &m.num_out_q,
                |m: &mut ListPortsResponse_Port| &mut m.num_out_q,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size_inc_q",
                |m: &ListPortsResponse_Port| &m.size_inc_q,
                |m: &mut ListPortsResponse_Port| &mut m.size_inc_q,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size_out_q",
                |m: &ListPortsResponse_Port| &m.size_out_q,
                |m: &mut ListPortsResponse_Port| &mut m.size_out_q,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>,
                >(
                    "driver_arg",
                    |m: &ListPortsResponse_Port| &m.driver_arg,
                    |m: &mut ListPortsResponse_Port| &mut m.driver_arg,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPortsResponse_Port>(
                "ListPortsResponse.Port",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListPortsResponse_Port {
        static instance: ::protobuf::rt::LazyV2<ListPortsResponse_Port> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPortsResponse_Port::new)
    }
}

impl ::protobuf::Clear for ListPortsResponse_Port {
    fn clear(&mut self) {
        self.name.clear();
        self.driver.clear();
        self.mac_addr.clear();
        self.num_inc_q = 0;
        self.num_out_q = 0;
        self.size_inc_q = 0;
        self.size_out_q = 0;
        self.driver_arg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPortsResponse_Port {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPortsResponse_Port {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CreatePortRequest {
    // message fields
    pub name: ::std::string::String,
    pub driver: ::std::string::String,
    pub num_inc_q: u64,
    pub num_out_q: u64,
    pub size_inc_q: u64,
    pub size_out_q: u64,
    pub arg: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatePortRequest {
    fn default() -> &'a CreatePortRequest {
        <CreatePortRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreatePortRequest {
    pub fn new() -> CreatePortRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string driver = 2;

    pub fn get_driver(&self) -> &str {
        &self.driver
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        &mut self.driver
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.driver, ::std::string::String::new())
    }

    // uint64 num_inc_q = 3;

    pub fn get_num_inc_q(&self) -> u64 {
        self.num_inc_q
    }
    pub fn clear_num_inc_q(&mut self) {
        self.num_inc_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_inc_q(&mut self, v: u64) {
        self.num_inc_q = v;
    }

    // uint64 num_out_q = 4;

    pub fn get_num_out_q(&self) -> u64 {
        self.num_out_q
    }
    pub fn clear_num_out_q(&mut self) {
        self.num_out_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_out_q(&mut self, v: u64) {
        self.num_out_q = v;
    }

    // uint64 size_inc_q = 5;

    pub fn get_size_inc_q(&self) -> u64 {
        self.size_inc_q
    }
    pub fn clear_size_inc_q(&mut self) {
        self.size_inc_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_size_inc_q(&mut self, v: u64) {
        self.size_inc_q = v;
    }

    // uint64 size_out_q = 6;

    pub fn get_size_out_q(&self) -> u64 {
        self.size_out_q
    }
    pub fn clear_size_out_q(&mut self) {
        self.size_out_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_size_out_q(&mut self, v: u64) {
        self.size_out_q = v;
    }

    // .google.protobuf.Any arg = 7;

    pub fn get_arg(&self) -> &::protobuf::well_known_types::Any {
        self.arg.as_ref().unwrap_or_else(|| {
            <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::protobuf::well_known_types::Any) {
        self.arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::protobuf::well_known_types::Any {
        self.arg
            .take()
            .unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for CreatePortRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.driver,
                    )?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_inc_q = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_out_q = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size_inc_q = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size_out_q = tmp;
                }
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arg)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.driver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.driver);
        }
        if self.num_inc_q != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.num_inc_q,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.num_out_q != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.num_out_q,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.size_inc_q != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.size_inc_q,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.size_out_q != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.size_out_q,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if let Some(ref v) = self.arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.driver.is_empty() {
            os.write_string(2, &self.driver)?;
        }
        if self.num_inc_q != 0 {
            os.write_uint64(3, self.num_inc_q)?;
        }
        if self.num_out_q != 0 {
            os.write_uint64(4, self.num_out_q)?;
        }
        if self.size_inc_q != 0 {
            os.write_uint64(5, self.size_inc_q)?;
        }
        if self.size_out_q != 0 {
            os.write_uint64(6, self.size_out_q)?;
        }
        if let Some(ref v) = self.arg.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatePortRequest {
        CreatePortRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &CreatePortRequest| &m.name,
                |m: &mut CreatePortRequest| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "driver",
                |m: &CreatePortRequest| &m.driver,
                |m: &mut CreatePortRequest| &mut m.driver,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "num_inc_q",
                |m: &CreatePortRequest| &m.num_inc_q,
                |m: &mut CreatePortRequest| &mut m.num_inc_q,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "num_out_q",
                |m: &CreatePortRequest| &m.num_out_q,
                |m: &mut CreatePortRequest| &mut m.num_out_q,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size_inc_q",
                |m: &CreatePortRequest| &m.size_inc_q,
                |m: &mut CreatePortRequest| &mut m.size_inc_q,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size_out_q",
                |m: &CreatePortRequest| &m.size_out_q,
                |m: &mut CreatePortRequest| &mut m.size_out_q,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>,
                >(
                    "arg",
                    |m: &CreatePortRequest| &m.arg,
                    |m: &mut CreatePortRequest| &mut m.arg,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreatePortRequest>(
                "CreatePortRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CreatePortRequest {
        static instance: ::protobuf::rt::LazyV2<CreatePortRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreatePortRequest::new)
    }
}

impl ::protobuf::Clear for CreatePortRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.driver.clear();
        self.num_inc_q = 0;
        self.num_out_q = 0;
        self.size_inc_q = 0;
        self.size_out_q = 0;
        self.arg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreatePortRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePortRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PortConf {
    // message fields
    pub mac_addr: ::std::string::String,
    pub mtu: u32,
    pub admin_up: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortConf {
    fn default() -> &'a PortConf {
        <PortConf as ::protobuf::Message>::default_instance()
    }
}

impl PortConf {
    pub fn new() -> PortConf {
        ::std::default::Default::default()
    }

    // string mac_addr = 1;

    pub fn get_mac_addr(&self) -> &str {
        &self.mac_addr
    }
    pub fn clear_mac_addr(&mut self) {
        self.mac_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_addr(&mut self, v: ::std::string::String) {
        self.mac_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_addr(&mut self) -> &mut ::std::string::String {
        &mut self.mac_addr
    }

    // Take field
    pub fn take_mac_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_addr, ::std::string::String::new())
    }

    // uint32 mtu = 2;

    pub fn get_mtu(&self) -> u32 {
        self.mtu
    }
    pub fn clear_mtu(&mut self) {
        self.mtu = 0;
    }

    // Param is passed by value, moved
    pub fn set_mtu(&mut self, v: u32) {
        self.mtu = v;
    }

    // bool admin_up = 3;

    pub fn get_admin_up(&self) -> bool {
        self.admin_up
    }
    pub fn clear_admin_up(&mut self) {
        self.admin_up = false;
    }

    // Param is passed by value, moved
    pub fn set_admin_up(&mut self, v: bool) {
        self.admin_up = v;
    }
}

impl ::protobuf::Message for PortConf {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mac_addr,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.mtu = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.admin_up = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mac_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mac_addr);
        }
        if self.mtu != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.mtu, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.admin_up != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.mac_addr.is_empty() {
            os.write_string(1, &self.mac_addr)?;
        }
        if self.mtu != 0 {
            os.write_uint32(2, self.mtu)?;
        }
        if self.admin_up != false {
            os.write_bool(3, self.admin_up)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortConf {
        PortConf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mac_addr",
                |m: &PortConf| &m.mac_addr,
                |m: &mut PortConf| &mut m.mac_addr,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "mtu",
                |m: &PortConf| &m.mtu,
                |m: &mut PortConf| &mut m.mtu,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "admin_up",
                |m: &PortConf| &m.admin_up,
                |m: &mut PortConf| &mut m.admin_up,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortConf>(
                "PortConf",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static PortConf {
        static instance: ::protobuf::rt::LazyV2<PortConf> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortConf::new)
    }
}

impl ::protobuf::Clear for PortConf {
    fn clear(&mut self) {
        self.mac_addr.clear();
        self.mtu = 0;
        self.admin_up = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortConf {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SetPortConfRequest {
    // message fields
    pub name: ::std::string::String,
    pub conf: ::protobuf::SingularPtrField<PortConf>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPortConfRequest {
    fn default() -> &'a SetPortConfRequest {
        <SetPortConfRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPortConfRequest {
    pub fn new() -> SetPortConfRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .bess.pb.PortConf conf = 2;

    pub fn get_conf(&self) -> &PortConf {
        self.conf
            .as_ref()
            .unwrap_or_else(|| <PortConf as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conf(&mut self) {
        self.conf.clear();
    }

    pub fn has_conf(&self) -> bool {
        self.conf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conf(&mut self, v: PortConf) {
        self.conf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conf(&mut self) -> &mut PortConf {
        if self.conf.is_none() {
            self.conf.set_default();
        }
        self.conf.as_mut().unwrap()
    }

    // Take field
    pub fn take_conf(&mut self) -> PortConf {
        self.conf.take().unwrap_or_else(|| PortConf::new())
    }
}

impl ::protobuf::Message for SetPortConfRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.conf {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conf)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.conf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.conf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPortConfRequest {
        SetPortConfRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &SetPortConfRequest| &m.name,
                |m: &mut SetPortConfRequest| &mut m.name,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<PortConf>,
                >(
                    "conf",
                    |m: &SetPortConfRequest| &m.conf,
                    |m: &mut SetPortConfRequest| &mut m.conf,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetPortConfRequest>(
                "SetPortConfRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static SetPortConfRequest {
        static instance: ::protobuf::rt::LazyV2<SetPortConfRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetPortConfRequest::new)
    }
}

impl ::protobuf::Clear for SetPortConfRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.conf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPortConfRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPortConfRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetPortConfRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPortConfRequest {
    fn default() -> &'a GetPortConfRequest {
        <GetPortConfRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPortConfRequest {
    pub fn new() -> GetPortConfRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPortConfRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPortConfRequest {
        GetPortConfRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetPortConfRequest| &m.name,
                |m: &mut GetPortConfRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPortConfRequest>(
                "GetPortConfRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetPortConfRequest {
        static instance: ::protobuf::rt::LazyV2<GetPortConfRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPortConfRequest::new)
    }
}

impl ::protobuf::Clear for GetPortConfRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPortConfRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPortConfRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetPortConfResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub conf: ::protobuf::SingularPtrField<PortConf>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPortConfResponse {
    fn default() -> &'a GetPortConfResponse {
        <GetPortConfResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPortConfResponse {
    pub fn new() -> GetPortConfResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // .bess.pb.PortConf conf = 2;

    pub fn get_conf(&self) -> &PortConf {
        self.conf
            .as_ref()
            .unwrap_or_else(|| <PortConf as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conf(&mut self) {
        self.conf.clear();
    }

    pub fn has_conf(&self) -> bool {
        self.conf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conf(&mut self, v: PortConf) {
        self.conf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conf(&mut self) -> &mut PortConf {
        if self.conf.is_none() {
            self.conf.set_default();
        }
        self.conf.as_mut().unwrap()
    }

    // Take field
    pub fn take_conf(&mut self) -> PortConf {
        self.conf.take().unwrap_or_else(|| PortConf::new())
    }
}

impl ::protobuf::Message for GetPortConfResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.conf {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conf)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.conf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.conf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPortConfResponse {
        GetPortConfResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &GetPortConfResponse| &m.error,
                    |m: &mut GetPortConfResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<PortConf>,
                >(
                    "conf",
                    |m: &GetPortConfResponse| &m.conf,
                    |m: &mut GetPortConfResponse| &mut m.conf,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPortConfResponse>(
                "GetPortConfResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetPortConfResponse {
        static instance: ::protobuf::rt::LazyV2<GetPortConfResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPortConfResponse::new)
    }
}

impl ::protobuf::Clear for GetPortConfResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.conf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPortConfResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPortConfResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CreatePortResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub name: ::std::string::String,
    pub mac_addr: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatePortResponse {
    fn default() -> &'a CreatePortResponse {
        <CreatePortResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreatePortResponse {
    pub fn new() -> CreatePortResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string mac_addr = 3;

    pub fn get_mac_addr(&self) -> &str {
        &self.mac_addr
    }
    pub fn clear_mac_addr(&mut self) {
        self.mac_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_addr(&mut self, v: ::std::string::String) {
        self.mac_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_addr(&mut self) -> &mut ::std::string::String {
        &mut self.mac_addr
    }

    // Take field
    pub fn take_mac_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreatePortResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mac_addr,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.mac_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mac_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.mac_addr.is_empty() {
            os.write_string(3, &self.mac_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatePortResponse {
        CreatePortResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &CreatePortResponse| &m.error,
                    |m: &mut CreatePortResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &CreatePortResponse| &m.name,
                |m: &mut CreatePortResponse| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mac_addr",
                |m: &CreatePortResponse| &m.mac_addr,
                |m: &mut CreatePortResponse| &mut m.mac_addr,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreatePortResponse>(
                "CreatePortResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CreatePortResponse {
        static instance: ::protobuf::rt::LazyV2<CreatePortResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreatePortResponse::new)
    }
}

impl ::protobuf::Clear for CreatePortResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.name.clear();
        self.mac_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreatePortResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePortResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DestroyPortRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DestroyPortRequest {
    fn default() -> &'a DestroyPortRequest {
        <DestroyPortRequest as ::protobuf::Message>::default_instance()
    }
}

impl DestroyPortRequest {
    pub fn new() -> DestroyPortRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DestroyPortRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DestroyPortRequest {
        DestroyPortRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &DestroyPortRequest| &m.name,
                |m: &mut DestroyPortRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DestroyPortRequest>(
                "DestroyPortRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DestroyPortRequest {
        static instance: ::protobuf::rt::LazyV2<DestroyPortRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DestroyPortRequest::new)
    }
}

impl ::protobuf::Clear for DestroyPortRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DestroyPortRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DestroyPortRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetPortStatsRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPortStatsRequest {
    fn default() -> &'a GetPortStatsRequest {
        <GetPortStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPortStatsRequest {
    pub fn new() -> GetPortStatsRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPortStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPortStatsRequest {
        GetPortStatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetPortStatsRequest| &m.name,
                |m: &mut GetPortStatsRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPortStatsRequest>(
                "GetPortStatsRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetPortStatsRequest {
        static instance: ::protobuf::rt::LazyV2<GetPortStatsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPortStatsRequest::new)
    }
}

impl ::protobuf::Clear for GetPortStatsRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPortStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPortStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetPortStatsResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub inc: ::protobuf::SingularPtrField<GetPortStatsResponse_Stat>,
    pub out: ::protobuf::SingularPtrField<GetPortStatsResponse_Stat>,
    pub timestamp: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPortStatsResponse {
    fn default() -> &'a GetPortStatsResponse {
        <GetPortStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPortStatsResponse {
    pub fn new() -> GetPortStatsResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // .bess.pb.GetPortStatsResponse.Stat inc = 2;

    pub fn get_inc(&self) -> &GetPortStatsResponse_Stat {
        self.inc.as_ref().unwrap_or_else(|| {
            <GetPortStatsResponse_Stat as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_inc(&mut self) {
        self.inc.clear();
    }

    pub fn has_inc(&self) -> bool {
        self.inc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inc(&mut self, v: GetPortStatsResponse_Stat) {
        self.inc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inc(&mut self) -> &mut GetPortStatsResponse_Stat {
        if self.inc.is_none() {
            self.inc.set_default();
        }
        self.inc.as_mut().unwrap()
    }

    // Take field
    pub fn take_inc(&mut self) -> GetPortStatsResponse_Stat {
        self.inc
            .take()
            .unwrap_or_else(|| GetPortStatsResponse_Stat::new())
    }

    // .bess.pb.GetPortStatsResponse.Stat out = 3;

    pub fn get_out(&self) -> &GetPortStatsResponse_Stat {
        self.out.as_ref().unwrap_or_else(|| {
            <GetPortStatsResponse_Stat as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    pub fn has_out(&self) -> bool {
        self.out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: GetPortStatsResponse_Stat) {
        self.out = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut GetPortStatsResponse_Stat {
        if self.out.is_none() {
            self.out.set_default();
        }
        self.out.as_mut().unwrap()
    }

    // Take field
    pub fn take_out(&mut self) -> GetPortStatsResponse_Stat {
        self.out
            .take()
            .unwrap_or_else(|| GetPortStatsResponse_Stat::new())
    }

    // double timestamp = 4;

    pub fn get_timestamp(&self) -> f64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0.;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for GetPortStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.inc {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.out {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inc)?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.out)?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.timestamp = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.out.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.out.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0. {
            os.write_double(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPortStatsResponse {
        GetPortStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &GetPortStatsResponse| &m.error,
                    |m: &mut GetPortStatsResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GetPortStatsResponse_Stat>,
                >(
                    "inc",
                    |m: &GetPortStatsResponse| &m.inc,
                    |m: &mut GetPortStatsResponse| &mut m.inc,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GetPortStatsResponse_Stat>,
                >(
                    "out",
                    |m: &GetPortStatsResponse| &m.out,
                    |m: &mut GetPortStatsResponse| &mut m.out,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "timestamp",
                |m: &GetPortStatsResponse| &m.timestamp,
                |m: &mut GetPortStatsResponse| &mut m.timestamp,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPortStatsResponse>(
                "GetPortStatsResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetPortStatsResponse {
        static instance: ::protobuf::rt::LazyV2<GetPortStatsResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPortStatsResponse::new)
    }
}

impl ::protobuf::Clear for GetPortStatsResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.inc.clear();
        self.out.clear();
        self.timestamp = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPortStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPortStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetPortStatsResponse_Stat {
    // message fields
    pub packets: u64,
    pub dropped: u64,
    pub bytes: u64,
    pub requested_hist: ::std::vec::Vec<u64>,
    pub actual_hist: ::std::vec::Vec<u64>,
    pub diff_hist: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPortStatsResponse_Stat {
    fn default() -> &'a GetPortStatsResponse_Stat {
        <GetPortStatsResponse_Stat as ::protobuf::Message>::default_instance()
    }
}

impl GetPortStatsResponse_Stat {
    pub fn new() -> GetPortStatsResponse_Stat {
        ::std::default::Default::default()
    }

    // uint64 packets = 1;

    pub fn get_packets(&self) -> u64 {
        self.packets
    }
    pub fn clear_packets(&mut self) {
        self.packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: u64) {
        self.packets = v;
    }

    // uint64 dropped = 2;

    pub fn get_dropped(&self) -> u64 {
        self.dropped
    }
    pub fn clear_dropped(&mut self) {
        self.dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped(&mut self, v: u64) {
        self.dropped = v;
    }

    // uint64 bytes = 3;

    pub fn get_bytes(&self) -> u64 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = v;
    }

    // repeated uint64 requested_hist = 4;

    pub fn get_requested_hist(&self) -> &[u64] {
        &self.requested_hist
    }
    pub fn clear_requested_hist(&mut self) {
        self.requested_hist.clear();
    }

    // Param is passed by value, moved
    pub fn set_requested_hist(&mut self, v: ::std::vec::Vec<u64>) {
        self.requested_hist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requested_hist(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.requested_hist
    }

    // Take field
    pub fn take_requested_hist(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.requested_hist, ::std::vec::Vec::new())
    }

    // repeated uint64 actual_hist = 5;

    pub fn get_actual_hist(&self) -> &[u64] {
        &self.actual_hist
    }
    pub fn clear_actual_hist(&mut self) {
        self.actual_hist.clear();
    }

    // Param is passed by value, moved
    pub fn set_actual_hist(&mut self, v: ::std::vec::Vec<u64>) {
        self.actual_hist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actual_hist(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.actual_hist
    }

    // Take field
    pub fn take_actual_hist(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.actual_hist, ::std::vec::Vec::new())
    }

    // repeated uint64 diff_hist = 6;

    pub fn get_diff_hist(&self) -> &[u64] {
        &self.diff_hist
    }
    pub fn clear_diff_hist(&mut self) {
        self.diff_hist.clear();
    }

    // Param is passed by value, moved
    pub fn set_diff_hist(&mut self, v: ::std::vec::Vec<u64>) {
        self.diff_hist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_diff_hist(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.diff_hist
    }

    // Take field
    pub fn take_diff_hist(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.diff_hist, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetPortStatsResponse_Stat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.dropped = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes = tmp;
                }
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(
                        wire_type,
                        is,
                        &mut self.requested_hist,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_repeated_uint64_into(
                        wire_type,
                        is,
                        &mut self.actual_hist,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.diff_hist)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.packets != 0 {
            my_size += ::protobuf::rt::value_size(
                1,
                self.packets,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.dropped != 0 {
            my_size += ::protobuf::rt::value_size(
                2,
                self.dropped,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.bytes != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requested_hist {
            my_size +=
                ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.actual_hist {
            my_size +=
                ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.diff_hist {
            my_size +=
                ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.packets != 0 {
            os.write_uint64(1, self.packets)?;
        }
        if self.dropped != 0 {
            os.write_uint64(2, self.dropped)?;
        }
        if self.bytes != 0 {
            os.write_uint64(3, self.bytes)?;
        }
        for v in &self.requested_hist {
            os.write_uint64(4, *v)?;
        }
        for v in &self.actual_hist {
            os.write_uint64(5, *v)?;
        }
        for v in &self.diff_hist {
            os.write_uint64(6, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPortStatsResponse_Stat {
        GetPortStatsResponse_Stat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "packets",
                |m: &GetPortStatsResponse_Stat| &m.packets,
                |m: &mut GetPortStatsResponse_Stat| &mut m.packets,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "dropped",
                |m: &GetPortStatsResponse_Stat| &m.dropped,
                |m: &mut GetPortStatsResponse_Stat| &mut m.dropped,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "bytes",
                |m: &GetPortStatsResponse_Stat| &m.bytes,
                |m: &mut GetPortStatsResponse_Stat| &mut m.bytes,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "requested_hist",
                |m: &GetPortStatsResponse_Stat| &m.requested_hist,
                |m: &mut GetPortStatsResponse_Stat| &mut m.requested_hist,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "actual_hist",
                |m: &GetPortStatsResponse_Stat| &m.actual_hist,
                |m: &mut GetPortStatsResponse_Stat| &mut m.actual_hist,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "diff_hist",
                |m: &GetPortStatsResponse_Stat| &m.diff_hist,
                |m: &mut GetPortStatsResponse_Stat| &mut m.diff_hist,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPortStatsResponse_Stat>(
                "GetPortStatsResponse.Stat",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetPortStatsResponse_Stat {
        static instance: ::protobuf::rt::LazyV2<GetPortStatsResponse_Stat> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPortStatsResponse_Stat::new)
    }
}

impl ::protobuf::Clear for GetPortStatsResponse_Stat {
    fn clear(&mut self) {
        self.packets = 0;
        self.dropped = 0;
        self.bytes = 0;
        self.requested_hist.clear();
        self.actual_hist.clear();
        self.diff_hist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPortStatsResponse_Stat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPortStatsResponse_Stat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetLinkStatusRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLinkStatusRequest {
    fn default() -> &'a GetLinkStatusRequest {
        <GetLinkStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLinkStatusRequest {
    pub fn new() -> GetLinkStatusRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetLinkStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLinkStatusRequest {
        GetLinkStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetLinkStatusRequest| &m.name,
                |m: &mut GetLinkStatusRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLinkStatusRequest>(
                "GetLinkStatusRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetLinkStatusRequest {
        static instance: ::protobuf::rt::LazyV2<GetLinkStatusRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLinkStatusRequest::new)
    }
}

impl ::protobuf::Clear for GetLinkStatusRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetLinkStatusResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub speed: u32,
    pub full_duplex: bool,
    pub autoneg: bool,
    pub link_up: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLinkStatusResponse {
    fn default() -> &'a GetLinkStatusResponse {
        <GetLinkStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLinkStatusResponse {
    pub fn new() -> GetLinkStatusResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // uint32 speed = 2;

    pub fn get_speed(&self) -> u32 {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = 0;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: u32) {
        self.speed = v;
    }

    // bool full_duplex = 3;

    pub fn get_full_duplex(&self) -> bool {
        self.full_duplex
    }
    pub fn clear_full_duplex(&mut self) {
        self.full_duplex = false;
    }

    // Param is passed by value, moved
    pub fn set_full_duplex(&mut self, v: bool) {
        self.full_duplex = v;
    }

    // bool autoneg = 4;

    pub fn get_autoneg(&self) -> bool {
        self.autoneg
    }
    pub fn clear_autoneg(&mut self) {
        self.autoneg = false;
    }

    // Param is passed by value, moved
    pub fn set_autoneg(&mut self, v: bool) {
        self.autoneg = v;
    }

    // bool link_up = 5;

    pub fn get_link_up(&self) -> bool {
        self.link_up
    }
    pub fn clear_link_up(&mut self) {
        self.link_up = false;
    }

    // Param is passed by value, moved
    pub fn set_link_up(&mut self, v: bool) {
        self.link_up = v;
    }
}

impl ::protobuf::Message for GetLinkStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.speed = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.full_duplex = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.autoneg = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.link_up = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.speed != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.speed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.full_duplex != false {
            my_size += 2;
        }
        if self.autoneg != false {
            my_size += 2;
        }
        if self.link_up != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.speed != 0 {
            os.write_uint32(2, self.speed)?;
        }
        if self.full_duplex != false {
            os.write_bool(3, self.full_duplex)?;
        }
        if self.autoneg != false {
            os.write_bool(4, self.autoneg)?;
        }
        if self.link_up != false {
            os.write_bool(5, self.link_up)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLinkStatusResponse {
        GetLinkStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &GetLinkStatusResponse| &m.error,
                    |m: &mut GetLinkStatusResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "speed",
                |m: &GetLinkStatusResponse| &m.speed,
                |m: &mut GetLinkStatusResponse| &mut m.speed,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "full_duplex",
                |m: &GetLinkStatusResponse| &m.full_duplex,
                |m: &mut GetLinkStatusResponse| &mut m.full_duplex,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "autoneg",
                |m: &GetLinkStatusResponse| &m.autoneg,
                |m: &mut GetLinkStatusResponse| &mut m.autoneg,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "link_up",
                |m: &GetLinkStatusResponse| &m.link_up,
                |m: &mut GetLinkStatusResponse| &mut m.link_up,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLinkStatusResponse>(
                "GetLinkStatusResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetLinkStatusResponse {
        static instance: ::protobuf::rt::LazyV2<GetLinkStatusResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLinkStatusResponse::new)
    }
}

impl ::protobuf::Clear for GetLinkStatusResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.speed = 0;
        self.full_duplex = false;
        self.autoneg = false;
        self.link_up = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListMclassResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListMclassResponse {
    fn default() -> &'a ListMclassResponse {
        <ListMclassResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListMclassResponse {
    pub fn new() -> ListMclassResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated string names = 2;

    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListMclassResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.names {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMclassResponse {
        ListMclassResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListMclassResponse| &m.error,
                    |m: &mut ListMclassResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "names",
                    |m: &ListMclassResponse| &m.names,
                    |m: &mut ListMclassResponse| &mut m.names,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListMclassResponse>(
                "ListMclassResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListMclassResponse {
        static instance: ::protobuf::rt::LazyV2<ListMclassResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListMclassResponse::new)
    }
}

impl ::protobuf::Clear for ListMclassResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMclassResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMclassResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetMclassInfoRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMclassInfoRequest {
    fn default() -> &'a GetMclassInfoRequest {
        <GetMclassInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMclassInfoRequest {
    pub fn new() -> GetMclassInfoRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetMclassInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMclassInfoRequest {
        GetMclassInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetMclassInfoRequest| &m.name,
                |m: &mut GetMclassInfoRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMclassInfoRequest>(
                "GetMclassInfoRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetMclassInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetMclassInfoRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetMclassInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetMclassInfoRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMclassInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMclassInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetMclassInfoResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub name: ::std::string::String,
    pub help: ::std::string::String,
    pub cmds: ::protobuf::RepeatedField<::std::string::String>,
    pub cmd_args: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMclassInfoResponse {
    fn default() -> &'a GetMclassInfoResponse {
        <GetMclassInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetMclassInfoResponse {
    pub fn new() -> GetMclassInfoResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string help = 3;

    pub fn get_help(&self) -> &str {
        &self.help
    }
    pub fn clear_help(&mut self) {
        self.help.clear();
    }

    // Param is passed by value, moved
    pub fn set_help(&mut self, v: ::std::string::String) {
        self.help = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_help(&mut self) -> &mut ::std::string::String {
        &mut self.help
    }

    // Take field
    pub fn take_help(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.help, ::std::string::String::new())
    }

    // repeated string cmds = 4;

    pub fn get_cmds(&self) -> &[::std::string::String] {
        &self.cmds
    }
    pub fn clear_cmds(&mut self) {
        self.cmds.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmds(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cmds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cmds(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cmds
    }

    // Take field
    pub fn take_cmds(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cmds, ::protobuf::RepeatedField::new())
    }

    // repeated string cmd_args = 5;

    pub fn get_cmd_args(&self) -> &[::std::string::String] {
        &self.cmd_args
    }
    pub fn clear_cmd_args(&mut self) {
        self.cmd_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmd_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cmd_args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cmd_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cmd_args
    }

    // Take field
    pub fn take_cmd_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cmd_args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetMclassInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.help,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cmds)?;
                }
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cmd_args)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.help.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.help);
        }
        for value in &self.cmds {
            my_size += ::protobuf::rt::string_size(4, &value);
        }
        for value in &self.cmd_args {
            my_size += ::protobuf::rt::string_size(5, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.help.is_empty() {
            os.write_string(3, &self.help)?;
        }
        for v in &self.cmds {
            os.write_string(4, &v)?;
        }
        for v in &self.cmd_args {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMclassInfoResponse {
        GetMclassInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &GetMclassInfoResponse| &m.error,
                    |m: &mut GetMclassInfoResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetMclassInfoResponse| &m.name,
                |m: &mut GetMclassInfoResponse| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "help",
                |m: &GetMclassInfoResponse| &m.help,
                |m: &mut GetMclassInfoResponse| &mut m.help,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cmds",
                    |m: &GetMclassInfoResponse| &m.cmds,
                    |m: &mut GetMclassInfoResponse| &mut m.cmds,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cmd_args",
                    |m: &GetMclassInfoResponse| &m.cmd_args,
                    |m: &mut GetMclassInfoResponse| &mut m.cmd_args,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMclassInfoResponse>(
                "GetMclassInfoResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetMclassInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetMclassInfoResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetMclassInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetMclassInfoResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.name.clear();
        self.help.clear();
        self.cmds.clear();
        self.cmd_args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMclassInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMclassInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListModulesResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub modules: ::protobuf::RepeatedField<ListModulesResponse_Module>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModulesResponse {
    fn default() -> &'a ListModulesResponse {
        <ListModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesResponse {
    pub fn new() -> ListModulesResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated .bess.pb.ListModulesResponse.Module modules = 2;

    pub fn get_modules(&self) -> &[ListModulesResponse_Module] {
        &self.modules
    }
    pub fn clear_modules(&mut self) {
        self.modules.clear();
    }

    // Param is passed by value, moved
    pub fn set_modules(&mut self, v: ::protobuf::RepeatedField<ListModulesResponse_Module>) {
        self.modules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modules(&mut self) -> &mut ::protobuf::RepeatedField<ListModulesResponse_Module> {
        &mut self.modules
    }

    // Take field
    pub fn take_modules(&mut self) -> ::protobuf::RepeatedField<ListModulesResponse_Module> {
        ::std::mem::replace(&mut self.modules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListModulesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.modules {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modules)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.modules {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModulesResponse {
        ListModulesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListModulesResponse| &m.error,
                    |m: &mut ListModulesResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<ListModulesResponse_Module>,
                >(
                    "modules",
                    |m: &ListModulesResponse| &m.modules,
                    |m: &mut ListModulesResponse| &mut m.modules,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModulesResponse>(
                "ListModulesResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListModulesResponse {
        static instance: ::protobuf::rt::LazyV2<ListModulesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModulesResponse::new)
    }
}

impl ::protobuf::Clear for ListModulesResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.modules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListModulesResponse_Module {
    // message fields
    pub name: ::std::string::String,
    pub mclass: ::std::string::String,
    pub desc: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModulesResponse_Module {
    fn default() -> &'a ListModulesResponse_Module {
        <ListModulesResponse_Module as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesResponse_Module {
    pub fn new() -> ListModulesResponse_Module {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string mclass = 2;

    pub fn get_mclass(&self) -> &str {
        &self.mclass
    }
    pub fn clear_mclass(&mut self) {
        self.mclass.clear();
    }

    // Param is passed by value, moved
    pub fn set_mclass(&mut self, v: ::std::string::String) {
        self.mclass = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mclass(&mut self) -> &mut ::std::string::String {
        &mut self.mclass
    }

    // Take field
    pub fn take_mclass(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mclass, ::std::string::String::new())
    }

    // string desc = 3;

    pub fn get_desc(&self) -> &str {
        &self.desc
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        &mut self.desc
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListModulesResponse_Module {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mclass,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.desc,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.mclass.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mclass);
        }
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.desc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.mclass.is_empty() {
            os.write_string(2, &self.mclass)?;
        }
        if !self.desc.is_empty() {
            os.write_string(3, &self.desc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModulesResponse_Module {
        ListModulesResponse_Module::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &ListModulesResponse_Module| &m.name,
                |m: &mut ListModulesResponse_Module| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mclass",
                |m: &ListModulesResponse_Module| &m.mclass,
                |m: &mut ListModulesResponse_Module| &mut m.mclass,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "desc",
                |m: &ListModulesResponse_Module| &m.desc,
                |m: &mut ListModulesResponse_Module| &mut m.desc,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModulesResponse_Module>(
                "ListModulesResponse.Module",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListModulesResponse_Module {
        static instance: ::protobuf::rt::LazyV2<ListModulesResponse_Module> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModulesResponse_Module::new)
    }
}

impl ::protobuf::Clear for ListModulesResponse_Module {
    fn clear(&mut self) {
        self.name.clear();
        self.mclass.clear();
        self.desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModulesResponse_Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesResponse_Module {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CreateModuleRequest {
    // message fields
    pub name: ::std::string::String,
    pub mclass: ::std::string::String,
    pub arg: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateModuleRequest {
    fn default() -> &'a CreateModuleRequest {
        <CreateModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateModuleRequest {
    pub fn new() -> CreateModuleRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string mclass = 2;

    pub fn get_mclass(&self) -> &str {
        &self.mclass
    }
    pub fn clear_mclass(&mut self) {
        self.mclass.clear();
    }

    // Param is passed by value, moved
    pub fn set_mclass(&mut self, v: ::std::string::String) {
        self.mclass = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mclass(&mut self) -> &mut ::std::string::String {
        &mut self.mclass
    }

    // Take field
    pub fn take_mclass(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mclass, ::std::string::String::new())
    }

    // .google.protobuf.Any arg = 3;

    pub fn get_arg(&self) -> &::protobuf::well_known_types::Any {
        self.arg.as_ref().unwrap_or_else(|| {
            <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::protobuf::well_known_types::Any) {
        self.arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::protobuf::well_known_types::Any {
        self.arg
            .take()
            .unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for CreateModuleRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mclass,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arg)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.mclass.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mclass);
        }
        if let Some(ref v) = self.arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.mclass.is_empty() {
            os.write_string(2, &self.mclass)?;
        }
        if let Some(ref v) = self.arg.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateModuleRequest {
        CreateModuleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &CreateModuleRequest| &m.name,
                |m: &mut CreateModuleRequest| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mclass",
                |m: &CreateModuleRequest| &m.mclass,
                |m: &mut CreateModuleRequest| &mut m.mclass,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>,
                >(
                    "arg",
                    |m: &CreateModuleRequest| &m.arg,
                    |m: &mut CreateModuleRequest| &mut m.arg,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateModuleRequest>(
                "CreateModuleRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CreateModuleRequest {
        static instance: ::protobuf::rt::LazyV2<CreateModuleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateModuleRequest::new)
    }
}

impl ::protobuf::Clear for CreateModuleRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.mclass.clear();
        self.arg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateModuleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CreateModuleResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateModuleResponse {
    fn default() -> &'a CreateModuleResponse {
        <CreateModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateModuleResponse {
    pub fn new() -> CreateModuleResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateModuleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateModuleResponse {
        CreateModuleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &CreateModuleResponse| &m.error,
                    |m: &mut CreateModuleResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &CreateModuleResponse| &m.name,
                |m: &mut CreateModuleResponse| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateModuleResponse>(
                "CreateModuleResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CreateModuleResponse {
        static instance: ::protobuf::rt::LazyV2<CreateModuleResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateModuleResponse::new)
    }
}

impl ::protobuf::Clear for CreateModuleResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateModuleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DestroyModuleRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DestroyModuleRequest {
    fn default() -> &'a DestroyModuleRequest {
        <DestroyModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl DestroyModuleRequest {
    pub fn new() -> DestroyModuleRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DestroyModuleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DestroyModuleRequest {
        DestroyModuleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &DestroyModuleRequest| &m.name,
                |m: &mut DestroyModuleRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DestroyModuleRequest>(
                "DestroyModuleRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DestroyModuleRequest {
        static instance: ::protobuf::rt::LazyV2<DestroyModuleRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(DestroyModuleRequest::new)
    }
}

impl ::protobuf::Clear for DestroyModuleRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DestroyModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DestroyModuleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetModuleInfoRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModuleInfoRequest {
    fn default() -> &'a GetModuleInfoRequest {
        <GetModuleInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleInfoRequest {
    pub fn new() -> GetModuleInfoRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetModuleInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModuleInfoRequest {
        GetModuleInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetModuleInfoRequest| &m.name,
                |m: &mut GetModuleInfoRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModuleInfoRequest>(
                "GetModuleInfoRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetModuleInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetModuleInfoRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModuleInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetModuleInfoRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModuleInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetModuleInfoResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub name: ::std::string::String,
    pub mclass: ::std::string::String,
    pub desc: ::std::string::String,
    pub igates: ::protobuf::RepeatedField<GetModuleInfoResponse_IGate>,
    pub ogates: ::protobuf::RepeatedField<GetModuleInfoResponse_OGate>,
    pub metadata: ::protobuf::RepeatedField<GetModuleInfoResponse_Attribute>,
    pub deadends: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModuleInfoResponse {
    fn default() -> &'a GetModuleInfoResponse {
        <GetModuleInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleInfoResponse {
    pub fn new() -> GetModuleInfoResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string mclass = 3;

    pub fn get_mclass(&self) -> &str {
        &self.mclass
    }
    pub fn clear_mclass(&mut self) {
        self.mclass.clear();
    }

    // Param is passed by value, moved
    pub fn set_mclass(&mut self, v: ::std::string::String) {
        self.mclass = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mclass(&mut self) -> &mut ::std::string::String {
        &mut self.mclass
    }

    // Take field
    pub fn take_mclass(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mclass, ::std::string::String::new())
    }

    // string desc = 4;

    pub fn get_desc(&self) -> &str {
        &self.desc
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        &mut self.desc
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desc, ::std::string::String::new())
    }

    // repeated .bess.pb.GetModuleInfoResponse.IGate igates = 6;

    pub fn get_igates(&self) -> &[GetModuleInfoResponse_IGate] {
        &self.igates
    }
    pub fn clear_igates(&mut self) {
        self.igates.clear();
    }

    // Param is passed by value, moved
    pub fn set_igates(&mut self, v: ::protobuf::RepeatedField<GetModuleInfoResponse_IGate>) {
        self.igates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_igates(&mut self) -> &mut ::protobuf::RepeatedField<GetModuleInfoResponse_IGate> {
        &mut self.igates
    }

    // Take field
    pub fn take_igates(&mut self) -> ::protobuf::RepeatedField<GetModuleInfoResponse_IGate> {
        ::std::mem::replace(&mut self.igates, ::protobuf::RepeatedField::new())
    }

    // repeated .bess.pb.GetModuleInfoResponse.OGate ogates = 7;

    pub fn get_ogates(&self) -> &[GetModuleInfoResponse_OGate] {
        &self.ogates
    }
    pub fn clear_ogates(&mut self) {
        self.ogates.clear();
    }

    // Param is passed by value, moved
    pub fn set_ogates(&mut self, v: ::protobuf::RepeatedField<GetModuleInfoResponse_OGate>) {
        self.ogates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ogates(&mut self) -> &mut ::protobuf::RepeatedField<GetModuleInfoResponse_OGate> {
        &mut self.ogates
    }

    // Take field
    pub fn take_ogates(&mut self) -> ::protobuf::RepeatedField<GetModuleInfoResponse_OGate> {
        ::std::mem::replace(&mut self.ogates, ::protobuf::RepeatedField::new())
    }

    // repeated .bess.pb.GetModuleInfoResponse.Attribute metadata = 8;

    pub fn get_metadata(&self) -> &[GetModuleInfoResponse_Attribute] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<GetModuleInfoResponse_Attribute>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<GetModuleInfoResponse_Attribute> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<GetModuleInfoResponse_Attribute> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }

    // uint64 deadends = 9;

    pub fn get_deadends(&self) -> u64 {
        self.deadends
    }
    pub fn clear_deadends(&mut self) {
        self.deadends = 0;
    }

    // Param is passed by value, moved
    pub fn set_deadends(&mut self, v: u64) {
        self.deadends = v;
    }
}

impl ::protobuf::Message for GetModuleInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.igates {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.ogates {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mclass,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.desc,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.igates)?;
                }
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ogates)?;
                }
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.deadends = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.mclass.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mclass);
        }
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.desc);
        }
        for value in &self.igates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ogates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.deadends != 0 {
            my_size += ::protobuf::rt::value_size(
                9,
                self.deadends,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.mclass.is_empty() {
            os.write_string(3, &self.mclass)?;
        }
        if !self.desc.is_empty() {
            os.write_string(4, &self.desc)?;
        }
        for v in &self.igates {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ogates {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metadata {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.deadends != 0 {
            os.write_uint64(9, self.deadends)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModuleInfoResponse {
        GetModuleInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &GetModuleInfoResponse| &m.error,
                    |m: &mut GetModuleInfoResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetModuleInfoResponse| &m.name,
                |m: &mut GetModuleInfoResponse| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mclass",
                |m: &GetModuleInfoResponse| &m.mclass,
                |m: &mut GetModuleInfoResponse| &mut m.mclass,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "desc",
                |m: &GetModuleInfoResponse| &m.desc,
                |m: &mut GetModuleInfoResponse| &mut m.desc,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GetModuleInfoResponse_IGate>,
                >(
                    "igates",
                    |m: &GetModuleInfoResponse| &m.igates,
                    |m: &mut GetModuleInfoResponse| &mut m.igates,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GetModuleInfoResponse_OGate>,
                >(
                    "ogates",
                    |m: &GetModuleInfoResponse| &m.ogates,
                    |m: &mut GetModuleInfoResponse| &mut m.ogates,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GetModuleInfoResponse_Attribute>,
                >(
                    "metadata",
                    |m: &GetModuleInfoResponse| &m.metadata,
                    |m: &mut GetModuleInfoResponse| &mut m.metadata,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "deadends",
                |m: &GetModuleInfoResponse| &m.deadends,
                |m: &mut GetModuleInfoResponse| &mut m.deadends,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModuleInfoResponse>(
                "GetModuleInfoResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetModuleInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetModuleInfoResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModuleInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetModuleInfoResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.name.clear();
        self.mclass.clear();
        self.desc.clear();
        self.igates.clear();
        self.ogates.clear();
        self.metadata.clear();
        self.deadends = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModuleInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetModuleInfoResponse_GateHook {
    // message fields
    pub class_name: ::std::string::String,
    pub hook_name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModuleInfoResponse_GateHook {
    fn default() -> &'a GetModuleInfoResponse_GateHook {
        <GetModuleInfoResponse_GateHook as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleInfoResponse_GateHook {
    pub fn new() -> GetModuleInfoResponse_GateHook {
        ::std::default::Default::default()
    }

    // string class_name = 1;

    pub fn get_class_name(&self) -> &str {
        &self.class_name
    }
    pub fn clear_class_name(&mut self) {
        self.class_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: ::std::string::String) {
        self.class_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
        &mut self.class_name
    }

    // Take field
    pub fn take_class_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.class_name, ::std::string::String::new())
    }

    // string hook_name = 2;

    pub fn get_hook_name(&self) -> &str {
        &self.hook_name
    }
    pub fn clear_hook_name(&mut self) {
        self.hook_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_hook_name(&mut self, v: ::std::string::String) {
        self.hook_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook_name(&mut self) -> &mut ::std::string::String {
        &mut self.hook_name
    }

    // Take field
    pub fn take_hook_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hook_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetModuleInfoResponse_GateHook {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.class_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.hook_name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.class_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_name);
        }
        if !self.hook_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hook_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.class_name.is_empty() {
            os.write_string(1, &self.class_name)?;
        }
        if !self.hook_name.is_empty() {
            os.write_string(2, &self.hook_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModuleInfoResponse_GateHook {
        GetModuleInfoResponse_GateHook::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "class_name",
                |m: &GetModuleInfoResponse_GateHook| &m.class_name,
                |m: &mut GetModuleInfoResponse_GateHook| &mut m.class_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "hook_name",
                |m: &GetModuleInfoResponse_GateHook| &m.hook_name,
                |m: &mut GetModuleInfoResponse_GateHook| &mut m.hook_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModuleInfoResponse_GateHook>(
                "GetModuleInfoResponse.GateHook",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetModuleInfoResponse_GateHook {
        static instance: ::protobuf::rt::LazyV2<GetModuleInfoResponse_GateHook> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModuleInfoResponse_GateHook::new)
    }
}

impl ::protobuf::Clear for GetModuleInfoResponse_GateHook {
    fn clear(&mut self) {
        self.class_name.clear();
        self.hook_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModuleInfoResponse_GateHook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleInfoResponse_GateHook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetModuleInfoResponse_IGate {
    // message fields
    pub igate: u64,
    pub ogates: ::protobuf::RepeatedField<GetModuleInfoResponse_IGate_OGate>,
    pub cnt: u64,
    pub pkts: u64,
    pub bytes: u64,
    pub timestamp: f64,
    pub gatehooks: ::protobuf::RepeatedField<GetModuleInfoResponse_GateHook>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModuleInfoResponse_IGate {
    fn default() -> &'a GetModuleInfoResponse_IGate {
        <GetModuleInfoResponse_IGate as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleInfoResponse_IGate {
    pub fn new() -> GetModuleInfoResponse_IGate {
        ::std::default::Default::default()
    }

    // uint64 igate = 1;

    pub fn get_igate(&self) -> u64 {
        self.igate
    }
    pub fn clear_igate(&mut self) {
        self.igate = 0;
    }

    // Param is passed by value, moved
    pub fn set_igate(&mut self, v: u64) {
        self.igate = v;
    }

    // repeated .bess.pb.GetModuleInfoResponse.IGate.OGate ogates = 2;

    pub fn get_ogates(&self) -> &[GetModuleInfoResponse_IGate_OGate] {
        &self.ogates
    }
    pub fn clear_ogates(&mut self) {
        self.ogates.clear();
    }

    // Param is passed by value, moved
    pub fn set_ogates(&mut self, v: ::protobuf::RepeatedField<GetModuleInfoResponse_IGate_OGate>) {
        self.ogates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ogates(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<GetModuleInfoResponse_IGate_OGate> {
        &mut self.ogates
    }

    // Take field
    pub fn take_ogates(&mut self) -> ::protobuf::RepeatedField<GetModuleInfoResponse_IGate_OGate> {
        ::std::mem::replace(&mut self.ogates, ::protobuf::RepeatedField::new())
    }

    // uint64 cnt = 3;

    pub fn get_cnt(&self) -> u64 {
        self.cnt
    }
    pub fn clear_cnt(&mut self) {
        self.cnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_cnt(&mut self, v: u64) {
        self.cnt = v;
    }

    // uint64 pkts = 4;

    pub fn get_pkts(&self) -> u64 {
        self.pkts
    }
    pub fn clear_pkts(&mut self) {
        self.pkts = 0;
    }

    // Param is passed by value, moved
    pub fn set_pkts(&mut self, v: u64) {
        self.pkts = v;
    }

    // uint64 bytes = 5;

    pub fn get_bytes(&self) -> u64 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = v;
    }

    // double timestamp = 6;

    pub fn get_timestamp(&self) -> f64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0.;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = v;
    }

    // repeated .bess.pb.GetModuleInfoResponse.GateHook gatehooks = 8;

    pub fn get_gatehooks(&self) -> &[GetModuleInfoResponse_GateHook] {
        &self.gatehooks
    }
    pub fn clear_gatehooks(&mut self) {
        self.gatehooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_gatehooks(&mut self, v: ::protobuf::RepeatedField<GetModuleInfoResponse_GateHook>) {
        self.gatehooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gatehooks(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<GetModuleInfoResponse_GateHook> {
        &mut self.gatehooks
    }

    // Take field
    pub fn take_gatehooks(&mut self) -> ::protobuf::RepeatedField<GetModuleInfoResponse_GateHook> {
        ::std::mem::replace(&mut self.gatehooks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetModuleInfoResponse_IGate {
    fn is_initialized(&self) -> bool {
        for v in &self.ogates {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.gatehooks {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.igate = tmp;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ogates)?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.cnt = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkts = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.timestamp = tmp;
                }
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gatehooks)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.igate != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.igate, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ogates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.cnt != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.cnt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pkts != 0 {
            my_size +=
                ::protobuf::rt::value_size(4, self.pkts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes != 0 {
            my_size +=
                ::protobuf::rt::value_size(5, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0. {
            my_size += 9;
        }
        for value in &self.gatehooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.igate != 0 {
            os.write_uint64(1, self.igate)?;
        }
        for v in &self.ogates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.cnt != 0 {
            os.write_uint64(3, self.cnt)?;
        }
        if self.pkts != 0 {
            os.write_uint64(4, self.pkts)?;
        }
        if self.bytes != 0 {
            os.write_uint64(5, self.bytes)?;
        }
        if self.timestamp != 0. {
            os.write_double(6, self.timestamp)?;
        }
        for v in &self.gatehooks {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModuleInfoResponse_IGate {
        GetModuleInfoResponse_IGate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "igate",
                |m: &GetModuleInfoResponse_IGate| &m.igate,
                |m: &mut GetModuleInfoResponse_IGate| &mut m.igate,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GetModuleInfoResponse_IGate_OGate>,
                >(
                    "ogates",
                    |m: &GetModuleInfoResponse_IGate| &m.ogates,
                    |m: &mut GetModuleInfoResponse_IGate| &mut m.ogates,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "cnt",
                |m: &GetModuleInfoResponse_IGate| &m.cnt,
                |m: &mut GetModuleInfoResponse_IGate| &mut m.cnt,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "pkts",
                |m: &GetModuleInfoResponse_IGate| &m.pkts,
                |m: &mut GetModuleInfoResponse_IGate| &mut m.pkts,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "bytes",
                |m: &GetModuleInfoResponse_IGate| &m.bytes,
                |m: &mut GetModuleInfoResponse_IGate| &mut m.bytes,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "timestamp",
                |m: &GetModuleInfoResponse_IGate| &m.timestamp,
                |m: &mut GetModuleInfoResponse_IGate| &mut m.timestamp,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GetModuleInfoResponse_GateHook>,
                >(
                    "gatehooks",
                    |m: &GetModuleInfoResponse_IGate| &m.gatehooks,
                    |m: &mut GetModuleInfoResponse_IGate| &mut m.gatehooks,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModuleInfoResponse_IGate>(
                "GetModuleInfoResponse.IGate",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetModuleInfoResponse_IGate {
        static instance: ::protobuf::rt::LazyV2<GetModuleInfoResponse_IGate> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModuleInfoResponse_IGate::new)
    }
}

impl ::protobuf::Clear for GetModuleInfoResponse_IGate {
    fn clear(&mut self) {
        self.igate = 0;
        self.ogates.clear();
        self.cnt = 0;
        self.pkts = 0;
        self.bytes = 0;
        self.timestamp = 0.;
        self.gatehooks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModuleInfoResponse_IGate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleInfoResponse_IGate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetModuleInfoResponse_IGate_OGate {
    // message fields
    pub ogate: u64,
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModuleInfoResponse_IGate_OGate {
    fn default() -> &'a GetModuleInfoResponse_IGate_OGate {
        <GetModuleInfoResponse_IGate_OGate as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleInfoResponse_IGate_OGate {
    pub fn new() -> GetModuleInfoResponse_IGate_OGate {
        ::std::default::Default::default()
    }

    // uint64 ogate = 1;

    pub fn get_ogate(&self) -> u64 {
        self.ogate
    }
    pub fn clear_ogate(&mut self) {
        self.ogate = 0;
    }

    // Param is passed by value, moved
    pub fn set_ogate(&mut self, v: u64) {
        self.ogate = v;
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetModuleInfoResponse_IGate_OGate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.ogate = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ogate != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.ogate, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.ogate != 0 {
            os.write_uint64(1, self.ogate)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModuleInfoResponse_IGate_OGate {
        GetModuleInfoResponse_IGate_OGate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ogate",
                |m: &GetModuleInfoResponse_IGate_OGate| { &m.ogate },
                |m: &mut GetModuleInfoResponse_IGate_OGate| { &mut m.ogate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetModuleInfoResponse_IGate_OGate| { &m.name },
                |m: &mut GetModuleInfoResponse_IGate_OGate| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModuleInfoResponse_IGate_OGate>(
                "GetModuleInfoResponse.IGate.OGate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModuleInfoResponse_IGate_OGate {
        static instance: ::protobuf::rt::LazyV2<GetModuleInfoResponse_IGate_OGate> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModuleInfoResponse_IGate_OGate::new)
    }
}

impl ::protobuf::Clear for GetModuleInfoResponse_IGate_OGate {
    fn clear(&mut self) {
        self.ogate = 0;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModuleInfoResponse_IGate_OGate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleInfoResponse_IGate_OGate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetModuleInfoResponse_OGate {
    // message fields
    pub ogate: u64,
    pub cnt: u64,
    pub pkts: u64,
    pub bytes: u64,
    pub timestamp: f64,
    pub name: ::std::string::String,
    pub igate: u64,
    pub gatehooks: ::protobuf::RepeatedField<GetModuleInfoResponse_GateHook>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModuleInfoResponse_OGate {
    fn default() -> &'a GetModuleInfoResponse_OGate {
        <GetModuleInfoResponse_OGate as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleInfoResponse_OGate {
    pub fn new() -> GetModuleInfoResponse_OGate {
        ::std::default::Default::default()
    }

    // uint64 ogate = 1;

    pub fn get_ogate(&self) -> u64 {
        self.ogate
    }
    pub fn clear_ogate(&mut self) {
        self.ogate = 0;
    }

    // Param is passed by value, moved
    pub fn set_ogate(&mut self, v: u64) {
        self.ogate = v;
    }

    // uint64 cnt = 2;

    pub fn get_cnt(&self) -> u64 {
        self.cnt
    }
    pub fn clear_cnt(&mut self) {
        self.cnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_cnt(&mut self, v: u64) {
        self.cnt = v;
    }

    // uint64 pkts = 3;

    pub fn get_pkts(&self) -> u64 {
        self.pkts
    }
    pub fn clear_pkts(&mut self) {
        self.pkts = 0;
    }

    // Param is passed by value, moved
    pub fn set_pkts(&mut self, v: u64) {
        self.pkts = v;
    }

    // uint64 bytes = 4;

    pub fn get_bytes(&self) -> u64 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = v;
    }

    // double timestamp = 5;

    pub fn get_timestamp(&self) -> f64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0.;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = v;
    }

    // string name = 6;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 igate = 7;

    pub fn get_igate(&self) -> u64 {
        self.igate
    }
    pub fn clear_igate(&mut self) {
        self.igate = 0;
    }

    // Param is passed by value, moved
    pub fn set_igate(&mut self, v: u64) {
        self.igate = v;
    }

    // repeated .bess.pb.GetModuleInfoResponse.GateHook gatehooks = 9;

    pub fn get_gatehooks(&self) -> &[GetModuleInfoResponse_GateHook] {
        &self.gatehooks
    }
    pub fn clear_gatehooks(&mut self) {
        self.gatehooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_gatehooks(&mut self, v: ::protobuf::RepeatedField<GetModuleInfoResponse_GateHook>) {
        self.gatehooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gatehooks(
        &mut self,
    ) -> &mut ::protobuf::RepeatedField<GetModuleInfoResponse_GateHook> {
        &mut self.gatehooks
    }

    // Take field
    pub fn take_gatehooks(&mut self) -> ::protobuf::RepeatedField<GetModuleInfoResponse_GateHook> {
        ::std::mem::replace(&mut self.gatehooks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetModuleInfoResponse_OGate {
    fn is_initialized(&self) -> bool {
        for v in &self.gatehooks {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.ogate = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.cnt = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkts = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.timestamp = tmp;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.igate = tmp;
                }
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gatehooks)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ogate != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.ogate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cnt != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.cnt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pkts != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.pkts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes != 0 {
            my_size +=
                ::protobuf::rt::value_size(4, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0. {
            my_size += 9;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if self.igate != 0 {
            my_size +=
                ::protobuf::rt::value_size(7, self.igate, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.gatehooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.ogate != 0 {
            os.write_uint64(1, self.ogate)?;
        }
        if self.cnt != 0 {
            os.write_uint64(2, self.cnt)?;
        }
        if self.pkts != 0 {
            os.write_uint64(3, self.pkts)?;
        }
        if self.bytes != 0 {
            os.write_uint64(4, self.bytes)?;
        }
        if self.timestamp != 0. {
            os.write_double(5, self.timestamp)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if self.igate != 0 {
            os.write_uint64(7, self.igate)?;
        }
        for v in &self.gatehooks {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModuleInfoResponse_OGate {
        GetModuleInfoResponse_OGate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "ogate",
                |m: &GetModuleInfoResponse_OGate| &m.ogate,
                |m: &mut GetModuleInfoResponse_OGate| &mut m.ogate,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "cnt",
                |m: &GetModuleInfoResponse_OGate| &m.cnt,
                |m: &mut GetModuleInfoResponse_OGate| &mut m.cnt,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "pkts",
                |m: &GetModuleInfoResponse_OGate| &m.pkts,
                |m: &mut GetModuleInfoResponse_OGate| &mut m.pkts,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "bytes",
                |m: &GetModuleInfoResponse_OGate| &m.bytes,
                |m: &mut GetModuleInfoResponse_OGate| &mut m.bytes,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeDouble,
            >(
                "timestamp",
                |m: &GetModuleInfoResponse_OGate| &m.timestamp,
                |m: &mut GetModuleInfoResponse_OGate| &mut m.timestamp,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetModuleInfoResponse_OGate| &m.name,
                |m: &mut GetModuleInfoResponse_OGate| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "igate",
                |m: &GetModuleInfoResponse_OGate| &m.igate,
                |m: &mut GetModuleInfoResponse_OGate| &mut m.igate,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GetModuleInfoResponse_GateHook>,
                >(
                    "gatehooks",
                    |m: &GetModuleInfoResponse_OGate| &m.gatehooks,
                    |m: &mut GetModuleInfoResponse_OGate| &mut m.gatehooks,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModuleInfoResponse_OGate>(
                "GetModuleInfoResponse.OGate",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetModuleInfoResponse_OGate {
        static instance: ::protobuf::rt::LazyV2<GetModuleInfoResponse_OGate> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModuleInfoResponse_OGate::new)
    }
}

impl ::protobuf::Clear for GetModuleInfoResponse_OGate {
    fn clear(&mut self) {
        self.ogate = 0;
        self.cnt = 0;
        self.pkts = 0;
        self.bytes = 0;
        self.timestamp = 0.;
        self.name.clear();
        self.igate = 0;
        self.gatehooks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModuleInfoResponse_OGate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleInfoResponse_OGate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetModuleInfoResponse_Attribute {
    // message fields
    pub name: ::std::string::String,
    pub size: u64,
    pub mode: ::std::string::String,
    pub offset: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModuleInfoResponse_Attribute {
    fn default() -> &'a GetModuleInfoResponse_Attribute {
        <GetModuleInfoResponse_Attribute as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleInfoResponse_Attribute {
    pub fn new() -> GetModuleInfoResponse_Attribute {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 size = 2;

    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // string mode = 3;

    pub fn get_mode(&self) -> &str {
        &self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ::std::string::String) {
        self.mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut ::std::string::String {
        &mut self.mode
    }

    // Take field
    pub fn take_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mode, ::std::string::String::new())
    }

    // int64 offset = 4;

    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }
}

impl ::protobuf::Message for GetModuleInfoResponse_Attribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.mode,
                    )?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.size != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mode);
        }
        if self.offset != 0 {
            my_size +=
                ::protobuf::rt::value_size(4, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.size != 0 {
            os.write_uint64(2, self.size)?;
        }
        if !self.mode.is_empty() {
            os.write_string(3, &self.mode)?;
        }
        if self.offset != 0 {
            os.write_int64(4, self.offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModuleInfoResponse_Attribute {
        GetModuleInfoResponse_Attribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetModuleInfoResponse_Attribute| &m.name,
                |m: &mut GetModuleInfoResponse_Attribute| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "size",
                |m: &GetModuleInfoResponse_Attribute| &m.size,
                |m: &mut GetModuleInfoResponse_Attribute| &mut m.size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "mode",
                |m: &GetModuleInfoResponse_Attribute| &m.mode,
                |m: &mut GetModuleInfoResponse_Attribute| &mut m.mode,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "offset",
                |m: &GetModuleInfoResponse_Attribute| &m.offset,
                |m: &mut GetModuleInfoResponse_Attribute| &mut m.offset,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModuleInfoResponse_Attribute>(
                "GetModuleInfoResponse.Attribute",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetModuleInfoResponse_Attribute {
        static instance: ::protobuf::rt::LazyV2<GetModuleInfoResponse_Attribute> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModuleInfoResponse_Attribute::new)
    }
}

impl ::protobuf::Clear for GetModuleInfoResponse_Attribute {
    fn clear(&mut self) {
        self.name.clear();
        self.size = 0;
        self.mode.clear();
        self.offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModuleInfoResponse_Attribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleInfoResponse_Attribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ConnectModulesRequest {
    // message fields
    pub m1: ::std::string::String,
    pub m2: ::std::string::String,
    pub ogate: u64,
    pub igate: u64,
    pub skip_default_hooks: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectModulesRequest {
    fn default() -> &'a ConnectModulesRequest {
        <ConnectModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectModulesRequest {
    pub fn new() -> ConnectModulesRequest {
        ::std::default::Default::default()
    }

    // string m1 = 1;

    pub fn get_m1(&self) -> &str {
        &self.m1
    }
    pub fn clear_m1(&mut self) {
        self.m1.clear();
    }

    // Param is passed by value, moved
    pub fn set_m1(&mut self, v: ::std::string::String) {
        self.m1 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m1(&mut self) -> &mut ::std::string::String {
        &mut self.m1
    }

    // Take field
    pub fn take_m1(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.m1, ::std::string::String::new())
    }

    // string m2 = 2;

    pub fn get_m2(&self) -> &str {
        &self.m2
    }
    pub fn clear_m2(&mut self) {
        self.m2.clear();
    }

    // Param is passed by value, moved
    pub fn set_m2(&mut self, v: ::std::string::String) {
        self.m2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_m2(&mut self) -> &mut ::std::string::String {
        &mut self.m2
    }

    // Take field
    pub fn take_m2(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.m2, ::std::string::String::new())
    }

    // uint64 ogate = 3;

    pub fn get_ogate(&self) -> u64 {
        self.ogate
    }
    pub fn clear_ogate(&mut self) {
        self.ogate = 0;
    }

    // Param is passed by value, moved
    pub fn set_ogate(&mut self, v: u64) {
        self.ogate = v;
    }

    // uint64 igate = 4;

    pub fn get_igate(&self) -> u64 {
        self.igate
    }
    pub fn clear_igate(&mut self) {
        self.igate = 0;
    }

    // Param is passed by value, moved
    pub fn set_igate(&mut self, v: u64) {
        self.igate = v;
    }

    // bool skip_default_hooks = 5;

    pub fn get_skip_default_hooks(&self) -> bool {
        self.skip_default_hooks
    }
    pub fn clear_skip_default_hooks(&mut self) {
        self.skip_default_hooks = false;
    }

    // Param is passed by value, moved
    pub fn set_skip_default_hooks(&mut self, v: bool) {
        self.skip_default_hooks = v;
    }
}

impl ::protobuf::Message for ConnectModulesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.m1)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.m2)?;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.ogate = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.igate = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_default_hooks = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.m1.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.m1);
        }
        if !self.m2.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.m2);
        }
        if self.ogate != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.ogate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.igate != 0 {
            my_size +=
                ::protobuf::rt::value_size(4, self.igate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.skip_default_hooks != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.m1.is_empty() {
            os.write_string(1, &self.m1)?;
        }
        if !self.m2.is_empty() {
            os.write_string(2, &self.m2)?;
        }
        if self.ogate != 0 {
            os.write_uint64(3, self.ogate)?;
        }
        if self.igate != 0 {
            os.write_uint64(4, self.igate)?;
        }
        if self.skip_default_hooks != false {
            os.write_bool(5, self.skip_default_hooks)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectModulesRequest {
        ConnectModulesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "m1",
                |m: &ConnectModulesRequest| &m.m1,
                |m: &mut ConnectModulesRequest| &mut m.m1,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "m2",
                |m: &ConnectModulesRequest| &m.m2,
                |m: &mut ConnectModulesRequest| &mut m.m2,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "ogate",
                |m: &ConnectModulesRequest| &m.ogate,
                |m: &mut ConnectModulesRequest| &mut m.ogate,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "igate",
                |m: &ConnectModulesRequest| &m.igate,
                |m: &mut ConnectModulesRequest| &mut m.igate,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "skip_default_hooks",
                |m: &ConnectModulesRequest| &m.skip_default_hooks,
                |m: &mut ConnectModulesRequest| &mut m.skip_default_hooks,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectModulesRequest>(
                "ConnectModulesRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ConnectModulesRequest {
        static instance: ::protobuf::rt::LazyV2<ConnectModulesRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectModulesRequest::new)
    }
}

impl ::protobuf::Clear for ConnectModulesRequest {
    fn clear(&mut self) {
        self.m1.clear();
        self.m2.clear();
        self.ogate = 0;
        self.igate = 0;
        self.skip_default_hooks = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectModulesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DisconnectModulesRequest {
    // message fields
    pub name: ::std::string::String,
    pub ogate: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectModulesRequest {
    fn default() -> &'a DisconnectModulesRequest {
        <DisconnectModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectModulesRequest {
    pub fn new() -> DisconnectModulesRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 ogate = 2;

    pub fn get_ogate(&self) -> u64 {
        self.ogate
    }
    pub fn clear_ogate(&mut self) {
        self.ogate = 0;
    }

    // Param is passed by value, moved
    pub fn set_ogate(&mut self, v: u64) {
        self.ogate = v;
    }
}

impl ::protobuf::Message for DisconnectModulesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.ogate = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.ogate != 0 {
            my_size +=
                ::protobuf::rt::value_size(2, self.ogate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.ogate != 0 {
            os.write_uint64(2, self.ogate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectModulesRequest {
        DisconnectModulesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &DisconnectModulesRequest| &m.name,
                |m: &mut DisconnectModulesRequest| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "ogate",
                |m: &DisconnectModulesRequest| &m.ogate,
                |m: &mut DisconnectModulesRequest| &mut m.ogate,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisconnectModulesRequest>(
                "DisconnectModulesRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DisconnectModulesRequest {
        static instance: ::protobuf::rt::LazyV2<DisconnectModulesRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(DisconnectModulesRequest::new)
    }
}

impl ::protobuf::Clear for DisconnectModulesRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.ogate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectModulesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MempoolDump {
    // message fields
    pub socket: i32,
    pub initialized: bool,
    pub mp_size: u32,
    pub mp_cache_size: u32,
    pub mp_element_size: u32,
    pub mp_populated_size: u32,
    pub mp_available_count: u32,
    pub mp_in_use_count: u32,
    pub ring_count: u32,
    pub ring_free_count: u32,
    pub ring_bytes: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MempoolDump {
    fn default() -> &'a MempoolDump {
        <MempoolDump as ::protobuf::Message>::default_instance()
    }
}

impl MempoolDump {
    pub fn new() -> MempoolDump {
        ::std::default::Default::default()
    }

    // int32 socket = 1;

    pub fn get_socket(&self) -> i32 {
        self.socket
    }
    pub fn clear_socket(&mut self) {
        self.socket = 0;
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: i32) {
        self.socket = v;
    }

    // bool initialized = 2;

    pub fn get_initialized(&self) -> bool {
        self.initialized
    }
    pub fn clear_initialized(&mut self) {
        self.initialized = false;
    }

    // Param is passed by value, moved
    pub fn set_initialized(&mut self, v: bool) {
        self.initialized = v;
    }

    // uint32 mp_size = 3;

    pub fn get_mp_size(&self) -> u32 {
        self.mp_size
    }
    pub fn clear_mp_size(&mut self) {
        self.mp_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_mp_size(&mut self, v: u32) {
        self.mp_size = v;
    }

    // uint32 mp_cache_size = 4;

    pub fn get_mp_cache_size(&self) -> u32 {
        self.mp_cache_size
    }
    pub fn clear_mp_cache_size(&mut self) {
        self.mp_cache_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_mp_cache_size(&mut self, v: u32) {
        self.mp_cache_size = v;
    }

    // uint32 mp_element_size = 5;

    pub fn get_mp_element_size(&self) -> u32 {
        self.mp_element_size
    }
    pub fn clear_mp_element_size(&mut self) {
        self.mp_element_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_mp_element_size(&mut self, v: u32) {
        self.mp_element_size = v;
    }

    // uint32 mp_populated_size = 6;

    pub fn get_mp_populated_size(&self) -> u32 {
        self.mp_populated_size
    }
    pub fn clear_mp_populated_size(&mut self) {
        self.mp_populated_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_mp_populated_size(&mut self, v: u32) {
        self.mp_populated_size = v;
    }

    // uint32 mp_available_count = 7;

    pub fn get_mp_available_count(&self) -> u32 {
        self.mp_available_count
    }
    pub fn clear_mp_available_count(&mut self) {
        self.mp_available_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_mp_available_count(&mut self, v: u32) {
        self.mp_available_count = v;
    }

    // uint32 mp_in_use_count = 8;

    pub fn get_mp_in_use_count(&self) -> u32 {
        self.mp_in_use_count
    }
    pub fn clear_mp_in_use_count(&mut self) {
        self.mp_in_use_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_mp_in_use_count(&mut self, v: u32) {
        self.mp_in_use_count = v;
    }

    // uint32 ring_count = 9;

    pub fn get_ring_count(&self) -> u32 {
        self.ring_count
    }
    pub fn clear_ring_count(&mut self) {
        self.ring_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_ring_count(&mut self, v: u32) {
        self.ring_count = v;
    }

    // uint32 ring_free_count = 10;

    pub fn get_ring_free_count(&self) -> u32 {
        self.ring_free_count
    }
    pub fn clear_ring_free_count(&mut self) {
        self.ring_free_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_ring_free_count(&mut self, v: u32) {
        self.ring_free_count = v;
    }

    // uint64 ring_bytes = 11;

    pub fn get_ring_bytes(&self) -> u64 {
        self.ring_bytes
    }
    pub fn clear_ring_bytes(&mut self) {
        self.ring_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_ring_bytes(&mut self, v: u64) {
        self.ring_bytes = v;
    }
}

impl ::protobuf::Message for MempoolDump {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.socket = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.initialized = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.mp_size = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.mp_cache_size = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.mp_element_size = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.mp_populated_size = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.mp_available_count = tmp;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.mp_in_use_count = tmp;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.ring_count = tmp;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint32()?;
                    self.ring_free_count = tmp;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_uint64()?;
                    self.ring_bytes = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.socket != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.socket, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.initialized != false {
            my_size += 2;
        }
        if self.mp_size != 0 {
            my_size += ::protobuf::rt::value_size(
                3,
                self.mp_size,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.mp_cache_size != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.mp_cache_size,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.mp_element_size != 0 {
            my_size += ::protobuf::rt::value_size(
                5,
                self.mp_element_size,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.mp_populated_size != 0 {
            my_size += ::protobuf::rt::value_size(
                6,
                self.mp_populated_size,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.mp_available_count != 0 {
            my_size += ::protobuf::rt::value_size(
                7,
                self.mp_available_count,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.mp_in_use_count != 0 {
            my_size += ::protobuf::rt::value_size(
                8,
                self.mp_in_use_count,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.ring_count != 0 {
            my_size += ::protobuf::rt::value_size(
                9,
                self.ring_count,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.ring_free_count != 0 {
            my_size += ::protobuf::rt::value_size(
                10,
                self.ring_free_count,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.ring_bytes != 0 {
            my_size += ::protobuf::rt::value_size(
                11,
                self.ring_bytes,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.socket != 0 {
            os.write_int32(1, self.socket)?;
        }
        if self.initialized != false {
            os.write_bool(2, self.initialized)?;
        }
        if self.mp_size != 0 {
            os.write_uint32(3, self.mp_size)?;
        }
        if self.mp_cache_size != 0 {
            os.write_uint32(4, self.mp_cache_size)?;
        }
        if self.mp_element_size != 0 {
            os.write_uint32(5, self.mp_element_size)?;
        }
        if self.mp_populated_size != 0 {
            os.write_uint32(6, self.mp_populated_size)?;
        }
        if self.mp_available_count != 0 {
            os.write_uint32(7, self.mp_available_count)?;
        }
        if self.mp_in_use_count != 0 {
            os.write_uint32(8, self.mp_in_use_count)?;
        }
        if self.ring_count != 0 {
            os.write_uint32(9, self.ring_count)?;
        }
        if self.ring_free_count != 0 {
            os.write_uint32(10, self.ring_free_count)?;
        }
        if self.ring_bytes != 0 {
            os.write_uint64(11, self.ring_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MempoolDump {
        MempoolDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "socket",
                |m: &MempoolDump| &m.socket,
                |m: &mut MempoolDump| &mut m.socket,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "initialized",
                |m: &MempoolDump| &m.initialized,
                |m: &mut MempoolDump| &mut m.initialized,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "mp_size",
                |m: &MempoolDump| &m.mp_size,
                |m: &mut MempoolDump| &mut m.mp_size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "mp_cache_size",
                |m: &MempoolDump| &m.mp_cache_size,
                |m: &mut MempoolDump| &mut m.mp_cache_size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "mp_element_size",
                |m: &MempoolDump| &m.mp_element_size,
                |m: &mut MempoolDump| &mut m.mp_element_size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "mp_populated_size",
                |m: &MempoolDump| &m.mp_populated_size,
                |m: &mut MempoolDump| &mut m.mp_populated_size,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "mp_available_count",
                |m: &MempoolDump| &m.mp_available_count,
                |m: &mut MempoolDump| &mut m.mp_available_count,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "mp_in_use_count",
                |m: &MempoolDump| &m.mp_in_use_count,
                |m: &mut MempoolDump| &mut m.mp_in_use_count,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "ring_count",
                |m: &MempoolDump| &m.ring_count,
                |m: &mut MempoolDump| &mut m.ring_count,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "ring_free_count",
                |m: &MempoolDump| &m.ring_free_count,
                |m: &mut MempoolDump| &mut m.ring_free_count,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "ring_bytes",
                |m: &MempoolDump| &m.ring_bytes,
                |m: &mut MempoolDump| &mut m.ring_bytes,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MempoolDump>(
                "MempoolDump",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static MempoolDump {
        static instance: ::protobuf::rt::LazyV2<MempoolDump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MempoolDump::new)
    }
}

impl ::protobuf::Clear for MempoolDump {
    fn clear(&mut self) {
        self.socket = 0;
        self.initialized = false;
        self.mp_size = 0;
        self.mp_cache_size = 0;
        self.mp_element_size = 0;
        self.mp_populated_size = 0;
        self.mp_available_count = 0;
        self.mp_in_use_count = 0;
        self.ring_count = 0;
        self.ring_free_count = 0;
        self.ring_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MempoolDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MempoolDump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DumpMempoolRequest {
    // message fields
    pub socket: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DumpMempoolRequest {
    fn default() -> &'a DumpMempoolRequest {
        <DumpMempoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl DumpMempoolRequest {
    pub fn new() -> DumpMempoolRequest {
        ::std::default::Default::default()
    }

    // int32 socket = 1;

    pub fn get_socket(&self) -> i32 {
        self.socket
    }
    pub fn clear_socket(&mut self) {
        self.socket = 0;
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: i32) {
        self.socket = v;
    }
}

impl ::protobuf::Message for DumpMempoolRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int32()?;
                    self.socket = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.socket != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.socket, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.socket != 0 {
            os.write_int32(1, self.socket)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DumpMempoolRequest {
        DumpMempoolRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "socket",
                |m: &DumpMempoolRequest| &m.socket,
                |m: &mut DumpMempoolRequest| &mut m.socket,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DumpMempoolRequest>(
                "DumpMempoolRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DumpMempoolRequest {
        static instance: ::protobuf::rt::LazyV2<DumpMempoolRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DumpMempoolRequest::new)
    }
}

impl ::protobuf::Clear for DumpMempoolRequest {
    fn clear(&mut self) {
        self.socket = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DumpMempoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DumpMempoolRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DumpMempoolResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub dumps: ::protobuf::RepeatedField<MempoolDump>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DumpMempoolResponse {
    fn default() -> &'a DumpMempoolResponse {
        <DumpMempoolResponse as ::protobuf::Message>::default_instance()
    }
}

impl DumpMempoolResponse {
    pub fn new() -> DumpMempoolResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated .bess.pb.MempoolDump dumps = 2;

    pub fn get_dumps(&self) -> &[MempoolDump] {
        &self.dumps
    }
    pub fn clear_dumps(&mut self) {
        self.dumps.clear();
    }

    // Param is passed by value, moved
    pub fn set_dumps(&mut self, v: ::protobuf::RepeatedField<MempoolDump>) {
        self.dumps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dumps(&mut self) -> &mut ::protobuf::RepeatedField<MempoolDump> {
        &mut self.dumps
    }

    // Take field
    pub fn take_dumps(&mut self) -> ::protobuf::RepeatedField<MempoolDump> {
        ::std::mem::replace(&mut self.dumps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DumpMempoolResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.dumps {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dumps)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.dumps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.dumps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DumpMempoolResponse {
        DumpMempoolResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &DumpMempoolResponse| &m.error,
                    |m: &mut DumpMempoolResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<MempoolDump>,
                >(
                    "dumps",
                    |m: &DumpMempoolResponse| &m.dumps,
                    |m: &mut DumpMempoolResponse| &mut m.dumps,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DumpMempoolResponse>(
                "DumpMempoolResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DumpMempoolResponse {
        static instance: ::protobuf::rt::LazyV2<DumpMempoolResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DumpMempoolResponse::new)
    }
}

impl ::protobuf::Clear for DumpMempoolResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.dumps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DumpMempoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DumpMempoolResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CommandRequest {
    // message fields
    pub name: ::std::string::String,
    pub cmd: ::std::string::String,
    pub arg: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandRequest {
    fn default() -> &'a CommandRequest {
        <CommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl CommandRequest {
    pub fn new() -> CommandRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string cmd = 2;

    pub fn get_cmd(&self) -> &str {
        &self.cmd
    }
    pub fn clear_cmd(&mut self) {
        self.cmd.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::std::string::String) {
        self.cmd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut ::std::string::String {
        &mut self.cmd
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cmd, ::std::string::String::new())
    }

    // .google.protobuf.Any arg = 3;

    pub fn get_arg(&self) -> &::protobuf::well_known_types::Any {
        self.arg.as_ref().unwrap_or_else(|| {
            <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::protobuf::well_known_types::Any) {
        self.arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::protobuf::well_known_types::Any {
        self.arg
            .take()
            .unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for CommandRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cmd)?;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arg)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.cmd.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cmd);
        }
        if let Some(ref v) = self.arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.cmd.is_empty() {
            os.write_string(2, &self.cmd)?;
        }
        if let Some(ref v) = self.arg.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandRequest {
        CommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &CommandRequest| &m.name,
                |m: &mut CommandRequest| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "cmd",
                |m: &CommandRequest| &m.cmd,
                |m: &mut CommandRequest| &mut m.cmd,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>,
                >(
                    "arg",
                    |m: &CommandRequest| &m.arg,
                    |m: &mut CommandRequest| &mut m.arg,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandRequest>(
                "CommandRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CommandRequest {
        static instance: ::protobuf::rt::LazyV2<CommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandRequest::new)
    }
}

impl ::protobuf::Clear for CommandRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.cmd.clear();
        self.arg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CommandResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub data: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandResponse {
    fn default() -> &'a CommandResponse {
        <CommandResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandResponse {
    pub fn new() -> CommandResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // .google.protobuf.Any data = 2;

    pub fn get_data(&self) -> &::protobuf::well_known_types::Any {
        self.data.as_ref().unwrap_or_else(|| {
            <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::well_known_types::Any) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::well_known_types::Any {
        self.data
            .take()
            .unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for CommandResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandResponse {
        CommandResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &CommandResponse| &m.error,
                    |m: &mut CommandResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>,
                >(
                    "data",
                    |m: &CommandResponse| &m.data,
                    |m: &mut CommandResponse| &mut m.data,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandResponse>(
                "CommandResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CommandResponse {
        static instance: ::protobuf::rt::LazyV2<CommandResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandResponse::new)
    }
}

impl ::protobuf::Clear for CommandResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListGateHookClassResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListGateHookClassResponse {
    fn default() -> &'a ListGateHookClassResponse {
        <ListGateHookClassResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListGateHookClassResponse {
    pub fn new() -> ListGateHookClassResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated string names = 2;

    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListGateHookClassResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.names {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGateHookClassResponse {
        ListGateHookClassResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListGateHookClassResponse| &m.error,
                    |m: &mut ListGateHookClassResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "names",
                    |m: &ListGateHookClassResponse| &m.names,
                    |m: &mut ListGateHookClassResponse| &mut m.names,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListGateHookClassResponse>(
                "ListGateHookClassResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListGateHookClassResponse {
        static instance: ::protobuf::rt::LazyV2<ListGateHookClassResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ListGateHookClassResponse::new)
    }
}

impl ::protobuf::Clear for ListGateHookClassResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGateHookClassResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGateHookClassResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetGateHookClassInfoRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetGateHookClassInfoRequest {
    fn default() -> &'a GetGateHookClassInfoRequest {
        <GetGateHookClassInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetGateHookClassInfoRequest {
    pub fn new() -> GetGateHookClassInfoRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetGateHookClassInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetGateHookClassInfoRequest {
        GetGateHookClassInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetGateHookClassInfoRequest| &m.name,
                |m: &mut GetGateHookClassInfoRequest| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetGateHookClassInfoRequest>(
                "GetGateHookClassInfoRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetGateHookClassInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetGateHookClassInfoRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetGateHookClassInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetGateHookClassInfoRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetGateHookClassInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetGateHookClassInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetGateHookClassInfoResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub name: ::std::string::String,
    pub help: ::std::string::String,
    pub cmds: ::protobuf::RepeatedField<::std::string::String>,
    pub cmd_args: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetGateHookClassInfoResponse {
    fn default() -> &'a GetGateHookClassInfoResponse {
        <GetGateHookClassInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetGateHookClassInfoResponse {
    pub fn new() -> GetGateHookClassInfoResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string help = 3;

    pub fn get_help(&self) -> &str {
        &self.help
    }
    pub fn clear_help(&mut self) {
        self.help.clear();
    }

    // Param is passed by value, moved
    pub fn set_help(&mut self, v: ::std::string::String) {
        self.help = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_help(&mut self) -> &mut ::std::string::String {
        &mut self.help
    }

    // Take field
    pub fn take_help(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.help, ::std::string::String::new())
    }

    // repeated string cmds = 4;

    pub fn get_cmds(&self) -> &[::std::string::String] {
        &self.cmds
    }
    pub fn clear_cmds(&mut self) {
        self.cmds.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmds(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cmds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cmds(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cmds
    }

    // Take field
    pub fn take_cmds(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cmds, ::protobuf::RepeatedField::new())
    }

    // repeated string cmd_args = 5;

    pub fn get_cmd_args(&self) -> &[::std::string::String] {
        &self.cmd_args
    }
    pub fn clear_cmd_args(&mut self) {
        self.cmd_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmd_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cmd_args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cmd_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cmd_args
    }

    // Take field
    pub fn take_cmd_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cmd_args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetGateHookClassInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.help,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cmds)?;
                }
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cmd_args)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.help.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.help);
        }
        for value in &self.cmds {
            my_size += ::protobuf::rt::string_size(4, &value);
        }
        for value in &self.cmd_args {
            my_size += ::protobuf::rt::string_size(5, &value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.help.is_empty() {
            os.write_string(3, &self.help)?;
        }
        for v in &self.cmds {
            os.write_string(4, &v)?;
        }
        for v in &self.cmd_args {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetGateHookClassInfoResponse {
        GetGateHookClassInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &GetGateHookClassInfoResponse| &m.error,
                    |m: &mut GetGateHookClassInfoResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &GetGateHookClassInfoResponse| &m.name,
                |m: &mut GetGateHookClassInfoResponse| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "help",
                |m: &GetGateHookClassInfoResponse| &m.help,
                |m: &mut GetGateHookClassInfoResponse| &mut m.help,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cmds",
                    |m: &GetGateHookClassInfoResponse| &m.cmds,
                    |m: &mut GetGateHookClassInfoResponse| &mut m.cmds,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cmd_args",
                    |m: &GetGateHookClassInfoResponse| &m.cmd_args,
                    |m: &mut GetGateHookClassInfoResponse| &mut m.cmd_args,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetGateHookClassInfoResponse>(
                "GetGateHookClassInfoResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GetGateHookClassInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetGateHookClassInfoResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GetGateHookClassInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetGateHookClassInfoResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.name.clear();
        self.help.clear();
        self.cmds.clear();
        self.cmd_args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetGateHookClassInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetGateHookClassInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TrackArg {
    // message fields
    pub bits: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrackArg {
    fn default() -> &'a TrackArg {
        <TrackArg as ::protobuf::Message>::default_instance()
    }
}

impl TrackArg {
    pub fn new() -> TrackArg {
        ::std::default::Default::default()
    }

    // bool bits = 5;

    pub fn get_bits(&self) -> bool {
        self.bits
    }
    pub fn clear_bits(&mut self) {
        self.bits = false;
    }

    // Param is passed by value, moved
    pub fn set_bits(&mut self, v: bool) {
        self.bits = v;
    }
}

impl ::protobuf::Message for TrackArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.bits = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bits != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.bits != false {
            os.write_bool(5, self.bits)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrackArg {
        TrackArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "bits",
                |m: &TrackArg| &m.bits,
                |m: &mut TrackArg| &mut m.bits,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrackArg>(
                "TrackArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static TrackArg {
        static instance: ::protobuf::rt::LazyV2<TrackArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrackArg::new)
    }
}

impl ::protobuf::Clear for TrackArg {
    fn clear(&mut self) {
        self.bits = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrackArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrackArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TcpdumpArg {
    // message fields
    pub fifo: ::std::string::String,
    pub defer: bool,
    pub reconnect: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TcpdumpArg {
    fn default() -> &'a TcpdumpArg {
        <TcpdumpArg as ::protobuf::Message>::default_instance()
    }
}

impl TcpdumpArg {
    pub fn new() -> TcpdumpArg {
        ::std::default::Default::default()
    }

    // string fifo = 5;

    pub fn get_fifo(&self) -> &str {
        &self.fifo
    }
    pub fn clear_fifo(&mut self) {
        self.fifo.clear();
    }

    // Param is passed by value, moved
    pub fn set_fifo(&mut self, v: ::std::string::String) {
        self.fifo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fifo(&mut self) -> &mut ::std::string::String {
        &mut self.fifo
    }

    // Take field
    pub fn take_fifo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fifo, ::std::string::String::new())
    }

    // bool defer = 6;

    pub fn get_defer(&self) -> bool {
        self.defer
    }
    pub fn clear_defer(&mut self) {
        self.defer = false;
    }

    // Param is passed by value, moved
    pub fn set_defer(&mut self, v: bool) {
        self.defer = v;
    }

    // bool reconnect = 7;

    pub fn get_reconnect(&self) -> bool {
        self.reconnect
    }
    pub fn clear_reconnect(&mut self) {
        self.reconnect = false;
    }

    // Param is passed by value, moved
    pub fn set_reconnect(&mut self, v: bool) {
        self.reconnect = v;
    }
}

impl ::protobuf::Message for TcpdumpArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.fifo,
                    )?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.defer = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.reconnect = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fifo.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.fifo);
        }
        if self.defer != false {
            my_size += 2;
        }
        if self.reconnect != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.fifo.is_empty() {
            os.write_string(5, &self.fifo)?;
        }
        if self.defer != false {
            os.write_bool(6, self.defer)?;
        }
        if self.reconnect != false {
            os.write_bool(7, self.reconnect)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TcpdumpArg {
        TcpdumpArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "fifo",
                |m: &TcpdumpArg| &m.fifo,
                |m: &mut TcpdumpArg| &mut m.fifo,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "defer",
                |m: &TcpdumpArg| &m.defer,
                |m: &mut TcpdumpArg| &mut m.defer,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "reconnect",
                |m: &TcpdumpArg| &m.reconnect,
                |m: &mut TcpdumpArg| &mut m.reconnect,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TcpdumpArg>(
                "TcpdumpArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static TcpdumpArg {
        static instance: ::protobuf::rt::LazyV2<TcpdumpArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TcpdumpArg::new)
    }
}

impl ::protobuf::Clear for TcpdumpArg {
    fn clear(&mut self) {
        self.fifo.clear();
        self.defer = false;
        self.reconnect = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TcpdumpArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TcpdumpArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PcapngArg {
    // message fields
    pub fifo: ::std::string::String,
    pub defer: bool,
    pub reconnect: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PcapngArg {
    fn default() -> &'a PcapngArg {
        <PcapngArg as ::protobuf::Message>::default_instance()
    }
}

impl PcapngArg {
    pub fn new() -> PcapngArg {
        ::std::default::Default::default()
    }

    // string fifo = 5;

    pub fn get_fifo(&self) -> &str {
        &self.fifo
    }
    pub fn clear_fifo(&mut self) {
        self.fifo.clear();
    }

    // Param is passed by value, moved
    pub fn set_fifo(&mut self, v: ::std::string::String) {
        self.fifo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fifo(&mut self) -> &mut ::std::string::String {
        &mut self.fifo
    }

    // Take field
    pub fn take_fifo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fifo, ::std::string::String::new())
    }

    // bool defer = 6;

    pub fn get_defer(&self) -> bool {
        self.defer
    }
    pub fn clear_defer(&mut self) {
        self.defer = false;
    }

    // Param is passed by value, moved
    pub fn set_defer(&mut self, v: bool) {
        self.defer = v;
    }

    // bool reconnect = 7;

    pub fn get_reconnect(&self) -> bool {
        self.reconnect
    }
    pub fn clear_reconnect(&mut self) {
        self.reconnect = false;
    }

    // Param is passed by value, moved
    pub fn set_reconnect(&mut self, v: bool) {
        self.reconnect = v;
    }
}

impl ::protobuf::Message for PcapngArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.fifo,
                    )?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.defer = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.reconnect = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fifo.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.fifo);
        }
        if self.defer != false {
            my_size += 2;
        }
        if self.reconnect != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.fifo.is_empty() {
            os.write_string(5, &self.fifo)?;
        }
        if self.defer != false {
            os.write_bool(6, self.defer)?;
        }
        if self.reconnect != false {
            os.write_bool(7, self.reconnect)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PcapngArg {
        PcapngArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "fifo",
                |m: &PcapngArg| &m.fifo,
                |m: &mut PcapngArg| &mut m.fifo,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "defer",
                |m: &PcapngArg| &m.defer,
                |m: &mut PcapngArg| &mut m.defer,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "reconnect",
                |m: &PcapngArg| &m.reconnect,
                |m: &mut PcapngArg| &mut m.reconnect,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PcapngArg>(
                "PcapngArg",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static PcapngArg {
        static instance: ::protobuf::rt::LazyV2<PcapngArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PcapngArg::new)
    }
}

impl ::protobuf::Clear for PcapngArg {
    fn clear(&mut self) {
        self.fifo.clear();
        self.defer = false;
        self.reconnect = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PcapngArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PcapngArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GateHookInfo {
    // message fields
    pub class_name: ::std::string::String,
    pub hook_name: ::std::string::String,
    pub module_name: ::std::string::String,
    pub arg: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // message oneof groups
    pub gate: ::std::option::Option<GateHookInfo_oneof_gate>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GateHookInfo {
    fn default() -> &'a GateHookInfo {
        <GateHookInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum GateHookInfo_oneof_gate {
    igate(i64),
    ogate(i64),
}

impl GateHookInfo {
    pub fn new() -> GateHookInfo {
        ::std::default::Default::default()
    }

    // string class_name = 1;

    pub fn get_class_name(&self) -> &str {
        &self.class_name
    }
    pub fn clear_class_name(&mut self) {
        self.class_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: ::std::string::String) {
        self.class_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
        &mut self.class_name
    }

    // Take field
    pub fn take_class_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.class_name, ::std::string::String::new())
    }

    // string hook_name = 2;

    pub fn get_hook_name(&self) -> &str {
        &self.hook_name
    }
    pub fn clear_hook_name(&mut self) {
        self.hook_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_hook_name(&mut self, v: ::std::string::String) {
        self.hook_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook_name(&mut self) -> &mut ::std::string::String {
        &mut self.hook_name
    }

    // Take field
    pub fn take_hook_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hook_name, ::std::string::String::new())
    }

    // string module_name = 3;

    pub fn get_module_name(&self) -> &str {
        &self.module_name
    }
    pub fn clear_module_name(&mut self) {
        self.module_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: ::std::string::String) {
        self.module_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
        &mut self.module_name
    }

    // Take field
    pub fn take_module_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.module_name, ::std::string::String::new())
    }

    // int64 igate = 4;

    pub fn get_igate(&self) -> i64 {
        match self.gate {
            ::std::option::Option::Some(GateHookInfo_oneof_gate::igate(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_igate(&mut self) {
        self.gate = ::std::option::Option::None;
    }

    pub fn has_igate(&self) -> bool {
        match self.gate {
            ::std::option::Option::Some(GateHookInfo_oneof_gate::igate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_igate(&mut self, v: i64) {
        self.gate = ::std::option::Option::Some(GateHookInfo_oneof_gate::igate(v))
    }

    // int64 ogate = 5;

    pub fn get_ogate(&self) -> i64 {
        match self.gate {
            ::std::option::Option::Some(GateHookInfo_oneof_gate::ogate(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_ogate(&mut self) {
        self.gate = ::std::option::Option::None;
    }

    pub fn has_ogate(&self) -> bool {
        match self.gate {
            ::std::option::Option::Some(GateHookInfo_oneof_gate::ogate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ogate(&mut self, v: i64) {
        self.gate = ::std::option::Option::Some(GateHookInfo_oneof_gate::ogate(v))
    }

    // .google.protobuf.Any arg = 6;

    pub fn get_arg(&self) -> &::protobuf::well_known_types::Any {
        self.arg.as_ref().unwrap_or_else(|| {
            <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::protobuf::well_known_types::Any) {
        self.arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::protobuf::well_known_types::Any {
        self.arg
            .take()
            .unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for GateHookInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.class_name,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.hook_name,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.module_name,
                    )?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.gate = ::std::option::Option::Some(GateHookInfo_oneof_gate::igate(
                        is.read_int64()?,
                    ));
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    self.gate = ::std::option::Option::Some(GateHookInfo_oneof_gate::ogate(
                        is.read_int64()?,
                    ));
                }
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arg)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.class_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_name);
        }
        if !self.hook_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hook_name);
        }
        if !self.module_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.module_name);
        }
        if let Some(ref v) = self.arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.gate {
            match v {
                &GateHookInfo_oneof_gate::igate(v) => {
                    my_size +=
                        ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                }
                &GateHookInfo_oneof_gate::ogate(v) => {
                    my_size +=
                        ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.class_name.is_empty() {
            os.write_string(1, &self.class_name)?;
        }
        if !self.hook_name.is_empty() {
            os.write_string(2, &self.hook_name)?;
        }
        if !self.module_name.is_empty() {
            os.write_string(3, &self.module_name)?;
        }
        if let Some(ref v) = self.arg.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.gate {
            match v {
                &GateHookInfo_oneof_gate::igate(v) => {
                    os.write_int64(4, v)?;
                }
                &GateHookInfo_oneof_gate::ogate(v) => {
                    os.write_int64(5, v)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GateHookInfo {
        GateHookInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "class_name",
                |m: &GateHookInfo| &m.class_name,
                |m: &mut GateHookInfo| &mut m.class_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "hook_name",
                |m: &GateHookInfo| &m.hook_name,
                |m: &mut GateHookInfo| &mut m.hook_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "module_name",
                |m: &GateHookInfo| &m.module_name,
                |m: &mut GateHookInfo| &mut m.module_name,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "igate",
                    GateHookInfo::has_igate,
                    GateHookInfo::get_igate,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "ogate",
                    GateHookInfo::has_ogate,
                    GateHookInfo::get_ogate,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>,
                >(
                    "arg",
                    |m: &GateHookInfo| &m.arg,
                    |m: &mut GateHookInfo| &mut m.arg,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GateHookInfo>(
                "GateHookInfo",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GateHookInfo {
        static instance: ::protobuf::rt::LazyV2<GateHookInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GateHookInfo::new)
    }
}

impl ::protobuf::Clear for GateHookInfo {
    fn clear(&mut self) {
        self.class_name.clear();
        self.hook_name.clear();
        self.module_name.clear();
        self.gate = ::std::option::Option::None;
        self.gate = ::std::option::Option::None;
        self.arg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GateHookInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GateHookInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ConfigureGateHookRequest {
    // message fields
    pub hook: ::protobuf::SingularPtrField<GateHookInfo>,
    pub enable: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigureGateHookRequest {
    fn default() -> &'a ConfigureGateHookRequest {
        <ConfigureGateHookRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConfigureGateHookRequest {
    pub fn new() -> ConfigureGateHookRequest {
        ::std::default::Default::default()
    }

    // .bess.pb.GateHookInfo hook = 1;

    pub fn get_hook(&self) -> &GateHookInfo {
        self.hook
            .as_ref()
            .unwrap_or_else(|| <GateHookInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hook(&mut self) {
        self.hook.clear();
    }

    pub fn has_hook(&self) -> bool {
        self.hook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hook(&mut self, v: GateHookInfo) {
        self.hook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook(&mut self) -> &mut GateHookInfo {
        if self.hook.is_none() {
            self.hook.set_default();
        }
        self.hook.as_mut().unwrap()
    }

    // Take field
    pub fn take_hook(&mut self) -> GateHookInfo {
        self.hook.take().unwrap_or_else(|| GateHookInfo::new())
    }

    // bool enable = 2;

    pub fn get_enable(&self) -> bool {
        self.enable
    }
    pub fn clear_enable(&mut self) {
        self.enable = false;
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = v;
    }
}

impl ::protobuf::Message for ConfigureGateHookRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.hook {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hook)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enable != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enable != false {
            os.write_bool(2, self.enable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigureGateHookRequest {
        ConfigureGateHookRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GateHookInfo>,
                >(
                    "hook",
                    |m: &ConfigureGateHookRequest| &m.hook,
                    |m: &mut ConfigureGateHookRequest| &mut m.hook,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "enable",
                |m: &ConfigureGateHookRequest| &m.enable,
                |m: &mut ConfigureGateHookRequest| &mut m.enable,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigureGateHookRequest>(
                "ConfigureGateHookRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ConfigureGateHookRequest {
        static instance: ::protobuf::rt::LazyV2<ConfigureGateHookRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigureGateHookRequest::new)
    }
}

impl ::protobuf::Clear for ConfigureGateHookRequest {
    fn clear(&mut self) {
        self.hook.clear();
        self.enable = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigureGateHookRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigureGateHookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ConfigureGateHookResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigureGateHookResponse {
    fn default() -> &'a ConfigureGateHookResponse {
        <ConfigureGateHookResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConfigureGateHookResponse {
    pub fn new() -> ConfigureGateHookResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // string name = 2;

    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConfigureGateHookResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.name,
                    )?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigureGateHookResponse {
        ConfigureGateHookResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ConfigureGateHookResponse| &m.error,
                    |m: &mut ConfigureGateHookResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &ConfigureGateHookResponse| &m.name,
                |m: &mut ConfigureGateHookResponse| &mut m.name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigureGateHookResponse>(
                "ConfigureGateHookResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ConfigureGateHookResponse {
        static instance: ::protobuf::rt::LazyV2<ConfigureGateHookResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigureGateHookResponse::new)
    }
}

impl ::protobuf::Clear for ConfigureGateHookResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigureGateHookResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigureGateHookResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ListGateHooksResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub hooks: ::protobuf::RepeatedField<GateHookInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListGateHooksResponse {
    fn default() -> &'a ListGateHooksResponse {
        <ListGateHooksResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListGateHooksResponse {
    pub fn new() -> ListGateHooksResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated .bess.pb.GateHookInfo hooks = 2;

    pub fn get_hooks(&self) -> &[GateHookInfo] {
        &self.hooks
    }
    pub fn clear_hooks(&mut self) {
        self.hooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_hooks(&mut self, v: ::protobuf::RepeatedField<GateHookInfo>) {
        self.hooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hooks(&mut self) -> &mut ::protobuf::RepeatedField<GateHookInfo> {
        &mut self.hooks
    }

    // Take field
    pub fn take_hooks(&mut self) -> ::protobuf::RepeatedField<GateHookInfo> {
        ::std::mem::replace(&mut self.hooks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListGateHooksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.hooks {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hooks)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.hooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.hooks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGateHooksResponse {
        ListGateHooksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &ListGateHooksResponse| &m.error,
                    |m: &mut ListGateHooksResponse| &mut m.error,
                ),
            );
            fields.push(
                ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GateHookInfo>,
                >(
                    "hooks",
                    |m: &ListGateHooksResponse| &m.hooks,
                    |m: &mut ListGateHooksResponse| &mut m.hooks,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListGateHooksResponse>(
                "ListGateHooksResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ListGateHooksResponse {
        static instance: ::protobuf::rt::LazyV2<ListGateHooksResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ListGateHooksResponse::new)
    }
}

impl ::protobuf::Clear for ListGateHooksResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.hooks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGateHooksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGateHooksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GateHookCommandRequest {
    // message fields
    pub hook: ::protobuf::SingularPtrField<GateHookInfo>,
    pub cmd: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GateHookCommandRequest {
    fn default() -> &'a GateHookCommandRequest {
        <GateHookCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl GateHookCommandRequest {
    pub fn new() -> GateHookCommandRequest {
        ::std::default::Default::default()
    }

    // .bess.pb.GateHookInfo hook = 1;

    pub fn get_hook(&self) -> &GateHookInfo {
        self.hook
            .as_ref()
            .unwrap_or_else(|| <GateHookInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hook(&mut self) {
        self.hook.clear();
    }

    pub fn has_hook(&self) -> bool {
        self.hook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hook(&mut self, v: GateHookInfo) {
        self.hook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook(&mut self) -> &mut GateHookInfo {
        if self.hook.is_none() {
            self.hook.set_default();
        }
        self.hook.as_mut().unwrap()
    }

    // Take field
    pub fn take_hook(&mut self) -> GateHookInfo {
        self.hook.take().unwrap_or_else(|| GateHookInfo::new())
    }

    // string cmd = 2;

    pub fn get_cmd(&self) -> &str {
        &self.cmd
    }
    pub fn clear_cmd(&mut self) {
        self.cmd.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::std::string::String) {
        self.cmd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut ::std::string::String {
        &mut self.cmd
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cmd, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GateHookCommandRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.hook {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hook)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cmd)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cmd.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cmd);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cmd.is_empty() {
            os.write_string(2, &self.cmd)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GateHookCommandRequest {
        GateHookCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<GateHookInfo>,
                >(
                    "hook",
                    |m: &GateHookCommandRequest| &m.hook,
                    |m: &mut GateHookCommandRequest| &mut m.hook,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "cmd",
                |m: &GateHookCommandRequest| &m.cmd,
                |m: &mut GateHookCommandRequest| &mut m.cmd,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GateHookCommandRequest>(
                "GateHookCommandRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GateHookCommandRequest {
        static instance: ::protobuf::rt::LazyV2<GateHookCommandRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(GateHookCommandRequest::new)
    }
}

impl ::protobuf::Clear for GateHookCommandRequest {
    fn clear(&mut self) {
        self.hook.clear();
        self.cmd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GateHookCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GateHookCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ConfigureResumeHookRequest {
    // message fields
    pub hook_name: ::std::string::String,
    pub enable: bool,
    pub arg: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigureResumeHookRequest {
    fn default() -> &'a ConfigureResumeHookRequest {
        <ConfigureResumeHookRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConfigureResumeHookRequest {
    pub fn new() -> ConfigureResumeHookRequest {
        ::std::default::Default::default()
    }

    // string hook_name = 1;

    pub fn get_hook_name(&self) -> &str {
        &self.hook_name
    }
    pub fn clear_hook_name(&mut self) {
        self.hook_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_hook_name(&mut self, v: ::std::string::String) {
        self.hook_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hook_name(&mut self) -> &mut ::std::string::String {
        &mut self.hook_name
    }

    // Take field
    pub fn take_hook_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hook_name, ::std::string::String::new())
    }

    // bool enable = 2;

    pub fn get_enable(&self) -> bool {
        self.enable
    }
    pub fn clear_enable(&mut self) {
        self.enable = false;
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = v;
    }

    // .google.protobuf.Any arg = 3;

    pub fn get_arg(&self) -> &::protobuf::well_known_types::Any {
        self.arg.as_ref().unwrap_or_else(|| {
            <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance()
        })
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::protobuf::well_known_types::Any) {
        self.arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::protobuf::well_known_types::Any {
        self.arg
            .take()
            .unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for ConfigureResumeHookRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.hook_name,
                    )?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = tmp;
                }
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arg)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hook_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hook_name);
        }
        if self.enable != false {
            my_size += 2;
        }
        if let Some(ref v) = self.arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.hook_name.is_empty() {
            os.write_string(1, &self.hook_name)?;
        }
        if self.enable != false {
            os.write_bool(2, self.enable)?;
        }
        if let Some(ref v) = self.arg.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigureResumeHookRequest {
        ConfigureResumeHookRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "hook_name",
                |m: &ConfigureResumeHookRequest| &m.hook_name,
                |m: &mut ConfigureResumeHookRequest| &mut m.hook_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "enable",
                |m: &ConfigureResumeHookRequest| &m.enable,
                |m: &mut ConfigureResumeHookRequest| &mut m.enable,
            ));
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>,
                >(
                    "arg",
                    |m: &ConfigureResumeHookRequest| &m.arg,
                    |m: &mut ConfigureResumeHookRequest| &mut m.arg,
                ),
            );
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigureResumeHookRequest>(
                "ConfigureResumeHookRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ConfigureResumeHookRequest {
        static instance: ::protobuf::rt::LazyV2<ConfigureResumeHookRequest> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigureResumeHookRequest::new)
    }
}

impl ::protobuf::Clear for ConfigureResumeHookRequest {
    fn clear(&mut self) {
        self.hook_name.clear();
        self.enable = false;
        self.arg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigureResumeHookRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigureResumeHookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PauseWorkerRequest {
    // message fields
    pub wid: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PauseWorkerRequest {
    fn default() -> &'a PauseWorkerRequest {
        <PauseWorkerRequest as ::protobuf::Message>::default_instance()
    }
}

impl PauseWorkerRequest {
    pub fn new() -> PauseWorkerRequest {
        ::std::default::Default::default()
    }

    // int64 wid = 1;

    pub fn get_wid(&self) -> i64 {
        self.wid
    }
    pub fn clear_wid(&mut self) {
        self.wid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wid(&mut self, v: i64) {
        self.wid = v;
    }
}

impl ::protobuf::Message for PauseWorkerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.wid = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wid != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.wid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.wid != 0 {
            os.write_int64(1, self.wid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PauseWorkerRequest {
        PauseWorkerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "wid",
                |m: &PauseWorkerRequest| &m.wid,
                |m: &mut PauseWorkerRequest| &mut m.wid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PauseWorkerRequest>(
                "PauseWorkerRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static PauseWorkerRequest {
        static instance: ::protobuf::rt::LazyV2<PauseWorkerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PauseWorkerRequest::new)
    }
}

impl ::protobuf::Clear for PauseWorkerRequest {
    fn clear(&mut self) {
        self.wid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PauseWorkerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PauseWorkerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ResumeWorkerRequest {
    // message fields
    pub wid: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResumeWorkerRequest {
    fn default() -> &'a ResumeWorkerRequest {
        <ResumeWorkerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResumeWorkerRequest {
    pub fn new() -> ResumeWorkerRequest {
        ::std::default::Default::default()
    }

    // int64 wid = 1;

    pub fn get_wid(&self) -> i64 {
        self.wid
    }
    pub fn clear_wid(&mut self) {
        self.wid = 0;
    }

    // Param is passed by value, moved
    pub fn set_wid(&mut self, v: i64) {
        self.wid = v;
    }
}

impl ::protobuf::Message for ResumeWorkerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.wid = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wid != 0 {
            my_size +=
                ::protobuf::rt::value_size(1, self.wid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.wid != 0 {
            os.write_int64(1, self.wid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResumeWorkerRequest {
        ResumeWorkerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt64,
            >(
                "wid",
                |m: &ResumeWorkerRequest| &m.wid,
                |m: &mut ResumeWorkerRequest| &mut m.wid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResumeWorkerRequest>(
                "ResumeWorkerRequest",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ResumeWorkerRequest {
        static instance: ::protobuf::rt::LazyV2<ResumeWorkerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResumeWorkerRequest::new)
    }
}

impl ::protobuf::Clear for ResumeWorkerRequest {
    fn clear(&mut self) {
        self.wid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResumeWorkerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResumeWorkerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DumpDescriptorsResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::error::Error>,
    pub modules:
        ::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>,
    pub module_commands: ::std::collections::HashMap<
        ::std::string::String,
        DumpDescriptorsResponse_CommandDescriptors,
    >,
    pub ports:
        ::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DumpDescriptorsResponse {
    fn default() -> &'a DumpDescriptorsResponse {
        <DumpDescriptorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DumpDescriptorsResponse {
    pub fn new() -> DumpDescriptorsResponse {
        ::std::default::Default::default()
    }

    // .bess.pb.Error error = 1;

    pub fn get_error(&self) -> &super::error::Error {
        self.error
            .as_ref()
            .unwrap_or_else(|| <super::error::Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::error::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::error::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::error::Error {
        self.error
            .take()
            .unwrap_or_else(|| super::error::Error::new())
    }

    // repeated .bess.pb.DumpDescriptorsResponse.ModulesEntry modules = 2;

    pub fn get_modules(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>
    {
        &self.modules
    }
    pub fn clear_modules(&mut self) {
        self.modules.clear();
    }

    // Param is passed by value, moved
    pub fn set_modules(
        &mut self,
        v: ::std::collections::HashMap<
            ::std::string::String,
            ::protobuf::descriptor::DescriptorProto,
        >,
    ) {
        self.modules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modules(
        &mut self,
    ) -> &mut ::std::collections::HashMap<
        ::std::string::String,
        ::protobuf::descriptor::DescriptorProto,
    > {
        &mut self.modules
    }

    // Take field
    pub fn take_modules(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>
    {
        ::std::mem::replace(&mut self.modules, ::std::collections::HashMap::new())
    }

    // repeated .bess.pb.DumpDescriptorsResponse.ModuleCommandsEntry module_commands = 3;

    pub fn get_module_commands(
        &self,
    ) -> &::std::collections::HashMap<
        ::std::string::String,
        DumpDescriptorsResponse_CommandDescriptors,
    > {
        &self.module_commands
    }
    pub fn clear_module_commands(&mut self) {
        self.module_commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_module_commands(
        &mut self,
        v: ::std::collections::HashMap<
            ::std::string::String,
            DumpDescriptorsResponse_CommandDescriptors,
        >,
    ) {
        self.module_commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_module_commands(
        &mut self,
    ) -> &mut ::std::collections::HashMap<
        ::std::string::String,
        DumpDescriptorsResponse_CommandDescriptors,
    > {
        &mut self.module_commands
    }

    // Take field
    pub fn take_module_commands(
        &mut self,
    ) -> ::std::collections::HashMap<
        ::std::string::String,
        DumpDescriptorsResponse_CommandDescriptors,
    > {
        ::std::mem::replace(
            &mut self.module_commands,
            ::std::collections::HashMap::new(),
        )
    }

    // repeated .bess.pb.DumpDescriptorsResponse.PortsEntry ports = 4;

    pub fn get_ports(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>
    {
        &self.ports
    }
    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(
        &mut self,
        v: ::std::collections::HashMap<
            ::std::string::String,
            ::protobuf::descriptor::DescriptorProto,
        >,
    ) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(
        &mut self,
    ) -> &mut ::std::collections::HashMap<
        ::std::string::String,
        ::protobuf::descriptor::DescriptorProto,
    > {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>
    {
        ::std::mem::replace(&mut self.ports, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DumpDescriptorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                }
                2 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeMessage<
                            ::protobuf::descriptor::DescriptorProto,
                        >,
                    >(wire_type, is, &mut self.modules)?;
                }
                3 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeMessage<
                            DumpDescriptorsResponse_CommandDescriptors,
                        >,
                    >(wire_type, is, &mut self.module_commands)?;
                }
                4 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeMessage<
                            ::protobuf::descriptor::DescriptorProto,
                        >,
                    >(wire_type, is, &mut self.ports)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
        >(2, &self.modules);
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<DumpDescriptorsResponse_CommandDescriptors>,
        >(3, &self.module_commands);
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
        >(4, &self.ports);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
        >(2, &self.modules, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<DumpDescriptorsResponse_CommandDescriptors>,
        >(3, &self.module_commands, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
        >(4, &self.ports, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DumpDescriptorsResponse {
        DumpDescriptorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(
                ::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeMessage<super::error::Error>,
                >(
                    "error",
                    |m: &DumpDescriptorsResponse| &m.error,
                    |m: &mut DumpDescriptorsResponse| &mut m.error,
                ),
            );
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
            >(
                "modules",
                |m: &DumpDescriptorsResponse| &m.modules,
                |m: &mut DumpDescriptorsResponse| &mut m.modules,
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeMessage<DumpDescriptorsResponse_CommandDescriptors>,
            >(
                "module_commands",
                |m: &DumpDescriptorsResponse| &m.module_commands,
                |m: &mut DumpDescriptorsResponse| &mut m.module_commands,
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
            >(
                "ports",
                |m: &DumpDescriptorsResponse| &m.ports,
                |m: &mut DumpDescriptorsResponse| &mut m.ports,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DumpDescriptorsResponse>(
                "DumpDescriptorsResponse",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DumpDescriptorsResponse {
        static instance: ::protobuf::rt::LazyV2<DumpDescriptorsResponse> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(DumpDescriptorsResponse::new)
    }
}

impl ::protobuf::Clear for DumpDescriptorsResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.modules.clear();
        self.module_commands.clear();
        self.ports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DumpDescriptorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DumpDescriptorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DumpDescriptorsResponse_CommandDescriptors {
    // message fields
    pub commands:
        ::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DumpDescriptorsResponse_CommandDescriptors {
    fn default() -> &'a DumpDescriptorsResponse_CommandDescriptors {
        <DumpDescriptorsResponse_CommandDescriptors as ::protobuf::Message>::default_instance()
    }
}

impl DumpDescriptorsResponse_CommandDescriptors {
    pub fn new() -> DumpDescriptorsResponse_CommandDescriptors {
        ::std::default::Default::default()
    }

    // repeated .bess.pb.DumpDescriptorsResponse.CommandDescriptors.CommandsEntry commands = 1;

    pub fn get_commands(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>
    {
        &self.commands
    }
    pub fn clear_commands(&mut self) {
        self.commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_commands(
        &mut self,
        v: ::std::collections::HashMap<
            ::std::string::String,
            ::protobuf::descriptor::DescriptorProto,
        >,
    ) {
        self.commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commands(
        &mut self,
    ) -> &mut ::std::collections::HashMap<
        ::std::string::String,
        ::protobuf::descriptor::DescriptorProto,
    > {
        &mut self.commands
    }

    // Take field
    pub fn take_commands(
        &mut self,
    ) -> ::std::collections::HashMap<::std::string::String, ::protobuf::descriptor::DescriptorProto>
    {
        ::std::mem::replace(&mut self.commands, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DumpDescriptorsResponse_CommandDescriptors {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<
                        ::protobuf::types::ProtobufTypeString,
                        ::protobuf::types::ProtobufTypeMessage<
                            ::protobuf::descriptor::DescriptorProto,
                        >,
                    >(wire_type, is, &mut self.commands)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
        >(1, &self.commands);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream<'_>,
    ) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<
            ::protobuf::types::ProtobufTypeString,
            ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
        >(1, &self.commands, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DumpDescriptorsResponse_CommandDescriptors {
        DumpDescriptorsResponse_CommandDescriptors::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
                ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::DescriptorProto>,
            >(
                "commands",
                |m: &DumpDescriptorsResponse_CommandDescriptors| &m.commands,
                |m: &mut DumpDescriptorsResponse_CommandDescriptors| &mut m.commands,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<
                DumpDescriptorsResponse_CommandDescriptors,
            >(
                "DumpDescriptorsResponse.CommandDescriptors",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static DumpDescriptorsResponse_CommandDescriptors {
        static instance: ::protobuf::rt::LazyV2<DumpDescriptorsResponse_CommandDescriptors> =
            ::protobuf::rt::LazyV2::INIT;
        instance.get(DumpDescriptorsResponse_CommandDescriptors::new)
    }
}

impl ::protobuf::Clear for DumpDescriptorsResponse_CommandDescriptors {
    fn clear(&mut self) {
        self.commands.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DumpDescriptorsResponse_CommandDescriptors {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DumpDescriptorsResponse_CommandDescriptors {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ebess_msg.proto\x12\x07bess.pb\x1a\x19google/protobuf/any.proto\x1a\
    \x20google/protobuf/descriptor.proto\x1a\x0berror.proto\"\x0e\n\x0cEmpty\
    Request\"5\n\rEmptyResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.be\
    ss.pb.ErrorR\x05error\"Q\n\x0fVersionResponse\x12$\n\x05error\x18\x01\
    \x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12\x18\n\x07version\x18\x02\
    \x20\x01(\tR\x07version\")\n\x13ImportPluginRequest\x12\x12\n\x04path\
    \x18\x01\x20\x01(\tR\x04path\")\n\x13UnloadPluginRequest\x12\x12\n\x04pa\
    th\x18\x01\x20\x01(\tR\x04path\"Q\n\x13ListPluginsResponse\x12$\n\x05err\
    or\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12\x14\n\x05paths\
    \x18\x02\x20\x03(\tR\x05paths\"\x9a\x02\n\x13ListWorkersResponse\x12$\n\
    \x05error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12P\n\x0ewo\
    rkers_status\x18\x02\x20\x03(\x0b2).bess.pb.ListWorkersResponse.WorkerSt\
    atusR\rworkersStatus\x1a\x8a\x01\n\x0cWorkerStatus\x12\x10\n\x03wid\x18\
    \x01\x20\x01(\x03R\x03wid\x12\x12\n\x04core\x18\x02\x20\x01(\x03R\x04cor\
    e\x12\x18\n\x07running\x18\x03\x20\x01(\x08R\x07running\x12\x17\n\x07num\
    _tcs\x18\x04\x20\x01(\x03R\x06numTcs\x12!\n\x0csilent_drops\x18\x05\x20\
    \x01(\x03R\x0bsilentDrops\"V\n\x10AddWorkerRequest\x12\x10\n\x03wid\x18\
    \x01\x20\x01(\x03R\x03wid\x12\x12\n\x04core\x18\x02\x20\x01(\x03R\x04cor\
    e\x12\x1c\n\tscheduler\x18\x03\x20\x01(\tR\tscheduler\"(\n\x14DestroyWor\
    kerRequest\x12\x10\n\x03wid\x18\x01\x20\x01(\x03R\x03wid\"\xa0\x04\n\x0c\
    TrafficClass\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06parent\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x18\n\x07blocked\x18\x03\x20\
    \x01(\x08R\x07blocked\x12\x16\n\x06policy\x18\x04\x20\x01(\tR\x06policy\
    \x12\x1a\n\x08resource\x18\x05\x20\x01(\tR\x08resource\x12\x1c\n\x08prio\
    rity\x18\x06\x20\x01(\x03H\0R\x08priority\x12\x16\n\x05share\x18\x07\x20\
    \x01(\x03H\0R\x05share\x12\x10\n\x03wid\x18\x08\x20\x01(\x03R\x03wid\x12\
    6\n\x05limit\x18\t\x20\x03(\x0b2\x20.bess.pb.TrafficClass.LimitEntryR\
    \x05limit\x12@\n\tmax_burst\x18\n\x20\x03(\x0b2#.bess.pb.TrafficClass.Ma\
    xBurstEntryR\x08maxBurst\x12(\n\x10leaf_module_name\x18\x0b\x20\x01(\tR\
    \x0eleafModuleName\x12,\n\x12leaf_module_taskid\x18\x0c\x20\x01(\x04R\
    \x10leafModuleTaskid\x1a8\n\nLimitEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value:\x028\x01\
    \x1a;\n\rMaxBurstEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x03R\x05value:\x028\x01B\x05\n\x03arg\"\
    \"\n\x0eListTcsRequest\x12\x10\n\x03wid\x18\x01\x20\x01(\x03R\x03wid\"\
    \xe6\x01\n\x0fListTcsResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.\
    bess.pb.ErrorR\x05error\x12R\n\x0eclasses_status\x18\x02\x20\x03(\x0b2+.\
    bess.pb.ListTcsResponse.TrafficClassStatusR\rclassesStatus\x1aY\n\x12Tra\
    fficClassStatus\x12+\n\x05class\x18\x01\x20\x01(\x0b2\x15.bess.pb.Traffi\
    cClassR\x05class\x12\x16\n\x06parent\x18\x02\x20\x01(\tR\x06parent\"\xcb\
    \x03\n\"CheckSchedulingConstraintsResponse\x12$\n\x05error\x18\x01\x20\
    \x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12\x14\n\x05fatal\x18\x02\x20\
    \x01(\x08R\x05fatal\x12Z\n\nviolations\x18\x03\x20\x03(\x0b2:.bess.pb.Ch\
    eckSchedulingConstraintsResponse.ViolatingClassR\nviolations\x12U\n\x07m\
    odules\x18\x04\x20\x03(\x0b2;.bess.pb.CheckSchedulingConstraintsResponse\
    .ViolatingModuleR\x07modules\x1a\x8e\x01\n\x0eViolatingClass\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x1e\n\nconstraint\x18\x02\x20\
    \x01(\x05R\nconstraint\x12#\n\rassigned_node\x18\x03\x20\x01(\x05R\x0cas\
    signedNode\x12#\n\rassigned_core\x18\x04\x20\x01(\x05R\x0cassignedCore\
    \x1a%\n\x0fViolatingModule\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \";\n\x0cAddTcRequest\x12+\n\x05class\x18\x01\x20\x01(\x0b2\x15.bess.pb.\
    TrafficClassR\x05class\"D\n\x15UpdateTcParamsRequest\x12+\n\x05class\x18\
    \x01\x20\x01(\x0b2\x15.bess.pb.TrafficClassR\x05class\"D\n\x15UpdateTcPa\
    rentRequest\x12+\n\x05class\x18\x01\x20\x01(\x0b2\x15.bess.pb.TrafficCla\
    ssR\x05class\"'\n\x11GetTcStatsRequest\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\"\xb4\x01\n\x12GetTcStatsResponse\x12$\n\x05error\x18\x01\
    \x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\x01R\ttimestamp\x12\x14\n\x05count\x18\x03\x20\x01(\x04R\x05co\
    unt\x12\x16\n\x06cycles\x18\x04\x20\x01(\x04R\x06cycles\x12\x18\n\x07pac\
    kets\x18\x05\x20\x01(\x04R\x07packets\x12\x12\n\x04bits\x18\x06\x20\x01(\
    \x04R\x04bits\"^\n\x13ListDriversResponse\x12$\n\x05error\x18\x01\x20\
    \x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12!\n\x0cdriver_names\x18\x02\
    \x20\x03(\tR\x0bdriverNames\"7\n\x14GetDriverInfoRequest\x12\x1f\n\x0bdr\
    iver_name\x18\x01\x20\x01(\tR\ndriverName\"\x81\x01\n\x15GetDriverInfoRe\
    sponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04help\x18\x03\
    \x20\x01(\tR\x04help\x12\x1a\n\x08commands\x18\x04\x20\x03(\tR\x08comman\
    ds\"\xe9\x02\n\x11ListPortsResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b\
    2\x0e.bess.pb.ErrorR\x05error\x125\n\x05ports\x18\x02\x20\x03(\x0b2\x1f.\
    bess.pb.ListPortsResponse.PortR\x05ports\x1a\xf6\x01\n\x04Port\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06driver\x18\x02\x20\x01\
    (\tR\x06driver\x12\x19\n\x08mac_addr\x18\x03\x20\x01(\tR\x07macAddr\x12\
    \x1a\n\tnum_inc_q\x18\x04\x20\x01(\x04R\x07numIncQ\x12\x1a\n\tnum_out_q\
    \x18\x05\x20\x01(\x04R\x07numOutQ\x12\x1c\n\nsize_inc_q\x18\x06\x20\x01(\
    \x04R\x08sizeIncQ\x12\x1c\n\nsize_out_q\x18\x07\x20\x01(\x04R\x08sizeOut\
    Q\x123\n\ndriver_arg\x18\x08\x20\x01(\x0b2\x14.google.protobuf.AnyR\tdri\
    verArg\"\xdb\x01\n\x11CreatePortRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x16\n\x06driver\x18\x02\x20\x01(\tR\x06driver\x12\
    \x1a\n\tnum_inc_q\x18\x03\x20\x01(\x04R\x07numIncQ\x12\x1a\n\tnum_out_q\
    \x18\x04\x20\x01(\x04R\x07numOutQ\x12\x1c\n\nsize_inc_q\x18\x05\x20\x01(\
    \x04R\x08sizeIncQ\x12\x1c\n\nsize_out_q\x18\x06\x20\x01(\x04R\x08sizeOut\
    Q\x12&\n\x03arg\x18\x07\x20\x01(\x0b2\x14.google.protobuf.AnyR\x03arg\"R\
    \n\x08PortConf\x12\x19\n\x08mac_addr\x18\x01\x20\x01(\tR\x07macAddr\x12\
    \x10\n\x03mtu\x18\x02\x20\x01(\rR\x03mtu\x12\x19\n\x08admin_up\x18\x03\
    \x20\x01(\x08R\x07adminUp\"O\n\x12SetPortConfRequest\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12%\n\x04conf\x18\x02\x20\x01(\x0b2\x11.be\
    ss.pb.PortConfR\x04conf\"(\n\x12GetPortConfRequest\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"b\n\x13GetPortConfResponse\x12$\n\x05error\x18\
    \x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12%\n\x04conf\x18\x02\
    \x20\x01(\x0b2\x11.bess.pb.PortConfR\x04conf\"i\n\x12CreatePortResponse\
    \x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x19\n\x08mac_addr\x18\x03\
    \x20\x01(\tR\x07macAddr\"(\n\x12DestroyPortRequest\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\")\n\x13GetPortStatsRequest\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\"\xfe\x02\n\x14GetPortStatsResponse\x12$\n\
    \x05error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x124\n\x03in\
    c\x18\x02\x20\x01(\x0b2\".bess.pb.GetPortStatsResponse.StatR\x03inc\x124\
    \n\x03out\x18\x03\x20\x01(\x0b2\".bess.pb.GetPortStatsResponse.StatR\x03\
    out\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\x01R\ttimestamp\x1a\xb5\x01\n\
    \x04Stat\x12\x18\n\x07packets\x18\x01\x20\x01(\x04R\x07packets\x12\x18\n\
    \x07dropped\x18\x02\x20\x01(\x04R\x07dropped\x12\x14\n\x05bytes\x18\x03\
    \x20\x01(\x04R\x05bytes\x12%\n\x0erequested_hist\x18\x04\x20\x03(\x04R\r\
    requestedHist\x12\x1f\n\x0bactual_hist\x18\x05\x20\x03(\x04R\nactualHist\
    \x12\x1b\n\tdiff_hist\x18\x06\x20\x03(\x04R\x08diffHist\"*\n\x14GetLinkS\
    tatusRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\xa7\x01\n\
    \x15GetLinkStatusResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.bess\
    .pb.ErrorR\x05error\x12\x14\n\x05speed\x18\x02\x20\x01(\rR\x05speed\x12\
    \x1f\n\x0bfull_duplex\x18\x03\x20\x01(\x08R\nfullDuplex\x12\x18\n\x07aut\
    oneg\x18\x04\x20\x01(\x08R\x07autoneg\x12\x17\n\x07link_up\x18\x05\x20\
    \x01(\x08R\x06linkUp\"P\n\x12ListMclassResponse\x12$\n\x05error\x18\x01\
    \x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12\x14\n\x05names\x18\x02\
    \x20\x03(\tR\x05names\"*\n\x14GetMclassInfoRequest\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"\x94\x01\n\x15GetMclassInfoResponse\x12$\n\x05\
    error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12\x12\n\x04nam\
    e\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04help\x18\x03\x20\x01(\tR\x04h\
    elp\x12\x12\n\x04cmds\x18\x04\x20\x03(\tR\x04cmds\x12\x19\n\x08cmd_args\
    \x18\x05\x20\x03(\tR\x07cmdArgs\"\xc4\x01\n\x13ListModulesResponse\x12$\
    \n\x05error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12=\n\x07\
    modules\x18\x02\x20\x03(\x0b2#.bess.pb.ListModulesResponse.ModuleR\x07mo\
    dules\x1aH\n\x06Module\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x16\n\x06mclass\x18\x02\x20\x01(\tR\x06mclass\x12\x12\n\x04desc\x18\x03\
    \x20\x01(\tR\x04desc\"i\n\x13CreateModuleRequest\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x16\n\x06mclass\x18\x02\x20\x01(\tR\x06mcla\
    ss\x12&\n\x03arg\x18\x03\x20\x01(\x0b2\x14.google.protobuf.AnyR\x03arg\"\
    P\n\x14CreateModuleResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.be\
    ss.pb.ErrorR\x05error\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"*\n\
    \x14DestroyModuleRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\
    *\n\x14GetModuleInfoRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    e\"\xb3\x08\n\x15GetModuleInfoResponse\x12$\n\x05error\x18\x01\x20\x01(\
    \x0b2\x0e.bess.pb.ErrorR\x05error\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x16\n\x06mclass\x18\x03\x20\x01(\tR\x06mclass\x12\x12\n\x04\
    desc\x18\x04\x20\x01(\tR\x04desc\x12<\n\x06igates\x18\x06\x20\x03(\x0b2$\
    .bess.pb.GetModuleInfoResponse.IGateR\x06igates\x12<\n\x06ogates\x18\x07\
    \x20\x03(\x0b2$.bess.pb.GetModuleInfoResponse.OGateR\x06ogates\x12D\n\
    \x08metadata\x18\x08\x20\x03(\x0b2(.bess.pb.GetModuleInfoResponse.Attrib\
    uteR\x08metadata\x12\x1a\n\x08deadends\x18\t\x20\x01(\x04R\x08deadends\
    \x1aF\n\x08GateHook\x12\x1d\n\nclass_name\x18\x01\x20\x01(\tR\tclassName\
    \x12\x1b\n\thook_name\x18\x02\x20\x01(\tR\x08hookName\x1a\xbb\x02\n\x05I\
    Gate\x12\x14\n\x05igate\x18\x01\x20\x01(\x04R\x05igate\x12B\n\x06ogates\
    \x18\x02\x20\x03(\x0b2*.bess.pb.GetModuleInfoResponse.IGate.OGateR\x06og\
    ates\x12\x10\n\x03cnt\x18\x03\x20\x01(\x04R\x03cnt\x12\x12\n\x04pkts\x18\
    \x04\x20\x01(\x04R\x04pkts\x12\x14\n\x05bytes\x18\x05\x20\x01(\x04R\x05b\
    ytes\x12\x1c\n\ttimestamp\x18\x06\x20\x01(\x01R\ttimestamp\x12E\n\tgateh\
    ooks\x18\x08\x20\x03(\x0b2'.bess.pb.GetModuleInfoResponse.GateHookR\tgat\
    ehooks\x1a1\n\x05OGate\x12\x14\n\x05ogate\x18\x01\x20\x01(\x04R\x05ogate\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04nameJ\x04\x08\x07\x10\x08\x1a\
    \xee\x01\n\x05OGate\x12\x14\n\x05ogate\x18\x01\x20\x01(\x04R\x05ogate\
    \x12\x10\n\x03cnt\x18\x02\x20\x01(\x04R\x03cnt\x12\x12\n\x04pkts\x18\x03\
    \x20\x01(\x04R\x04pkts\x12\x14\n\x05bytes\x18\x04\x20\x01(\x04R\x05bytes\
    \x12\x1c\n\ttimestamp\x18\x05\x20\x01(\x01R\ttimestamp\x12\x12\n\x04name\
    \x18\x06\x20\x01(\tR\x04name\x12\x14\n\x05igate\x18\x07\x20\x01(\x04R\
    \x05igate\x12E\n\tgatehooks\x18\t\x20\x03(\x0b2'.bess.pb.GetModuleInfoRe\
    sponse.GateHookR\tgatehooksJ\x04\x08\x08\x10\t\x1a_\n\tAttribute\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04size\x18\x02\x20\x01\
    (\x04R\x04size\x12\x12\n\x04mode\x18\x03\x20\x01(\tR\x04mode\x12\x16\n\
    \x06offset\x18\x04\x20\x01(\x03R\x06offset\"\x91\x01\n\x15ConnectModules\
    Request\x12\x0e\n\x02m1\x18\x01\x20\x01(\tR\x02m1\x12\x0e\n\x02m2\x18\
    \x02\x20\x01(\tR\x02m2\x12\x14\n\x05ogate\x18\x03\x20\x01(\x04R\x05ogate\
    \x12\x14\n\x05igate\x18\x04\x20\x01(\x04R\x05igate\x12,\n\x12skip_defaul\
    t_hooks\x18\x05\x20\x01(\x08R\x10skipDefaultHooks\"D\n\x18DisconnectModu\
    lesRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05og\
    ate\x18\x02\x20\x01(\x04R\x05ogate\"\x93\x03\n\x0bMempoolDump\x12\x16\n\
    \x06socket\x18\x01\x20\x01(\x05R\x06socket\x12\x20\n\x0binitialized\x18\
    \x02\x20\x01(\x08R\x0binitialized\x12\x17\n\x07mp_size\x18\x03\x20\x01(\
    \rR\x06mpSize\x12\"\n\rmp_cache_size\x18\x04\x20\x01(\rR\x0bmpCacheSize\
    \x12&\n\x0fmp_element_size\x18\x05\x20\x01(\rR\rmpElementSize\x12*\n\x11\
    mp_populated_size\x18\x06\x20\x01(\rR\x0fmpPopulatedSize\x12,\n\x12mp_av\
    ailable_count\x18\x07\x20\x01(\rR\x10mpAvailableCount\x12%\n\x0fmp_in_us\
    e_count\x18\x08\x20\x01(\rR\x0cmpInUseCount\x12\x1d\n\nring_count\x18\t\
    \x20\x01(\rR\tringCount\x12&\n\x0fring_free_count\x18\n\x20\x01(\rR\rrin\
    gFreeCount\x12\x1d\n\nring_bytes\x18\x0b\x20\x01(\x04R\tringBytes\",\n\
    \x12DumpMempoolRequest\x12\x16\n\x06socket\x18\x01\x20\x01(\x05R\x06sock\
    et\"g\n\x13DumpMempoolResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e\
    .bess.pb.ErrorR\x05error\x12*\n\x05dumps\x18\x02\x20\x03(\x0b2\x14.bess.\
    pb.MempoolDumpR\x05dumps\"^\n\x0eCommandRequest\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x10\n\x03cmd\x18\x02\x20\x01(\tR\x03cmd\x12\
    &\n\x03arg\x18\x03\x20\x01(\x0b2\x14.google.protobuf.AnyR\x03arg\"a\n\
    \x0fCommandResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.Er\
    rorR\x05error\x12(\n\x04data\x18\x02\x20\x01(\x0b2\x14.google.protobuf.A\
    nyR\x04data\"W\n\x19ListGateHookClassResponse\x12$\n\x05error\x18\x01\
    \x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12\x14\n\x05names\x18\x02\
    \x20\x03(\tR\x05names\"1\n\x1bGetGateHookClassInfoRequest\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\"\x9b\x01\n\x1cGetGateHookClassInfoRespo\
    nse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04help\x18\x03\
    \x20\x01(\tR\x04help\x12\x12\n\x04cmds\x18\x04\x20\x03(\tR\x04cmds\x12\
    \x19\n\x08cmd_args\x18\x05\x20\x03(\tR\x07cmdArgs\"\x1e\n\x08TrackArg\
    \x12\x12\n\x04bits\x18\x05\x20\x01(\x08R\x04bits\"T\n\nTcpdumpArg\x12\
    \x12\n\x04fifo\x18\x05\x20\x01(\tR\x04fifo\x12\x14\n\x05defer\x18\x06\
    \x20\x01(\x08R\x05defer\x12\x1c\n\treconnect\x18\x07\x20\x01(\x08R\treco\
    nnect\"S\n\tPcapngArg\x12\x12\n\x04fifo\x18\x05\x20\x01(\tR\x04fifo\x12\
    \x14\n\x05defer\x18\x06\x20\x01(\x08R\x05defer\x12\x1c\n\treconnect\x18\
    \x07\x20\x01(\x08R\treconnect\"\xcb\x01\n\x0cGateHookInfo\x12\x1d\n\ncla\
    ss_name\x18\x01\x20\x01(\tR\tclassName\x12\x1b\n\thook_name\x18\x02\x20\
    \x01(\tR\x08hookName\x12\x1f\n\x0bmodule_name\x18\x03\x20\x01(\tR\nmodul\
    eName\x12\x16\n\x05igate\x18\x04\x20\x01(\x03H\0R\x05igate\x12\x16\n\x05\
    ogate\x18\x05\x20\x01(\x03H\0R\x05ogate\x12&\n\x03arg\x18\x06\x20\x01(\
    \x0b2\x14.google.protobuf.AnyR\x03argB\x06\n\x04gate\"]\n\x18ConfigureGa\
    teHookRequest\x12)\n\x04hook\x18\x01\x20\x01(\x0b2\x15.bess.pb.GateHookI\
    nfoR\x04hook\x12\x16\n\x06enable\x18\x02\x20\x01(\x08R\x06enable\"U\n\
    \x19ConfigureGateHookResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.\
    bess.pb.ErrorR\x05error\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"j\
    \n\x15ListGateHooksResponse\x12$\n\x05error\x18\x01\x20\x01(\x0b2\x0e.be\
    ss.pb.ErrorR\x05error\x12+\n\x05hooks\x18\x02\x20\x03(\x0b2\x15.bess.pb.\
    GateHookInfoR\x05hooks\"U\n\x16GateHookCommandRequest\x12)\n\x04hook\x18\
    \x01\x20\x01(\x0b2\x15.bess.pb.GateHookInfoR\x04hook\x12\x10\n\x03cmd\
    \x18\x02\x20\x01(\tR\x03cmd\"y\n\x1aConfigureResumeHookRequest\x12\x1b\n\
    \thook_name\x18\x01\x20\x01(\tR\x08hookName\x12\x16\n\x06enable\x18\x02\
    \x20\x01(\x08R\x06enable\x12&\n\x03arg\x18\x03\x20\x01(\x0b2\x14.google.\
    protobuf.AnyR\x03arg\"&\n\x12PauseWorkerRequest\x12\x10\n\x03wid\x18\x01\
    \x20\x01(\x03R\x03wid\"'\n\x13ResumeWorkerRequest\x12\x10\n\x03wid\x18\
    \x01\x20\x01(\x03R\x03wid\"\xb1\x06\n\x17DumpDescriptorsResponse\x12$\n\
    \x05error\x18\x01\x20\x01(\x0b2\x0e.bess.pb.ErrorR\x05error\x12G\n\x07mo\
    dules\x18\x02\x20\x03(\x0b2-.bess.pb.DumpDescriptorsResponse.ModulesEntr\
    yR\x07modules\x12]\n\x0fmodule_commands\x18\x03\x20\x03(\x0b24.bess.pb.D\
    umpDescriptorsResponse.ModuleCommandsEntryR\x0emoduleCommands\x12A\n\x05\
    ports\x18\x04\x20\x03(\x0b2+.bess.pb.DumpDescriptorsResponse.PortsEntryR\
    \x05ports\x1a\xd2\x01\n\x12CommandDescriptors\x12]\n\x08commands\x18\x01\
    \x20\x03(\x0b2A.bess.pb.DumpDescriptorsResponse.CommandDescriptors.Comma\
    ndsEntryR\x08commands\x1a]\n\rCommandsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x126\n\x05value\x18\x02\x20\x01(\x0b2\x20.google.protobu\
    f.DescriptorProtoR\x05value:\x028\x01\x1a\\\n\x0cModulesEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x126\n\x05value\x18\x02\x20\x01(\x0b2\
    \x20.google.protobuf.DescriptorProtoR\x05value:\x028\x01\x1av\n\x13Modul\
    eCommandsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12I\n\x05val\
    ue\x18\x02\x20\x01(\x0b23.bess.pb.DumpDescriptorsResponse.CommandDescrip\
    torsR\x05value:\x028\x01\x1aZ\n\nPortsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x126\n\x05value\x18\x02\x20\x01(\x0b2\x20.google.protobu\
    f.DescriptorProtoR\x05value:\x028\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<
    ::protobuf::descriptor::FileDescriptorProto,
> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| parse_descriptor_proto())
}
