syntax = "proto3";

import "google/protobuf/any.proto";

/// - "timestamp" represents the current time in seconds since the Epoch.
/// (in the same manner as gettimeofday() in C and time.time() in Python)
///
/// - All Responses (including EmptyResponse) messages have an "Error"-type
///   field. Upon a successful RPC the message has the default value
///   (with error code 0). Otherwise the error code has a non-zero value.

package bess.pb;

message EmptyRequest {
}

message EmptyResponse {
  /// Contains a non-zero error code and a non-empty message if and only if
  /// there has been an error
  Error error = 1;
}

message VersionResponse {
  Error error = 1;
  string version = 2;  /// Version of bessd
}

message ImportPluginRequest {
  string path = 1;  /// Path to the module library (*.so file)
}

message UnloadPluginRequest {
  string path = 1;  /// Path to the module library (*.so file)
}

message ListPluginsResponse {
  Error error = 1;
  repeated string paths = 2; /// Paths to the module library (*.so file)
}

message ListWorkersResponse {
  message WorkerStatus {
    int64 wid = 1;      /// Worker ID, starting from 0
    int64 core = 2;     /// CPU core ID on which the worker is pinned
    bool running = 3;   /// True if running, otherwise False.

    /// Number of traffic classes running on the worker
    int64 num_tcs = 4;

    /// Total number of packets that have been silently dropped on the worker.
    /// Silent drops happen when a module transmit packets via disconnected
    /// output gates.
    int64 silent_drops = 5;
  }

  Error error = 1;
  repeated WorkerStatus workers_status = 2;  /// List of all existing workers
}

message AddWorkerRequest {
  int64 wid = 1;         /// Worker ID to be added
  int64 core = 2;        /// CPU core ID on which the worker would run
  string scheduler = 3;  /// Empty string denotes default scheduler.
}

message DestroyWorkerRequest {
  int64 wid = 1;  /// Worker ID
}

message TrafficClass {
  string parent = 1;    /// Name of parent TC
  string name = 2;      /// Name of TC
  bool blocked = 3;     /// Is it running or ready to run at the moment?

  /// One of "priority", "weighted_fair", "round_robin", "rate_limit", "leaf"
  string policy = 4;

  /// Type of resource to regulate. Only used for traffic classes of
  /// weighted_fair and rate_limit types.
  /// Should be one of resource types: "count", "cycle", "packet", "bit"
  string resource = 5;

  oneof arg {
    /// Used by "priority". Lower number == high priority.
    //  FIXME: should be higher number == higher priority, to be consistent
    //         other uses of "priority" in BESS
    int64 priority = 6;

    /// Relative weight (share), used by "weighted_fair".
    /// 1 <= share <= 1024 is recommended. Higher number will result in
    /// lower scheduling accuracy.
    int64 share = 7;
  }

  /// Worker ID that this TC belongs to. If -1, the TC will be assigned
  /// to an arbitrary worker.
  int64 wid = 8;

  //  FIXME: If one can specify limit for only one resource type per TC,
  //         these two fields shouldn't be a map.

  /// Long-term average of resource limit, in cycles/s, packets/s, ...
  map<string, int64> limit = 9;

  /// Burst allowance of resource limit, in cycles, packets, bits, ...
  /// If set to 0, no extra tokens will be saved.
  map<string, int64> max_burst = 10;

  /// Only for "leaf": the task executed by this class.
  string leaf_module_name = 11;
  uint64 leaf_module_taskid = 12;
}

message ListTcsRequest {
  /// Specify a worker thread to fetch traffic classes.
  /// To include all traffic classes on every worker, specify -1.
  int64 wid = 1;
}

message ListTcsResponse {
  message TrafficClassStatus {
    TrafficClass class = 1;
    string parent = 2;  /// Name of its parent TC
  }
  Error error = 1;
  repeated TrafficClassStatus classes_status = 2;
}

message CheckSchedulingConstraintsResponse {
  message ViolatingClass {
    string name = 1;
    int32 constraint = 2;
    int32 assigned_node = 3;
    int32 assigned_core = 4;
  }
  message ViolatingModule { string name = 1; }
  Error error = 1;
  bool fatal = 2;
  repeated ViolatingClass violations = 3;
  repeated ViolatingModule modules = 4;
}

message AddTcRequest {
  TrafficClass class = 1;
}

message UpdateTcParamsRequest {
  TrafficClass class = 1;
}

message UpdateTcParentRequest {
  TrafficClass class = 1;
}

message GetTcStatsRequest {
  string name = 1;  /// Name of TC
}

message GetTcStatsResponse {
  Error error = 1;
  double timestamp = 2;  /// The time that stat counters were read

  /// THe following counters represent the total amount of accumulated resource
  /// usage of a module since its creation.
  uint64 count = 3;    /// # of scheduled times
  uint64 cycles = 4;   /// CPU cycles
  uint64 packets = 5;  /// # of packets
  uint64 bits = 6;     /// # of bits
}

message ListDriversResponse {
  Error error = 1;
  repeated string driver_names = 2;  /// List of availabe port drivers
}

message GetDriverInfoRequest {
  string driver_name = 1;  /// Name of port driver
}

message GetDriverInfoResponse {
  Error error = 1;
  string name = 2;  /// Name of port driver
  string help = 3;  /// 1-line description of the driver
  repeated string commands = 4;  /// List of supported commands (TODO)
}

message ListPortsResponse {
  message Port {
    string name = 1;      /// Name of port
    string driver = 2;    /// Name of port driver.
    string mac_addr = 3;  /// MAC address of the port
  }

  Error error = 1;
  repeated Port ports = 2;  /// List of all existing ports
}

message CreatePortRequest {
  /// Name of the port to create. Every port must have a unique name.
  /// If not specified, a default name will be assigned
  /// (returned via CreatePortResponse for future reference).
  string name = 1;

  /// Name of port driver. Must be specified.
  string driver = 2;

  /// Number of incoming/RX queues (Ext -> BESS). Default is 1
  uint64 num_inc_q = 3;
  /// Number of outgoind/TX queues (BESS -> Ext). Default is 1
  uint64 num_out_q = 4;

  /// Size of each incoming queue (# of packets).
  /// If not set (0), a driver-specific default value will be used.
  uint64 size_inc_q = 5;
  /// Size of each incoming queue (# of packets).
  /// If not set (0), a driver-specific default value will be used.
  uint64 size_out_q = 6;

  /// Driver specific argument for port initialization. See port_msg.proto
  google.protobuf.Any arg = 7;
}

/// All configuration parameters updatable at runtime
message PortConf {
  /// MAC address for the new port. Should be "xx:xx:xx:xx:xx:xx" format.
  /// Set to '00:00:00:00:00:00' to use the default/current MAC address
  string mac_addr = 1;

  /// Port MTU. Set to 0 to accept the default port MTU
  uint32 mtu = 2;

  /// Enable or disable the port.
  /// Both admin and link (operational) states must be up to function
  bool admin_up = 3;
}

message SetPortConfRequest {
  string name = 1;  /// Name of port
  PortConf conf = 2;
}

message GetPortConfRequest {
  string name = 1;  /// Name of port
}

message GetPortConfResponse {
  Error error = 1;
  PortConf conf = 2;
}

message CreatePortResponse {
  Error error = 1;
  string name = 2;      /// Name of the created port (specified or default one)
  string mac_addr = 3;  /// Port MAC address (specified or default one)
}

message DestroyPortRequest {
  string name = 1;  /// Name of port
}

message GetPortStatsRequest {
  string name = 1;  /// Name of port
}

message GetPortStatsResponse {
  message Stat {
    /// Number of objects that have been successfully sent/received.
    /// All counters shows the accumulated value since port initialization.
    uint64 packets = 1;

    /// Number of dropped packets.
    /// For incoming direction, it implies BESS is not picking up fast enough.
    /// For outgoing direction, non-zero drop counter indicates that the "peer"
    /// of this port is the performance bottleneck: namely, VMs/containers/apps
    /// for virtual ports, or PCIe/NIC/link for physical port.
    uint64 dropped = 2;

    /// Total number of bytes, not including Frame CRC or Ethernet overheads
    uint64 bytes = 3;

    // Histogram of how many times a given number of packets in a batch was
    // requested.
    repeated uint64 requested_hist = 4;

    // Histogram of how many times a given number of packets in a batch were
    // actually processed.
    repeated uint64 actual_hist = 5;

    // Histogram of the difference between the requested batch size and the
    // actual number of packets processed in that batch.
    repeated uint64 diff_hist = 6;
  }
  Error error = 1;
  Stat inc = 2;          /// Port stats for incoming (Ext -> BESS) direction.
  Stat out = 3;          /// Port stats for outgoing (BESS -> Ext) direction.
  double timestamp = 4;  /// Time that stat counters were read.
}

message GetLinkStatusRequest {
  string name = 1;       /// name of the port to query
}

message GetLinkStatusResponse {
  Error error = 1;
  uint32 speed = 2;      /// speed in mbps: 1000, 40000, etc. 0 for vports
  bool full_duplex = 3;  /// full-duplex enabled?
  bool autoneg = 4;      /// auto-negotiated speed and duplex?
  bool link_up = 5;      /// link up?
}





message ListMclassResponse {
  Error error = 1;
  repeated string names = 2;  /// List of module types
}

message GetMclassInfoRequest {
  string name = 1;  /// Name of module type
}

message GetMclassInfoResponse {
  Error error = 1;
  string name = 2;               /// Name of module type
  string help = 3;               /// 1=line description of the module type
  repeated string cmds = 4;      /// List of commands supported by the module
  repeated string cmd_args = 5;  /// Corresponding Protobuf message types

  /// FIXME; Should be "repeated ModuleCommand cmds", with the above two grouped
}

message ListModulesResponse {
  message Module {
    string name = 1;    /// Name of module
    string mclass = 2;  /// Module type
    string desc = 3;    /// Current status of module as a short, 1-line string
  }
  Error error = 1;
  repeated Module modules = 2;  /// List of all existing modules
}

message CreateModuleRequest {
  /// Name of the module to create. Every module must have a unique name.
  /// If not specified, a default name will be assigned
  /// (returned via CreateModuleResponse for future reference).
  string name = 1;

  /// Name of module type. Must be specified.
  string mclass = 2;

  /// Protobuf message to be used for module initialization.
  /// See module_msg.proto for the argument message types.
  google.protobuf.Any arg = 3;
}

message CreateModuleResponse {
  Error error = 1;
  string name = 2;  /// Name of the created module (specified or default one)
}

message DestroyModuleRequest {
  string name = 1;  /// Name of module to remove
}

message GetModuleInfoRequest {
  string name = 1;  /// Name of module to query
}

message GetModuleInfoResponse {
  message IGate {
    message OGate {
      uint64 ogate = 1;  /// Output gate of "previous" module
      string name = 2;   /// Name of "previous" module
    }
    uint64 igate = 1;           /// Input gate ID
    repeated OGate ogates = 2;  /// The list of upstream output gates
    uint64 cnt = 3;             /// # of packet batches seen
    uint64 pkts = 4;            /// # of packets seen
    uint64 bytes = 5;            /// # of bytes seen
    double timestamp = 6;       /// The time that cnt/pkts counters were read
  }
  message OGate {
    uint64 ogate = 1;      /// Output gate ID
    uint64 cnt = 2;        /// # of packet batches seen
    uint64 pkts = 3;       /// # of packets seen
    uint64 bytes = 4;      /// # of bytes seen
    double timestamp = 5;  /// The time thatcnt/pkts counters were read
    string name = 6;       /// Name of the "next" module it connects to
    uint64 igate = 7;      /// Input gate ID of the "next" module
  }
  message Attribute {
    string name = 1;   /// Name of per-packet metadata attribute
    uint64 size = 2;   /// Size of attribute (in bytes)
    string mode = 3;   /// "read", "write", or "update"
    int64 offset = 4;  /// (internal debugging purpose only)
  }
  Error error = 1;
  string name = 2;    /// Name of module
  string mclass = 3;  /// Module type
  string desc = 4;    /// Current status of module as a short, 1-line string
  repeated IGate igates = 6;        /// List of connected input gates
  repeated OGate ogates = 7;        /// List of connected output gates
  repeated Attribute metadata = 8;  /// List of metadata used by the module
}

message ConnectModulesRequest {
  string m1 = 1;      /// Name of "previous" module name
  string m2 = 2;      /// name of "next" module name
  uint64 ogate = 3;   /// m1's output gate ID
  uint64 igate = 4;   /// m2's input gate ID
  /// If true do not attach default hooks at the input/output gate.
  /// (Currently, the only default hook is the "track" hook at the ogate)
  bool skip_default_hooks = 5;
}

message DisconnectModulesRequest {
  string name = 1;   /// Name of previous module
  uint64 ogate = 2;  /// Output gate ID of previous module
}

message MempoolDump {
    int32 socket = 1;               /// The socket this mempool belongs to
    bool initialized = 2;           /// True when this mempool has been initialized
    uint32 mp_size = 3;             /// The maximum size of this mempool
    uint32 mp_cache_size = 4;       /// Size of per-lcore default local cache.
    uint32 mp_element_size = 5;     /// Size of one element
    uint32 mp_populated_size = 6;   /// Number of populated objects
    uint32 mp_available_count = 7;  /// Number of entries in this mempool
    uint32 mp_in_use_count = 8;     /// Number of elements which have been allocated from this mempool
    uint32 ring_count = 9;          /// Number of entries in the backing ring
    uint32 ring_free_count = 10;    /// Number of free entries in the backing ring
    uint64 ring_bytes = 11;         /// Size of the backing ring in bytes 
}

message DumpMempoolRequest {
    int32 socket = 1; // ID of the socket whose mempool should be dumped. -1 for all sockets
}

message DumpMempoolResponse {
    Error error = 1;
    repeated MempoolDump dumps = 2; /// The list of requested mempool dumps
}

message CommandRequest {
  string name = 1;              /// Name of module/port/driver
  string cmd = 2;               /// Name of command
  google.protobuf.Any arg = 3;  /// Command argument
}

message CommandResponse {
  Error error = 1;
  google.protobuf.Any data = 2;  /// Command response (see *_msg.proto)
}


//  -------------------------------------------------------------------------
//  Gate hooks
//  -------------------------------------------------------------------------

/// Enable/Disable the "track" hook on a gate (or all gates)
///
/// "track" hook accumulates the number of total packets, batches and bits
///  passing through a gate. This incurs some amount of CPU overheads. While
///  the cost is very small, remember that the delay adds up at every gate.
///
/// NOTE: There should be no running worker to run this command.
message TrackArg {
  bool bits = 5;  /// Tracks bits too if True, else only packets and batches
}

/// Enable/Disable tcpdump tapping at an input/output gate.
///
/// Once the tap is installed, all packets going through the gate will be
/// captured and sent in PCAP format to the specified named pipe (FIFO).
/// Thus you can run `tcpdump -r <path to FIFO>` or save the stream in a file.
/// This feature may affect performance.
///
/// NOTE: There should be no running worker to run this command.
message TcpdumpArg {
  string fifo = 5;    /// Path to the FIFO file.
  bool defer = 6;     /// If set, we'll defer opening the FIFO.
  bool reconnect = 7; /// If set, we'll reconnect after failure.
}

/// Enable/Disable pcapng tapping at an input/output gate.
///
/// Once the tap is installed, all packets going through the gate will be
/// captured and sent in pcapng format to the specified named pipe (FIFO).
/// Unlike the Tcpdump hook, this also dumps a textual metadata representation,
/// in the form of a comment to the Enhanced Packet Block. Thus you can run
/// `tcpdump -r <path to FIFO>` or save the stream in a file.
/// This feature may affect performance.
///
/// NOTE: There should be no running worker to run this command.
message PcapngArg {
  string fifo = 5;    /// Path to the FIFO file.
  bool defer = 6;     /// If set, we'll defer opening the FIFO.
  bool reconnect = 7; /// If set, we'll reconnect after failure.
}


message GateHookInfo {
  string hook_name = 1;         /// Name of the hook
  string module_name = 2;       /// Name of module
  oneof gate {
    int64 igate = 3;            /// Input gate index. All input gates if -1
    int64 ogate = 4;            /// Output gate index. All output gates if -1
  }
  google.protobuf.Any arg = 5;  /// Hook-specific arguments
}

message ConfigureGateHookRequest {
  GateHookInfo hook = 1;
  bool enable = 2;
}

message ListGateHooksResponse {
  Error error = 1;
  repeated GateHookInfo hooks = 2;
}

message GateHookCommandRequest {
  GateHookInfo hook = 1;  // N.B.: this includes the command argument
  string cmd = 2;
}

//  -------------------------------------------------------------------------
//  Resume hooks
//  -------------------------------------------------------------------------

// Enable/Disable a global ResumeHook.
message ConfigureResumeHookRequest {
  string hook_name = 1;         /// Name of the hook
  bool enable = 2;              /// Installs the hook if True, else uninstalls
  google.protobuf.Any arg = 3;  /// Hook-specific arguments
}

//  -------------------------------------------------------------------------
//  Worker maniuplation
//  -------------------------------------------------------------------------

message PauseWorkerRequest {
  int64 wid = 1;    /// ID of the worker to be paused
}

message ResumeWorkerRequest {
  int64 wid = 1;    /// ID of the worker to be resumed
}


message Error {
  int32 code = 1;  // 0 for success, errno (>0) for failure
  string errmsg = 2;
}


// Module-specific messages.
// The header generated from this file should not be included in the BESS core
// source code.

// For your comments to come out in the auto-documentation:
// Format comments with two stars at the top, or use three slashes (///)
// Anything you write will show up as markdown, so feel free to add italics, etc.

/// The module_msg.proto file is stored in `bess/protobuf/` and it supplies the glue between
/// bessd modules and the outside world via GRPC.
/// bessctl uses GRPC to update modules. Whenever you call a function in bessctl, a corresponding function
/// is called on modules in bessd. This file lists all modules, their initialization parameters
/// and any functions that may be called on them.

message EmptyArg {
}

/**
 * The BPF module has a command `clear()` that takes no parameters.
 * This command removes all filters from the module.
 */
message BPFCommandClearArg {
}

/**
 * The ExactMatch module has a command `add(...)` that takes two parameters.
 * The ExactMatch initializer specifies what fields in a packet to inspect; add() specifies
 * which values to check for over these fields.
 * add() inserts a new rule into the ExactMatch module such that traffic matching i
 * that bytestring will be forwarded
 * out a specified gate.
 * Example use: `add(fields=[aton('12.3.4.5'), aton('5.4.3.2')], gate=2)`
 */
message ExactMatchCommandAddArg {
  uint64 gate = 1; /// The gate to forward out packets that mach this rule.
  repeated FieldData fields = 2; /// The exact match values to check for
}

/**
 * The ExactMatch module has a command `delete(...)` which deletes an existing rule.
 * Example use: `delete(fields=[aton('12.3.4.5'), aton('5.4.3.2')])`
 */
message ExactMatchCommandDeleteArg {
  repeated FieldData fields = 2; /// The field values for the rule to be deleted.
}

/**
 * The ExactMatch module has a command `clear()` which takes no parameters.
 * This command removes all rules from the ExactMatch module.
 */
message ExactMatchCommandClearArg {
}

/**
 * The ExactMatch module has a command `set_default_gate(...)` which takes one parameter.
 * This command routes all traffic which does _not_ match a rule to a specified gate.
 * Example use in bessctl: `setDefaultGate(gate=2)`
 */
message ExactMatchCommandSetDefaultGateArg {
  uint64 gate = 1; /// The gate number to send the default traffic out.
}

/**
 * The FlowGen module has a command `set_burst(...)` that allows you to specify
 * the maximum number of packets to be stored in a single PacketBatch released
 * by the module.
 */
message FlowGenCommandSetBurstArg {
  uint64 burst = 1;
}

/**
 * The HashLB module has a command `set_mode(...)` which takes two parameters.
 * The `mode` parameter specifies whether the load balancer will hash over the
 * src/dest ethernet header (l2), over the src/dest IP addresses (l3), or over
 * the flow 5-tuple (l4).  Alternatively, if the `fields` parameter is set, the
 * load balancer will hash over the N-tuple with the specified offsets and
 * sizes.
 * Example use in bessctl: `lb.set_mode('l2')`
 */
message HashLBCommandSetModeArg {
  string mode = 1; /// What fields to hash over, l2, l3, and l4 are only valid values.
  repeated Field fields = 2; /// A list of fields that define a custom tuple.
}

/**
 * The HashLB module has a command `set_gates(...)` which takes one parameter.
 * This function takes in a list of gate numbers to send hashed traffic out over.
 * Example use in bessctl: `lb.setGates(gates=[0,1,2,3])`
 */
message HashLBCommandSetGatesArg {
  repeated int64 gates = 1; ///A list of gate numbers to load balance traffic over
}

/**
 * The IPLookup module has a command `add(...)` which takes three paramters.
 * This function accepts the routing rules -- CIDR prefix, CIDR prefix length,
 * and what gate to forward matching traffic out on.
 * Example use in bessctl: `table.add(prefix='10.0.0.0', prefix_len=8, gate=2)`
 */
message IPLookupCommandAddArg {
  string prefix = 1; /// The CIDR IP part of the prefix to match
  uint64 prefix_len = 2; /// The prefix length
  uint64 gate = 3; /// The number of the gate to forward matching traffic on.
}

/**
 * The IPLookup module has a command `delete(...)` which takes two paramters.
 * This function accepts the routing rules -- CIDR prefix, CIDR prefix length,
 * Example use in bessctl: `table.delete(prefix='10.0.0.0', prefix_len=8)`
 */
message IPLookupCommandDeleteArg {
  string prefix = 1; /// The CIDR IP part of the prefix to match
  uint64 prefix_len = 2; /// The prefix length
}

/**
 * The IPLookup module has a command `clear()` which takes no parameters.
 * This function removes all rules in the IPLookup table.
 * Example use in bessctl: `myiplookuptable.clear()`
 */
message IPLookupCommandClearArg {
}

/**
 * The L2Forward module forwards traffic via exact match over the Ethernet
 * destination address. The command `add(...)`  allows you to specifiy a
 * MAC address and which gate the L2Forward module should direct it out of.
 */
message L2ForwardCommandAddArg {
  message Entry {
    string addr = 1; /// The MAC address to match
    int64 gate = 2; /// Which gate to send out traffic matching this address.
  }
  repeated Entry entries = 1; /// A list of L2Forward entries.
}

/**
 * The L2Forward module has a function `delete(...)` to remove a rule
 * from the MAC forwarding table.
 */
message L2ForwardCommandDeleteArg {
  repeated string addrs = 1; /// The address to remove from the forwarding table
}

/**
 * For traffic reaching the L2Forward module which does not match a MAC rule,
 * the function `set_default_gate(...)` allows you to specify a default gate
 * to direct unmatched traffic to.
 */
message L2ForwardCommandSetDefaultGateArg {
  int64 gate = 1; /// The default gate to forward traffic which matches no entry to.
}

/**
 * The L2Forward module has a function `lookup(...)` to query what output gate
 * a given MAC address will be forwared to; it returns the gate ID number.
 */
message L2ForwardCommandLookupArg {
  repeated string addrs = 1; /// The MAC address to query for
}

/**
 * This message type provides the reponse to the L2Forward function `lookup(..)`.
 * It returns the gate that a requested MAC address is currently assigned to.
 */
message L2ForwardCommandLookupResponse {
  repeated uint64 gates = 1; /// The gate ID that the requested MAC address maps to
}

/**
 * The L2Forward module has a command `populate(...)` which allows for fast creation
 * of the forwarding table given a range of MAC addresses. The function takes in a
 * 'base' MAC address, a count (number of MAC addresses), and a gate_id. The module
 * will route all MAC addresses starting from the base address, up to base+count address
 * round-robin over gate_count total gates.
 * For example, `populate(base='11:22:33:44:00', count = 10, gate_count = 2) would
 * route addresses 11:22:33:44::(00, 02, 04, 06, 08) out a gate 0 and the odd-suffixed
 * addresses out gate 1.
 */
message L2ForwardCommandPopulateArg {
  string base = 1; /// The base MAC address
  int64 count = 2; /// How many addresses beyond base to populate into the routing table
  int64 gate_count = 3; /// How many gates to create in the L2Forward module.
}

/**
 * The Measure module measures and collects latency/jitter data for packets
 * annotated by a Timestamp module. Note that Timestamp and Measure module must reside
 * on the server for accurate measurement (as a result, the most typical use case is
 * measuring roundtrip time).
 * Optionally, you can also retrieve percentile values by specifying points in
 * "percentiles". For example, "percentiles" of [50.0, 99.0] will return
 * [median, 99'th %-ile tail latency] in "percentile_values_ns" in the response.
 */
message MeasureCommandGetSummaryArg {
  bool clear = 1; /// if true, the data will be all cleared after read
  repeated double latency_percentiles = 2; /// ascending list of real numbers in [0.0, 100.0]
  repeated double jitter_percentiles = 3; /// ascending list of real numbers in [0.0, 100.0]
}

/**
 * The Measure module function `get_summary()` returns the following values.
 * Note that the resolution value tells you how grainy the samples are,
 * e.g., 100 means that anything from 0-99 ns counts as "0",
 * anything from 100-199 counts as "100", and so on.  The average
 * is of samples using this graininess, but (being a result of division)
 * may not be a multiple of the resolution.
 */
message MeasureCommandGetSummaryResponse {
  message Histogram {
    uint64 count = 1; /// Total # of measured data points, including above_range
    uint64 above_range = 2; /// # of data points for the "too large value" bucket
    uint64 resolution_ns = 8; /// resolution of measured data
    uint64 min_ns = 3;
    uint64 avg_ns = 4;
    uint64 max_ns = 5;
    uint64 total_ns = 6;
    repeated uint64 percentile_values_ns = 7;
  }

  double timestamp = 1; /// Seconds since boot.
  uint64 packets = 2; /// Total # of packets seen by this module.
  uint64 bits = 3; /// Total # of bits seen by this module.
  Histogram latency = 4;
  Histogram jitter = 5;
}


/**
 * The Module DRR provides fair scheduling of flows based on a quantum which is
 * number of bytes allocated to each flow on each round of going through all flows.
 * Examples can be found [./bessctl/conf/samples/drr.bess]
 * __Input_Gates__: 1
 * __Output_Gates__:  1
 */
message DRRArg {
  uint32 num_flows = 1;  /// Number of flows to handle in module
  uint64 quantum = 2;  /// the number of bytes to allocate to each on every round
  uint32 max_flow_queue_size = 3; /// the max size that any Flows queue can get
}

/**
 * the SetQuantumSize function sets a new quantum for DRR module to operate on.
 */
message DRRQuantumArg {
  uint32 quantum = 1;  /// the number of bytes to allocate to each on every round
}

/**
 * The SetMaxQueueSize function sets a new maximum flow queue size for DRR module.
 * If the flow's queue gets to this size, the module starts dropping packets to
 * that flow until the queue is below this size.
 */
message DRRMaxFlowQueueSizeArg {
  uint32 max_queue_size = 1;  /// the max size that any Flows queue can get
}

/**
 * The module PortInc has a function `set_burst(...)` that allows you to specify the
 * maximum number of packets to be stored in a single PacketBatch released by
 * the module.
 */
message PortIncCommandSetBurstArg {
  uint64 burst = 1; /// The maximum "burst" of packets (ie, the maximum batch size)
}

/**
 * The module QueueInc has a function `set_burst(...)` that allows you to specify
 * the maximum number of packets to be stored in a single PacketBatch released
 * by the module.
 */
message QueueIncCommandSetBurstArg {
  uint64 burst = 1; /// The maximum "burst" of packets (ie, the maximum batch size)
}

/**
 * The module QueueInc has a function `set_burst(...)` that allows you to specify
 * the maximum number of packets to be stored in a single PacketBatch released
 * by the module.
 */
message QueueCommandSetBurstArg {
  uint64 burst = 1; /// The maximum "burst" of packets (ie, the maximum batch size)
}

/**
 * The module QueueInc has a function `set_size(...)` that allows specifying the
 * size of the queue in total number of packets.
 */
message QueueCommandSetSizeArg {
  uint64 size = 1; /// The maximum number of packets to store in the queue.
}

/**
 * Modules that are queues or contain queues may contain functions
 * `get_status()` that return QueueCommandGetStatusResponse.
 */
message QueueCommandGetStatusArg {}

/**
 * Modules that are queues or contain queues may contain functions
 * `get_status()` that take no parameters and returns the queue occupancy and
 * size.
 */
message QueueCommandGetStatusResponse {
  uint64 count = 1;    /// The number of packets currently in the queue.
  uint64 size = 2;     /// The maximum number of packets the queue can contain.
  uint64 enqueued = 3; /// total enqueued
  uint64 dequeued = 4; /// total dequeued
  uint64 dropped = 5;  /// total dropped
}

/**
 * The function `clear()` for RandomUpdate takes no parameters and clears all
 * state in the module.
 */
message RandomUpdateCommandClearArg {
}

/**
 * The function `clear()` for Rewrite takes no parameters and clears all state
 * in the module.
 */
message RewriteCommandClearArg {
}

/**
 * The function `clear()` for Update takes no parameters and clears all state in
 * the module.
 */
message UpdateCommandClearArg {
}

/**
 * The module WildcardMatch has a command `add(...)` which inserts a new rule
 * into the WildcardMatch module. For an example of code using WilcardMatch see
 * `bess/bessctl/conf/samples/wildcardmatch.bess`.
 */
message WildcardMatchCommandAddArg {
  uint64 gate = 1; /// Traffic matching this new rule will be sent to this gate.
  int64 priority = 2; ///If a packet matches multiple rules, the rule with higher priority will be applied. If priorities are equal behavior is undefined.
  repeated FieldData values = 3; /// The values to check for in each fieild.
  repeated FieldData masks = 4; /// The bitmask for each field -- set 0x0 to ignore the field altogether.
}

/**
 * The module WildcardMatch has a command `delete(...)` which removes a rule -- simply specify the values and masks from the previously inserted rule to remove them.
 */
message WildcardMatchCommandDeleteArg {
  repeated FieldData values = 1; /// The values being checked for in the rule
  repeated FieldData masks = 2; /// The bitmask from the rule.
}

/**
 * The function `clear()` for WildcardMatch takes no parameters, it clears
 * all state in the WildcardMatch module (is equivalent to calling delete for all rules)
 */
message WildcardMatchCommandClearArg {
}

/**
 * For traffic which does not match any rule in the WildcardMatch module,
 * the `set_default_gate(...)` function specifies which gate to send this extra traffic to.
 */
message WildcardMatchCommandSetDefaultGateArg {
  uint64 gate = 1;
}

/**
 * The module ACL creates an access control module which by default blocks all traffic, unless it contains a rule which specifies otherwise.
 * Examples of ACL can be found in [acl.bess](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/acl.bess)
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message ACLArg {
  /**
   * One ACL rule is represented by the following 6-tuple.
   */
  message Rule {
    string src_ip = 1;    /// Source IP block in CIDR. Wildcard if "".
    string dst_ip = 2;    /// Destination IP block in CIDR. Wildcard if "".
    uint32 src_port = 3;  /// TCP/UDP source port. Wildcard if 0.
    uint32 dst_port = 4;  /// TCP/UDP Destination port. Wildcard if 0.
    bool established = 5; /// Not implemented
    bool drop = 6;        /// Drop matched packets if true, forward if false. By default ACL drops all traffic.
  }
  repeated Rule rules = 1; ///A list of ACL rules.
}

/**
 * The BPF module is an access control module that sends packets out on a particular gate based on whether they match a BPF filter.
 *
 * __Input Gates__: 1
 * __Output Gates__: many (configurable)
 */
message BPFArg {
  /**
   * One BPF filter is represented by the following 3-tuple.
   */
  message Filter {
    int64 priority = 1; /// The priority level for this rule. If a packet matches multiple rules, it will be forwarded out the gate with the highest priority. If a packet matches multiple rules with the same priority, the behavior is undefined.
    string filter = 2; /// The actual BPF string.
    int64 gate = 3; ///What gate to forward packets that match this BPF to.
  }
  repeated Filter filters = 1; /// The BPF initialized function takes a list of BPF filters.
}

/**
 * The Buffer module takes no parameters to initialize (ie, `Buffer()` is sufficient to create one).
 * Buffer accepts packets and stores them; it may forard them to the next module only after it has
 * received enough packets to fill an entire PacketBatch.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message BufferArg {
}

/**
 * The Bypass module forwards packets by emulating pre-defined packet processing overhead.
 * It burns cpu cycles per_batch, per_packet, and per-bytes.
 * Bypass is useful primarily for testing and performance evaluation.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message BypassArg {
  uint32 cycles_per_batch = 1;
  uint32 cycles_per_packet = 2;
  uint32 cycles_per_byte = 3;
}

/**
 * The Dump module blindly forwards packets without modifying them. It periodically samples a packet and prints out out to the BESS log (by default stored in `/tmp/bessd.INFO`).
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message DumpArg {
  double interval = 1; ///How frequently to sample and print a packet, in seconds.
}

/**
 * The EtherEncap module wraps packets in an Ethernet header, but it takes no parameters. Instead, Ethernet source, destination, and type are pulled from a packet's metadata attributes.
 * For example: `SetMetadata('dst_mac', 11:22:33:44:55) -> EtherEncap()`
 * This is useful when upstream modules wish to assign a MAC address to a packet, e.g., due to an ARP request.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message EtherEncapArg {
}

/**
 * The ExactMatch module splits packets along output gates according to exact match values in arbitrary packet fields.
 * To instantiate an ExactMatch module, you must specify which fields in the packet to match over. You can add rules using the function `ExactMatch.add(...)`
 * Fields may be stored either in the packet data or its metadata attributes.
 * An example script using the ExactMatch code is found
 * in [`bess/bessctl/conf/samples/exactmatch.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/exactmatch.bess).
 *
 * __Input Gates__: 1
 * __Output Gates__: many (configurable)
 */
message ExactMatchArg {
  repeated Field fields = 1; ///A list of ExactMatch Fields
  repeated FieldData masks = 2; /// mask(i) corresponds to the mask for field(i)
}

/**
 * ExactMatchConfig represents the current runtime configuration
 * of an ExactMatch module, as returned by get_runtime_config and
 * set by set_runtime_config.
 */
message ExactMatchConfig {
  uint64 default_gate = 1;
  repeated ExactMatchCommandAddArg rules = 2;
}

/**
 * The FlowGen module generates simulated TCP flows of packets with correct SYN/FIN flags and sequence numbers.
 * This module is useful for testing, e.g., a NAT module or other flow-aware code.
 * Packets are generated off a base, "template" packet by modifying the IP src/dst and TCP src/dst. By default, only the ports are changed and will be modified by incrementing the template ports by up to 20000 more than the template values.
 *
 * __Input Gates__: 0
 * __Output Gates__: 1
 */
message FlowGenArg {
  bytes template = 1; /// The packet "template". All data packets are derived from this template and contain the same payload.
  double pps = 2; /// The total number of packets per second to generate.
  double flow_rate = 3; /// The number of new flows to create every second. flow_rate must be <= pps.
  double flow_duration = 4; /// The lifetime of a flow in seconds.
  string arrival = 5; /// The packet arrival distribution -- must be either "uniform" or "exponential"
  string duration = 6; /// The flow duration distribution -- must be either "uniform" or "pareto"
  bool quick_rampup = 7; /// Whether or not to populate the flowgenerator with initial flows (start generating full pps rate immediately) or to wait for new flows to be generated naturally (all flows have a SYN packet).
  uint32 ip_src_range = 8; /// When generating new flows, FlowGen modifies the template packet by changing the IP src, incrementing it by at most ip_src_range (e.g., if the base packet is 10.0.0.1 and range is 5, it will generate packets with IPs 10.0.0.1-10.0.0.6).
  uint32 ip_dst_range = 9; /// When generating new flows, FlowGen modifies the template packet by changing the IP dst, incrementing it by at most ip_dst_range.
  uint32 port_src_range = 10; /// When generating new flows, FlowGen modifies the template packet by changing the TCP port, incrementing it by at most port_src_range.
  uint32 port_dst_range = 11; /// When generating new flows, FlowGen modifies the template packet by changing the TCP dst port, incrementing it by at most port_dst_range.
}

/**
 * The GenericDecap module strips off the first few bytes of data from a packet.
 *
 * __Input Gates__: 1
 * __Ouptut Gates__: 1
 */
message GenericDecapArg {
  uint64 bytes = 1; /// The number of bytes to strip off.
}

/**
 * The GenericEncap module adds a header to packets passing through it.
 * Takes a list of fields. Each field is either:
 *
 *  1. {'size': X, 'value': Y}          (for constant values)
 *  2. {'size': X, 'attribute': Y}      (for metadata attributes)
 *
 * e.g.: GenericEncap([{'size': 4, 'value': 0xdeadbeef},
 *                     {'size': 2, 'attribute': 'foo'},
 *                     {'size': 2, 'value': 0x1234}])
 * will prepend a 8-byte header:
 *    de ad be ef <xx> <xx> 12 34
 * where the 2-byte <xx> <xx> comes from the value of metadata attribute 'foo'
 * for each packet.
 * An example script using GenericEncap is in [`bess/bessctl/conf/samples/generic_encap.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/generic_encap.bess).
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message GenericEncapArg {
  /**
   * An EncapField represents one field in the new packet header.
   */
  message EncapField {
    uint64 size = 1; /// The length of the field.
    oneof insertion {
      string attribute = 2; /// The metadata attribute name to pull the field value from
      FieldData value = 3; /// Or, the fixed value to insert into the packet.
    }
  }
  repeated EncapField fields = 1;
}

/**
 * The HashLB module partitions packets between output gates according to either
 * a hash over their MAC src/dst (mode=l2), their IP src/dst (mode=l3), the full
 * IP/TCP 5-tuple (mode=l4), or the N-tuple defined by `fields`.
 *
 * __Input Gates__: 1
 * __Output Gates__: many (configurable)
 */
message HashLBArg {
  repeated int64 gates = 1; /// A list of gate numbers over which to partition packets
  string mode = 2; /// The mode (l2, l3, or l4) for the hash function.
  repeated Field fields = 3; /// A list of fields that define a custom tuple.
}

/**
 * Encapsulates a packet with an IP header, where IP src, dst, and proto are filled in
 * by metadata values carried with the packet. Metadata attributes must include:
 * ip_src, ip_dst, ip_proto, ip_nexthop, and ether_type.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message IPEncapArg {
}

/**
 * An IPLookup module perfroms LPM lookups over a packet destination.
 * IPLookup takes no parameters to instantiate.
 * To add rules to the IPLookup table, use `IPLookup.add()`
 *
 * __Input Gates__: 1
 * __Output Gates__: many (configurable, depending on rule values)
 */
message IPLookupArg {
  uint32 max_rules = 1; /// Maximum number of rules (default: 1024)
  uint32 max_tbl8s = 2; /// Maximum number of IP prefixes with smaller than /24 (default: 128)
}

/**
 * An L2Forward module forwards packets to an output gate according to exact-match rules over
 * an Ethernet destination.
 * Note that this is _not_ a learning switch -- forwards according to fixed
 * routes specified by `add(..)`.
 *
 * __Input Gates__: 1
 * __Ouput Gates__: many (configurable, depending on rules)
 */
message L2ForwardArg {
  int64 size = 1; /// Configures the forwarding hash table -- total number of hash table entries.
  int64 bucket = 2; /// Configures the forwarding hash table -- total number of slots per hash value.
}

/**
 * The MACSwap module takes no arguments. It swaps the src/destination MAC addresses
 * within a packet.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message MACSwapArg {
}

/**
 * The measure module tracks latencies, packets per second, and other statistics.
 * It should be paired with a Timestamp module, which attaches a timestamp to packets.
 * The measure module will log how long (in nanoseconds) it has been for each packet it received since it was timsestamped.
 * This module is somewhat experimental and undergoing various changes.
 * There is a test for the the Measure module in [`bessctl/module_tests/timestamp.py`](https://github.com/NetSys/bess/blob/master/bessctl/module_tests/timestamp.py).
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message MeasureArg {
  // int64 warmup = 1; /// removed: instead of warmup delay, user should Clear()
  uint64 offset = 2; /// Where to store the current time within the packet, offset in bytes.
  double jitter_sample_prob = 3; /// How often the module should sample packets for inter-packet arrival measurements (to measure jitter).
  uint64 latency_ns_max = 4; /// maximum latency expected, in ns (default 0.1 s)
  uint32 latency_ns_resolution = 5; /// resolution, in ns (default 100)
}

/**
 * The merge module takes no parameters. It has multiple input gates,
 * and passes out all packets from a single output gate.
 *
 * __Input Gates__: many (configurable)
 * __Output Gates__: 1
 */
message MergeArg {
}

/**
 * The MetadataTest module is used for internal testing purposes.
 */
message MetadataTestArg {
  map<string, int64> read = 1;
  map<string, int64> write = 2;
  map<string, int64> update = 3;
}

/**
 * The NAT module implements Dynamic IPv4 address/port translation,
 * rewriting packet source addresses with external addresses as specified,
 * and destination addresses for packets on the reverse direction.
 * L3/L4 checksums are updated correspondingly.
 * To see an example of NAT in use, see:
 * [`bess/bessctl/conf/samples/nat.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/nat.bess)
 *
 * Currently only supports TCP/UDP/ICMP.
 * Note that address/port in packet payload (e.g., FTP) are NOT translated.
 *
 * __Input Gates__: 2 (0 for internal->external, and 1 for external->internal direction)
 * __Output Gates__: 2 (same as the input gate)
 */
message NATArg {
  message PortRange {
    uint32 begin = 1;
    uint32 end = 2;
    bool suspended = 3;
  }
  message ExternalAddress {
    string ext_addr = 1;
    repeated PortRange port_ranges = 2;
  }
  repeated ExternalAddress ext_addrs = 1; /// list of external IP addresses
}

/**
 * Static NAT module implements one-to-one translation of source/destination
 * IPv4 addresses. No port number is translated.
 * L3/L4 checksums are updated correspondingly.
 * To see an example of NAT in use, see:
 * [`bess/bessctl/conf/samples/nat.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/nat.bess)
 *
 * Forward direction (from input gate 0 to output gate 0):
 *  - Source IP address is updated, from internal to external address.
 * Reverse direction (from input gate 1 to output gate 1):
 *  - Destination IP address is updated, from external to internal address.
 * If the original address is outside any of the ranges, packets are forwarded
 * without NAT.
 *
 * Note that address in packet payload (e.g., FTP) are NOT translated.
 *
 * __Input Gates__: 2 (0 for internal->external, and 1 for external->internal direction)
 * __Output Gates__: 2 (same as the input gate)
 */
message StaticNATArg {
  message AddressRange {
    string start = 1; /// first IP address to use
    string end = 2; /// last IP address to use
  }

  message AddressRangePair {
    AddressRange int_range = 1;
    AddressRange ext_range = 2; /// should be the same size as int_range
  }

  repeated AddressRangePair pairs = 1;
}

/**
 * This module is used for testing purposes.
 */
message NoOpArg {
}

/**
 * The PortInc module connects a physical or virtual port and releases
 * packets from it. PortInc does not support multiqueueing.
 * For details on how to configure PortInc using DPDK, virtual ports,
 * or libpcap, see the sidebar in the wiki.
 *
 * __Input Gates__: 0
 * __Output Gates__: 1
 */
message PortIncArg {
  string port = 1; /// The portname to connect to.
  bool prefetch = 2; /// Whether or not to prefetch packets from the port.
}

/**
 * The PortOut module connects to a physical or virtual port and pushes
 * packets to it. For details on how to configure PortOut with DPDK,
 * virtual ports, libpcap, etc, see the sidebar in the wiki.
 *
 * __Input Gates__: 1
 * __Output Gates__: 0
 */
message PortOutArg {
  string port = 1; /// The portname to connect to.
}

/**
 * The QueueInc produces input packets from a physical or virtual port.
 * Unlike PortInc, it supports multiqueue ports.
 * For details on how to configure QueueInc with DPDK, virtualports,
 * libpcap, etc, see the sidebar in the wiki.
 *
 * __Input Gates__: 0
 * __Output Gates__: 1
 */
message QueueIncArg {
  string port = 1; /// The portname to connect to (read from).
  uint64 qid = 2; /// The queue on that port to read from. qid starts from 0.
  bool prefetch = 3; /// When prefetch is enabled, the module will perform CPU prefetch on the first 64B of each packet onto CPU L1 cache. Default value is false.
}

/**
 * The QueueOut module releases packets to a physical or virtual port.
 * Unlike PortOut, it supports multiqueue ports.
 * For details on how to configure QueueOut with DPDK, virtualports,
 * libpcap, etc, see the sidebar in the wiki.
 *
 * __Input Gates__: 1
 * __Output Gates__: 0
 */
message QueueOutArg {
  string port = 1; /// The portname to connect to.
  uint64 qid = 2; /// The queue on that port to write out to.
}

/**
 * The Queue module implements a simple packet queue.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message QueueArg {
  uint64 size = 1; /// The maximum number of packets to store in the queue.
  bool prefetch = 2; /// When prefetch is enabled, the module will perform CPU prefetch on the first 64B of each packet onto CPU L1 cache. Default value is false.
  bool backpressure = 3; // When backpressure is enabled, the module will notify upstream if it is overloaded.
}

/**
 * The RandomSplit module randomly split/drop packets
 *
 * __InputGates__: 1
 * __Output Gates__: many (configurable)
 */
message RandomSplitArg {
  double drop_rate = 1; /// Probability of dropping packet.
  repeated int64 gates = 2; /// A list of gate numbers to split the traffic.
}

/**
 * The RandomSplit module has a function `set_droprate(...)` which specifies
 * the probability of dropping packets
 */
message RandomSplitCommandSetDroprateArg {
  double drop_rate = 1; /// Probability of dropping packet.
}

/**
 * The RandomSplit module has a function `set_gates(...)` which changes
 * the total number of output gates in the module.
 */
message RandomSplitCommandSetGatesArg {
  repeated int64 gates = 1; /// A list of gate numbers to split the traffic.
}

/**
 * The RandomUpdate module rewrites a specified field (`offset` and `size`) in a packet
 * with a random value between a specified min and max values.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message RandomUpdateArg {
  /**
   * RandomUpdate's Field specifies where to rewrite, and what values to rewrite
   * in each packet processed.
   */
  message Field {
    int64 offset = 1; /// Offset in bytes for where to rewrite.
    uint64 size = 2; /// The number of bytes to write.
    uint64 min = 3; /// The minimum value to insert into the packet.
    uint64 max = 4; /// The maximum value to insert into the packet.
  }
  repeated Field fields = 1; /// A list of Random Update Fields.
}

/**
 * The Rewrite module replaces an entire packet body with a packet "template"
 * converting all packets that pass through to copies of the of one of
 * the templates.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message RewriteArg {
  repeated bytes templates = 1; /// A list of bytestrings representing packet templates.
}

/**
 * The RoundRobin module has a function `set_gates(...)` which changes
 * the total number of output gates in the module.
 */
message RoundRobinCommandSetGatesArg {
  repeated int64 gates = 1; /// A list of gate numbers to round-robin the traffic over.
}

/**
 * The RoundRobin module has a function `set_mode(...)` which specifies whether
 * to balance traffic across gates per-packet or per-batch.
 */
message RoundRobinCommandSetModeArg {
  string mode = 1; /// whether to perform 'packet' or 'batch' round robin partitioning.
}

/**
 * The RoundRobin module splits packets from one input gate across multiple output
 * gates.
 *
 * __Input Gates__: 1
 * __Output Gates__: many (configurable)
 */
message RoundRobinArg {
  repeated int64 gates = 1; /// A list of gate numbers to split packets across.
  string mode = 2; /// Whether to split across gate with every 'packet' or every 'batch'.
}

/**
 * The Replicate module makes copies of a packet sending one copy out over each
 * of n output gates.
 *
 * __Input Gates__: 1
 * __Output Gates__: many (configurable)
 */
message ReplicateArg {
  repeated int64 gates = 1; /// A list of gate numbers to send packet copies to.
}

/**
 * The Replicate module has a function `set_gates(...)` which changes
 * the total number of output gates in the module.
 */
message ReplicateCommandSetGatesArg {
  repeated int64 gates = 1; /// A list of gate numbers to replicate the traffic over.
}

/**
 * The SetMetadata module adds metadata attributes to packets, which are not stored
 * or sent out with packet data. For examples of SetMetadata use, see
 * [`bess/bessctl/conf/attr_match.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/metadata/attr_match.bess)
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message SetMetadataArg {
  /**
   * SetMetadata Attribute describes a metadata attribute and value to attach to every packet.
   * If copying data from a packet buffer, SetMetadata can also logically shift
   * then mask the value before storing it as metadata, i.e.,
   * metadata_value = (packet_value >> `rshift_bits`) & `mask`.
   */
  message Attribute {
    string name = 1; /// The metadata attribute name.
    uint64 size = 2; /// The size of values stored in this attribute in bytes.
    oneof value {
      uint64 value_int = 3; /// An integer value to store in the packet (host-order).
      bytes value_bin = 4; /// A binary value to store in the packet (host-order).
    }
    int32 offset = 5; /// An index in the packet data to store copy into the metadata attribute.
    bytes mask = 6; /// An array of bit masks to apply to each of the bytes copied starting from `offset`. If empty, the mask [0xFF,....,0xFF] will be used.
    int32 rshift_bits = 7; /// The number of bits to shift the value at `offset` by before masking. Must be a multiple of 8. Positive and negative values represent right and left shifts respectively.
  }
  repeated Attribute attrs = 1; /// A list of attributes to attach to the packet.
}

/**
 * The sink module drops all packets that are sent to it.
 *
 * __Input Gates__: 1
 * __Output Gates__: 0
 */
message SinkArg {
}

/**
 * The Source module has a function `set_burst(...)` which
 * specifies the maximum number of packets to release in a single packetbatch
 * from the module.
 *
 * __Input Gates__: 0
 * __Output Gates__: 1
 */
message SourceCommandSetBurstArg {
  uint64 burst = 1; /// The maximum number of packets to release in a packetbatch from the module.
}

/**
 * The Source module has a function `set_pkt_size(...)` which specifies the size
 * of packets to be produced by the Source module.
 */
message SourceCommandSetPktSizeArg {
  uint64 pkt_size = 1; /// The size (in bytes) of the packets for Source to create.
}

/**
 * The Source module generates packets with no payload contents.
 */
message SourceArg {
  uint64 pkt_size = 1; /// The size (in bytes) of packet data to produce.
}

/**
 * The Split module is a basic classifier which directs packets out a gate
 * based on data in the packet (e.g., if the read in value is 3, the packet
 * is directed out output gate 3).
 *
 * __Input Gates__: 1
 * __Output Gates__: many (up to 2^(size * 8))
 */
message SplitArg {
  uint64 size = 1; /// The size of the value to read in bytes
  oneof type {
    string attribute = 2; /// The name of the metadata field to read.
    int64 offset = 3; /// The offset (in bytes) of the data field to read.
  }
}

/**
 * The timestamp module takes an offset parameter. It inserts the current
 * time in nanoseconds into the packet, to be used for latency measurements
 * alongside the Measure module.  The default offset is after an IPv4 UDP
 * header.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message TimestampArg {
  uint64 offset = 1;
}

/**
 * The Update module rewrites a field in a packet's data with a specific value.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message UpdateArg {
  /**
   * Update Field describes where in a packet's data to rewrite, and with what value.
   */
  message Field {
    int64 offset = 1; /// The offset in the packet in bytes to rewrite at.
    uint64 size = 2; /// The number of bytes to rewrite (max 8 bytes).
    uint64 value = 3; /// The value to write into the packet, max 8 bytes.
  }
  repeated Field fields = 1; /// A list of Update Fields.
}

/**
 * The URLFilter performs TCP reconstruction over a flow and blocks
 * connections which mention a banned URL.
 *
 * __Input Gates__: 2
 * __Output Gates__: 2
 *
 * Note that the add() command takes this same argument, and the
 * clear() command takes an empty argument.
 */
message UrlFilterArg {
  /**
   * A URL consists of a host and a path.
   */
  message Url {
    string host = 1;  /// Host field, e.g. "www.google.com"
    string path = 2;  /// Path prefix, e.g. "/"
  }
  repeated Url blacklist = 1; /// A list of Urls to block.
}

/**
 * The runtime configuration of a URLFilter is the current
 * blacklist.  This means that getting the Arg gets an *empty*
 * list: we assume anyone using get_initial_arg is also using
 * get_runtime_config.
 */
message UrlFilterConfig {
  repeated UrlFilterArg.Url blacklist = 1;
}

/**
 * VLANPop removes the VLAN tag.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message VLANPopArg {
}

/**
 * VLANPush appends a VLAN tag with a specified TCI value.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message VLANPushArg {
  uint64 tci = 1; /// The TCI value to insert in the VLAN tag.
}

/**
 * Splits packets across output gates according to VLAN id (e.g., id 3 goes out gate 3.
 *
 * __Input Gates__: 1
 * __Output Gates__: many
 */
message VLANSplitArg {
}

/**
 * VXLANDecap module decapsulates a VXLAN header on a packet.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message VXLANDecapArg {
}

/**
 * VXLANEncap module wraps a packet in a VXLAN header with a specified destination port.
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message VXLANEncapArg {
  uint64 dstport = 1; /// The destination UDP port
}

/**
 * The WildcardMatch module matches over multiple fields in a packet and
 * pushes packets that do match out specified gate, and those that don't out a default
 * gate. WildcardMatch is initialized wtih the fields it should inspect over,
 * rules are added via the `add(...)` function.
 * An example of WildcardMatch is in [`bess/bessctl/conf/samples/wildcardmatch.bess`](https://github.com/NetSys/bess/blob/master/bessctl/conf/samples/wildcardmatch.bess)
 *
 * __Input Gates__: 1
 * __Output Gates__: many (configurable)
 */
message WildcardMatchArg {
  repeated Field fields = 1; /// A list of WildcardMatch fields.
}

/**
 * WildcardMatchConfig represents the current runtime configuration
 * of a WildcardMatch module, as returned by get_runtime_config and
 * set by set_runtime_config.
 */
message WildcardMatchConfig {
  uint64 default_gate = 1;
  repeated WildcardMatchCommandAddArg rules = 2;
}

/**
 * The ARP Responder module is responding to ARP requests
 * TODO: Dynamic learn new MAC's-IP's mapping
 *
 * __Input Gates__: 1
 * __Output Gates__: 1
 */
message ArpResponderArg {
  /**
   * One ARP IP-MAC mapping
   */
  string ip = 1; // The IP
  string mac_addr = 2; /// The MAC address
}

/**
 * The MPLS pop module removes MPLS labels
 *
 * __Input Gates__: 1
 * __Output Gates__: 2
 */
message MplsPopArg {
  bool remove_eth_header = 1; // Remove ETH header with the pop
  uint32 next_eth_type = 2; /// The next ETH type to set
}

/**
 * WorkerSplit splits packets based on the worker calling ProcessBatch(). It has
 * two modes.
 * 1) Packets from worker `x` are mapped to output gate `x`. This is the default
 *    mode.
 * 2) When the `worker_gates` field is set, packets from a worker `x` are mapped
 *    to `worker_gates[x]`.  In this mode, packet batches from workers not
 *    mapped to an output gate will be dropped.
 *
 * Calling the `reset` command with an empty `worker_gates` field will revert
 * WorkerSplit to the default mode.
 *
 * __Input Gates__: 1
 * __Output Gates__: many
 */
message WorkerSplitArg {
  map<uint32, uint32> worker_gates = 1; // ogate -> worker mask
}



service BESSControl {

  //  -------------------------------------------------------------------------
  //  System
  //  -------------------------------------------------------------------------

  /// Query version of bessd
  rpc GetVersion (EmptyRequest) returns (VersionResponse) {}

  /// Reset the current packet processing datapath to the initial state.
  ///
  /// This command is identical to the following sequence:
  ///   ResetModules()
  ///   ResetPorts()
  ///   ResetTcs()
  ///   ResetWorkers()
  /// As it clears everything, BESS should appear as if the daemon has freshly
  /// started (if not, it is a bug; please report).
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc ResetAll (EmptyRequest) returns (EmptyResponse) {}

  /// Terminate the BESS daemon.
  ///
  /// BESS daemon shuts off in a graceful manner. Note that this command is
  /// "asynchronous": this command doesn't block until the BESS daemon has
  /// shut off.
  ///
  /// NOTE: There should be no running worker to run this command.
  /// FIXME: rename (e.g., Terminate)
  rpc KillBess (EmptyRequest) returns (EmptyResponse) {}

  /// Import a plugin
  ///
  /// At the moment plugins can only contain module types,
  /// but might also support drivers/hooks/schedulers in the future.
  rpc ImportPlugin (ImportPluginRequest) returns (EmptyResponse) {}

  /// Unload a plugin
  ///
  /// At the moment plugins can only contain module types,
  /// but might also support drivers/hooks/schedulers in the future.
  rpc UnloadPlugin (UnloadPluginRequest) returns (EmptyResponse) {}

  /// List imported plugins
  ///
  /// At the moment plugins can only contain module types,
  /// but might also support drivers/hooks/schedulers in the future.
  rpc ListPlugins (EmptyRequest) returns (ListPluginsResponse) {}


  //  -------------------------------------------------------------------------
  //  Worker
  //  -------------------------------------------------------------------------

  /// Pause all running workers temporarily
  ///
  /// Some RPC commands to BESS or individual modules/ports require that
  /// threads must be inactive, to avoid race conditions.
  /// For such commands, use PauseALl at the beginning and ResumeAll at the end.
  ///  PauseAll()
  ///   SomeCommand1()
  ///   SomeCommand2()
  ///   ...
  ///  ResumeAll()
  /// Keep the duration as short as possible, to avoid packet drops.
  rpc PauseAll (EmptyRequest) returns (EmptyResponse) {}

  /// Pause the specified worker temporarily
  ///
  /// Some RPC commands to BESS or individual modules/ports require that
  /// threads must be inactive, to avoid race conditions.
  /// For such commands, use PauseWorker at the beginning and ResumeWorker at the end.
  ///  PauseWorker(0)
  ///   SomeCommand1()
  ///   SomeCommand2()
  ///   ...
  ///  ResumeWorker(0)
  /// Keep the duration as short as possible, to avoid packet drops.
  rpc PauseWorker (PauseWorkerRequest) returns (EmptyResponse) {}

  /// Resume the specified worker
  rpc ResumeWorker (ResumeWorkerRequest) returns (EmptyResponse) {}

  /// Resume all paused workers
  rpc ResumeAll (EmptyRequest) returns (EmptyResponse) {}

  /// Remove all existing workers
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc ResetWorkers (EmptyRequest) returns (EmptyResponse) {}

  /// Enumerate all existing workers
  rpc ListWorkers (EmptyRequest) returns (ListWorkersResponse) {}

  /// Create a new worker
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc AddWorker (AddWorkerRequest) returns (EmptyResponse) {}

  /// Remove a single worker
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc DestroyWorker (DestroyWorkerRequest) returns (EmptyResponse) {}


  //  -------------------------------------------------------------------------
  //  Traffic classe & task
  //  -------------------------------------------------------------------------

  /// Remove all existing traffic classes
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc ResetTcs (EmptyRequest) returns (EmptyResponse) {}

  /// Enumerate all existing workers
  rpc ListTcs (ListTcsRequest) returns (ListTcsResponse) {}

  /// Check scheduling contraints
  rpc CheckSchedulingConstraints (EmptyRequest) returns (CheckSchedulingConstraintsResponse) {}

  /// Create a new traffic class
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc AddTc (AddTcRequest) returns (EmptyResponse) {}

  /// Update parameters of an existing traffic class
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc UpdateTcParams (UpdateTcParamsRequest) returns (EmptyResponse) {}

  /// Change parent (and child arguments) of an existing traffic class
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc UpdateTcParent (UpdateTcParentRequest) returns (EmptyResponse) {}

  /// Collect statistics of a traffic class
  rpc GetTcStats (GetTcStatsRequest) returns (GetTcStatsResponse) {}


  //  -------------------------------------------------------------------------
  //  Port
  //  -------------------------------------------------------------------------

  /// Enumerate all port drivers available
  rpc ListDrivers (EmptyRequest) returns (ListDriversResponse) {}

  /// Query detailed information of a port driver
  rpc GetDriverInfo(GetDriverInfoRequest) returns (GetDriverInfoResponse) {}

  /// Remove all initialized ports
  ///
  /// Will fail if there are modules that are still using ports.
  /// (e.g., PortInc, PortOut, QueueInc, QueueOut)
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc ResetPorts (EmptyRequest) returns (EmptyResponse) {}

  /// Enumerate all initialized ports
  rpc ListPorts (EmptyRequest) returns (ListPortsResponse) {}

  /// Create a new port from the specified driver
  rpc CreatePort (CreatePortRequest) returns (CreatePortResponse) {}

  /// Remove a port
  ///
  /// The port should not be being used by a port-related module.
  /// (e.g., PortInc, PortOut, QueueInc, QueueOut)
  rpc DestroyPort (DestroyPortRequest) returns (EmptyResponse) {}

  /// Runtime-updatable configuration
  rpc SetPortConf (SetPortConfRequest) returns (EmptyResponse) {}
  rpc GetPortConf (GetPortConfRequest) returns (GetPortConfResponse) {}

  /// Collect port statistics
  ///
  /// At the moment, per-queue stats are not supported.
  rpc GetPortStats (GetPortStatsRequest) returns (GetPortStatsResponse) {}

  /// Query link status
  rpc GetLinkStatus (GetLinkStatusRequest) returns (GetLinkStatusResponse) {}

  // TODO: Add PortCommand, like ModuleCommand, which performs driver-specific
  //       actions on a port.


  //  -------------------------------------------------------------------------
  //  Module
  //  -------------------------------------------------------------------------

  /// Enumerate all module types available
  rpc ListMclass (EmptyRequest) returns (ListMclassResponse) {}

  /// Query detailed information of a module type
  rpc GetMclassInfo (GetMclassInfoRequest) returns (GetMclassInfoResponse) {}

  /// Remove all modules.
  ///
  /// This RPC will always succeed (unless there is a running worker)
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc ResetModules (EmptyRequest) returns (EmptyResponse) {}

  /// Enumerate all initialized modules
  rpc ListModules (EmptyRequest) returns (ListModulesResponse) {}

  /// Create a new module instance from the given module type
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc CreateModule (CreateModuleRequest) returns (CreateModuleResponse) {}

  /// Destroy an exsting module
  ///
  /// If the module is connected to other modules' input/output gate, they are
  /// disconnected first. All tasks created by the module will also be destoyed.
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc DestroyModule (DestroyModuleRequest) returns (EmptyResponse) {}

  /// Fetch detailed information of an module instance
  rpc GetModuleInfo (GetModuleInfoRequest) returns (GetModuleInfoResponse) {}

  /// Connect two modules.
  ///
  /// Connect between m1's ogate and n2's igate (i.e., ackets sent to m1's ogate
  /// will be fed to m2's igate). The oate can be connected to only one igate,
  /// while the igate can be connected to multiple output gates.
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc ConnectModules (ConnectModulesRequest) returns (EmptyResponse) {}

  /// Disconnect two modules.
  ///
  /// It removes a connection between two modules (you specify the previous one
  /// and its output gate). All packets coming out from the ogate will be
  /// dropped. Once disconnected, the ogate can be connected
  /// to any input gate.
  ///
  /// NOTE: There should be no running worker to run this command.
  rpc DisconnectModules (DisconnectModulesRequest) returns (EmptyResponse) {}

  /// Dump various stats about BESS's packet pools
  rpc DumpMempool (DumpMempoolRequest) returns (DumpMempoolResponse) {}

  /// Send a command to the specified module instance.
  ///
  /// Each module type defines a list of modyle-specific commands, which
  /// allow external programs to communicate with the module at runtime.
  /// See module_msg.proto for details.
  ///
  /// NOTE: Some commands cannot be used if there are running workers.
  ///       For those commands you must pause all workers first.
  rpc ModuleCommand (CommandRequest) returns (CommandResponse) {}

  //  -------------------------------------------------------------------------
  //  Gate hooks
  //  -------------------------------------------------------------------------

  /// Enable/Disable a gate hook.
  rpc ConfigureGateHook (ConfigureGateHookRequest) returns (CommandResponse) {}

  /// Enable/Disable a gate hook.
  rpc ListGateHooks (EmptyRequest) returns (ListGateHooksResponse) {}

  /// Send command to gate hook instance.
  rpc GateHookCommand (GateHookCommandRequest) returns (CommandResponse) {}

  //  -------------------------------------------------------------------------
  //  Resume hooks
  //  -------------------------------------------------------------------------

  /// Enable/Disable a resume hook.
  rpc ConfigureResumeHook (ConfigureResumeHookRequest) returns (CommandResponse) {}
}
/// This file contains some standard "types" for messages to/from BESS


/// The Field message represents one field in a packet -- either stored in metadata or in the packet body.
message Field {
  oneof position {
    string attr_name = 1; /// The metadata attribute assigned to store the data
    uint32 offset = 2; /// The offset in bytes to store the data into
  }
  uint32 num_bytes = 3; /// The size of the data in bytes
}

/// The FieldData message encodes a value to insert into a packet; the value can be supplied as either an int or a bytestring.
message FieldData {
  oneof encoding {
    bytes value_bin = 1; /// The value as a bytestring
    uint64 value_int = 2; /// The value in integer format
  }
}



message PCAPPortArg {
  string dev = 1;
}

message PMDPortArg {
  bool loopback = 1;
  oneof port {
    uint64 port_id = 2;
    string pci = 3;
    string vdev = 4;
  }

  // See http://dpdk.org/doc/dts/test_plans/dual_vlan_test_plan.html
  bool vlan_offload_rx_strip = 5;
  bool vlan_offload_rx_filter = 6;
  bool vlan_offload_rx_qinq = 7;
}

message UnixSocketPortArg {
  /// Set the first character to "@" in place of \0 for abstract path
  /// See manpage for unix(7).
  string path = 1;

  /// Minimum RX polling interval for system calls, when *idle*.
  /// Use a negative number for unthrottled polling. If unspecified or 0,
  /// it is set to 50,000 (50 microseconds, or 20k polls per second)
  int64 min_rx_interval_ns = 2;

  /// If set, the port driver will send a confirmation once
  /// the port is connected.  This lets pybess avoid a race during
  /// testing.  See bessctl/test_utils.py for details.
  bool confirm_connect = 3;
}

message ZeroCopyVPortArg {

}

message VPortArg {
  string ifname = 1;
  oneof cpid {
    string docker = 2;
    int64 container_pid = 3;
    string netns = 4;
  }
  repeated int64 rxq_cpus = 5;
  uint64 tx_tci = 6;
  uint64 tx_outer_tci = 7;
  bool loopback = 8;
  repeated string ip_addrs = 9;
}
